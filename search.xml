<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库事务处理要点记录]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1.SQL 事务流程图： 2.对于声明式事务，是使用 @Transactional 进行标注的。可以标注类或方法，当它标注在类上时，代表这个类的所有公共非静态的方法都将启动事务功能 3.需要在启动文件中定义事务管理器，一般不需要自己创建而直接使用 IOC 容器中的 Bean 进行装配 4.@PostConstruct：后初始化方法，类对象被初始化后调用 5.数据库事务的四个基本特征：ACID&emsp;&emsp;Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性） 6.并发操作数据时会出现两类丢失更新：第一类丢失更新和第二类丢失更新&emsp;&emsp;第一类丢失更新：一个事务回滚另外一个事务提交而引发的数据不一致的情况（目前大部分数据库已经克服了这类问题） 时刻 事务1 事务2 T1 初始库存100 初始库存100 T2 扣减库存，余99 - T3 - 扣减库存，余99 T4 - 提交事务，库存变为99 T5 回滚事务，库存100 - &emsp;&emsp;第二类丢失更新：多个事务都提交引发的丢失更新 时刻 事务1 事务2 T1 初始库存100 初始库存100 T2 扣减库存，余99 - T3 - 扣减库存，余99 T4 - 提交事务，库存变为99 T5 提交事务，库存变为99 - 7.隔离级别：&emsp;&emsp;未提交读、读写提交、可重复读、串行化&emsp;&emsp;① 未提交读：允许一个事务读取另一个事务没有提交的数据&emsp;&emsp;危险的隔离级别，并发能力高，但是会出现脏读难以保证数据一致性&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;脏读现象 时刻 事务1 事务2 备注 T0 …… …… 商品库存初始化为2 T1 读取库存为2 - - T2 扣减库存 - 库存为1 T3 - 扣减库存 库存为0，读取事务1未提交的库存数据 T4 - 提交事务 库存保存为0 T5 回滚事务 - 因为第一类丢失更新已经克服，所以不会回滚为2，库存为0，结果错误 &emsp;&emsp;② 读写提交：一个事务只能读取另外一个事务已经提交的数据，不能读取未提交的数据&emsp;&emsp;克服脏读现象，但是无法解决不可重复读现象&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;克服脏读 时刻 事务1 事务2 备注 T0 …… …… 商品库存初始化为2 T1 读取库存为2 - - T2 扣减库存 - 库存为1 T3 - 扣减库存 库存为1，读取不到事务1未提交的库存数据 T4 - 提交事务 库存保存为1 T5 回滚事务 - 因为第一类丢失更新已经克服，所以不会回滚为2，库存为1，结果正确 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;不可重复读现象 时刻 事务1 事务2 备注 T0 …… …… 商品库存初始化为1 T1 读取库存为1 - - T2 扣减库存 - 事务未提交 T3 - 读取库存为1 认为可扣减 T4 提交事务 - 库存变为0 T5 - 扣减库存 失败，因为此时库存为0，无法扣减 &emsp;&emsp;③ 可重复读：克服不可重复读现象，无法解决幻读现象&emsp;&emsp;&emsp;&emsp;克服不可重复读 时刻 事务1 事务2 备注 T0 …… …… 商品库存初始化为1 T1 读取库存为1 - - T2 扣减库存 - 事务未提交 T3 - 尝试读取库存 不允许读取，等待事务1提交 T4 提交事务 - 库存变为0 T5 - 读取库存 库存为0，无法扣减 &emsp;&emsp;&emsp;&emsp;幻读现象 时刻 事务1 事务2 备注 T1 读去库存50件 - 商品库存初始化为100，现在已经销售50笔，库存50件 T2 - 查询交易记录，50笔 - T3 扣减库存 - - T4 插入1笔交易记录 - - T5 提交事务 - 库存49件，交易记录51笔 T6 - 打印交易记录，51笔 这里与查询的不一致，在事务2看来有1笔试虚幻的，与之前查询的不一致 &emsp;&emsp;ps：这里的笔数是一个统计值而不是数据库存储的值，商品库存是数据库存储的值&emsp;&emsp;&emsp;&emsp;幻读针对多条记录而言&emsp;&emsp;&emsp;&emsp;可重复读是针对数据库的单一条记录&emsp;&emsp;④ 串行化：数据库最高的隔离级别，要求所有的 SQL 都按照顺序执行，能够完全保证数据的一致性&emsp;&emsp;&emsp;&emsp;隔离级别和可能发生的现象 项目类型 脏读 不可重复读 幻读 未提交读 √ √ √ 读写提交 × √ √ 可重复读 × × √ 串行化 × × × &emsp;&emsp;ps：追求更高的隔离级别，它能更好地保证了数据的一致性，但是也要付出锁的代价。有了锁，就意味着性能的丢失 Spring Boot 可以通过配置文件指定默认的隔离级别12345678910# 隔离级别数字配置的含义：# -1: 数据库默认隔离级别# 1: 未提交读# 2: 读写提交# 3: 可重复读# 4: 串行化# tomcat 数据源默认隔离级别spring.datasource.tomcat.default-transaction-isolation=2# dbcp2 数据库连接池默认隔离级别# spring.datasource.dbcp2.default-transaction-isolation=2 8.传播行为：在 Spring 事务机制中对数据库存在 7 中传播行为，它是通过枚举类 Propagation 定义的1234567891011121314151617181920212223242526272829303132333435363738394041/*** 需要事务，是默认传播行为* 如果当前存在事务，就沿用当前事务，否则新建一个事务运行子方法**/REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED)/*** 支持事务* 如果当前存在事务，就沿用当前事务，如果不存在，则继续采用无事务的方式运行子方法**/SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS)/*** 必须使用事务* 如果当前存在事务，就沿用当前事务，如果不存在，则会抛出异常**/MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY)/*** 无论当前事务是否存在，都会创建新事务运行方法* 新事务可以拥有新的锁和隔离级别等特性，与当前事务相互独立**/REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW)/*** 不支持事务* 当前存在事务时，将挂起事务，运行方法**/NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED)/*** 不支持事务* 如果当前方法存在异常，则抛出异常，否则继续使用无事务机制运行**/NEVER(TransactionDefinition.PROPAGATION_NEVER)/*** 在当前方法调用子方法时，如果子方法发生异常* 只回滚子方法执行过的 SQL，而不回滚当前方法的事务**/NESTED(TransactionDefinition.PROPAGATION_NESTED) 9.@Transactional 自调用失效问题：&emsp;&emsp;如果两个标注了@Transactional 但是，是一个类中的方法之间的调用，即自调用，会存在被调用方法 @Transactional 失效问题&emsp;&emsp;原因：&emsp;&emsp;&emsp;&emsp;Spring 数据库事务的约定，其实现原理是 AOP，AOP 的原理是动态代理，自调用时是类自身的调用，不是代理对象去调用，不会产生 AOP，所以导致 @Transactional 失效&emsp;&emsp;解决：&emsp;&emsp;&emsp;&emsp;① 使用一个 Service 去调用另一个 Service&emsp;&emsp;&emsp;&emsp;② 从 Spring IOC 容器中获取代理对象去启用 AOP]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>springBoot</tag>
        <tag>事务处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全注解下的 Spring IOC 要点记录]]></title>
    <url>%2F2018%2F11%2F19%2F%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84-Spring-Ioc%2F</url>
    <content type="text"><![CDATA[1.Spring 的两大特性：IOC（Inversion of control， 控制反转） 和 AOP（Aspect Oriented Programming， 面向切面编程） 2.IOC 是一种通过描述来生成或获取对象的技术 3.Spring Boot 主要通过注解的描述生成对象，而 Spring 主要通过 XML 和 Java 配置文件（在类名上加入 @Configuration 注解来使其变为配置类）来配置生成对象 4.在 Spring IOC 容器中， Bean 默认为单例存在且 Bean 名称是其在 IOC 容器中的唯一标识 5.POJO（Plain Ordinary Java Object）： Java 简单对象 6.@Configuration：代表是一个 Java 配置文件 7.@Component：标明哪个类被扫描进入 Spring IOC 容器&emsp;&emsp;@ComponentScan：标明采用何种策略去扫描装配 Bean&emsp;&emsp;&emsp;&emsp;basePackageClasses 参数可以用正则式去匹配包名&emsp;&emsp;&emsp;&emsp;includeFilters 和 excludeFilters 参数定义满足（或不满足）过滤器条件的 Bean 才去扫描，需要通过一个注解 @Filter 去定义&emsp;&emsp;&emsp;&emsp;可以通过配置 lazyInit 设置是否在 Bean 定以后完成实例化及依赖注入，默认为不延迟初始化（false） 12345# classes 定义注解类# pattern 定义正则式类@ComponentScan(basePackages = &quot;com.springboot.*&quot;, excludeFilters = &#123;@Filter(classes = &#123;Service.class&#125;, pattern = &quot;&quot;)&#125;)# 标注了 @Service 的类将不被 IOC 容器扫描注入 8.@Service 注解注入了 @Component， 即标注了 @Service 的类在默认情况下可以被 Spring IOC 容器扫描装配，无需再加入 @Component 注解&emsp;&emsp;@SpringBootApplication 注入了 @ComponentScan。启动类可以同时加入这两个注解来配置扫描包 9.可以通过 @Bean 将第三方包中的类对象放入 Spring IOC 容器中&emsp;&emsp;Spring 会将该方法返回的 DataSource 对象用名称 “dataSource” 保存在 IOC 容器中（未配置 name 属性时以方法名为名称保存） 1234567891011121314151617181920@Configurationpublic class AppConfig&#123; @Bean(name = "dataSource") public DataSource getDataSource()&#123; Properties props = new Properties(); props.setProperty("driver", "com.mysql.jdbc.Driver"); props.setProperty("url", "jdbc:mysql://localhost:3306/xxx"); props.setProperty("username", "root"); props.setProperty("password", "root"); DataSource dataSource = null; try&#123; dataSource = BasicDataSourceFactory.createDataSource(props); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return dataSource; &#125; &#125; 10.@Autowired：默认必须找到对应 Bean，可以设置 required 属性配置是否必须找到，默认为 true&emsp;&emsp;匹配机制：@Autowired 可以标注属性（注入属性）、方法（注入参数）、方法参数（注入参数） 11.装配：将 Bean 放入 Spring IOC 容器中&emsp;&emsp;注入：从 Spring IOC 容器中找出 Bean 赋值 12.消除歧义：&emsp;&emsp;@Primary：是的 POJO 注入优先级更高，标注 POJO 类名&emsp;&emsp;@Qualifier：利用 type + BeanName 在 IOC 容器进行查找装配，无视优先级，标注属性 123456......@Component@Primarypublic class Cat implements Animal&#123; ......&#125; 123@Autowired@Qualifier(&quot;dog&quot;)private Animal animal = null; 13.第三方类可以用 @Bean 来配置自定义初始化和销毁方法 14.Bean 的生命周期：&emsp;&emsp;Bean 定义：资源定位 –&gt; 解析 –&gt; 将Bean发布至 IOC 容器&emsp;&emsp;Bean 初始化：实例化 –&gt; 依赖注入&emsp;&emsp;Bean 生存期&emsp;&emsp;Bean 的销毁 15.使用属性文件：&emsp;&emsp;@Value：为属性或方法参数赋值，可以标注属性或方法（@Autowired 也可以标注属性或方法）&emsp;&emsp;@ConfigurationProperties(“xx”)：将匹配字符串与属性名组成的全限定名去配置文件中查找&emsp;&emsp;&emsp;&emsp;eg： “xx.属性名”&emsp;&emsp;@Property(value={“”}, ignoreResourceFound=false)：配置要查找的配置文件，可以通过 value 配置多个配置文件&emsp;&emsp;&emsp;&emsp;classpath:xx //类文件路径&emsp;&emsp;&emsp;&emsp;ignoreResourceFound：是否忽略配置文件找不到的问题，默认为 false 16.条件装配 Bean：用 @Conditional 注解配合 Condition 接口来完成&emsp;&emsp;@Conditional(xxx.class)：xxx 类必须实现 Condition 接口，即实现其 matches 方法&emsp;&emsp;&emsp;&emsp;matches 方法工作原理：&emsp;&emsp;&emsp;&emsp;matches 方法返回值为 boolean 类型；true：装配， false: 不装配17.作用域：&emsp;&emsp;Web 容器的四种作用域：页面（page）；请求（request）；会话（session）；应用（application）&emsp;&emsp;Spring 不支持 page 作用域 18.在 Spring 中可以用 singleton 作用域 代替 application 作用域 19.@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)：设置作用域，默认为单例（singleton）作用域&emsp;&emsp;ConfigurableBeanFactory 只能提供单例（SCOPE_SINGLETON）和原型（SCOPE_PROTOTYPE）两种作用域20.SpringBoot 引入 XML 配置 Bean：&emsp;&emsp;@ImportResource(value = “”)：引入该 XML 文件并将该文件中定义的 Bean 装配至 IOC 容器中 21.Spring EL：&emsp;&emsp;’${}’：占位符，读取属性&emsp;&emsp;’#{}’：Spring 表达式，可以在其中进行运算，调用方法 12# ?: 判断这个属性是否为空，不为空时执行 toUpperCase() 方法@Value(&quot;#&#123;beanName.str?.toUpperCase()&#125;&quot;)]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>springBoot</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BindingException 解决方法]]></title>
    <url>%2F2018%2F11%2F18%2FBindingException-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[报错原因：1org.apache.ibatis.binding.BindingException: Parameter 'name' not found. Available parameters are [arg1, arg0, param1, param2] 原因：在 dao 的方法中，直接写了两个方法的参数， Mybatis 没有办法将其绑定12@Insert(&#123;"insert into ", TABLE_NAME, "(", INSERT_FILED, ") values(#&#123;name&#125;, #&#123;note&#125;)"&#125;)int insertUser(String name, String note); 解决方法：在参数前加入 @Param(“”) 进行绑定12@Insert(&#123;"insert into ", TABLE_NAME, "(", INSERT_FILED, ") values(#&#123;name&#125;, #&#123;note&#125;)"&#125;)int insertUser(@Param("name") String name, @Param("note") String note);]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现简单聊天程序（集合，线程，I/O，网络编程）]]></title>
    <url>%2F2018%2F11%2F11%2FJava%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8CI-O%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这半个月的大作业，程序有一些不完善的地方有待提高，但是基本的聊天室功能已经可以实现 还没有接触javaFx所以用了swing做了简陋的界面 补充：{ 今天突然记起来，把这个大作业交了，然后大佬突然问我这个程序有没有线程安全问题，怎么处理的。我以为这只是把socket传入的字节重新传到客户端不存在修改也不存在线程的安全问题，大佬说只要有多个线程共享的数据，就有可能有线程安全问题！！！切记我恰好在服务器端用了vector集合存储了线程，所以避免了安全性问题，但是如果用了其他的容器还是会出现线程安全问题。例如，ArrayList里，容量是有一个上限的，在当前容量已满的情况下，会进行扩容，先判断是否达到容量上限，如果没有，就将进行扩容，如果达到则会报异常。如果没有给线程上锁，当有两个对象同时加入ArrayList里且容量只够再一次扩容时，会爆内存。而使用vector则没有这种担忧，看过vector源码的API就会知道，vector的实现方法都用synchronized包装了。synchronized：这是java语言的关键字，被它修饰的方法或代码块在执行的时候能够保证在同一时刻最多只有一个线程执行该段代码，相当于一个上锁的操作。 } 客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import java.awt.BorderLayout;import java.awt.Color;import java.awt.Container;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTextArea;import javax.swing.JTextField; public class Client extends JFrame &#123; private static final long serialVersionUID = 1L; JTextField JTF = new JTextField(); JTextArea JTA = new JTextArea(); JScrollPane JSP = new JScrollPane(JTA); Socket socket = null; OutputStream ops = null; InputStream ips = null; String name = new String(); public void makeWindow()&#123; name = JOptionPane.showInputDialog(null, "请输入用户名字", "输入用户名", JOptionPane.INFORMATION_MESSAGE); connect(); JFrame frame = new JFrame("聊天窗口"); frame.setSize(500, 400); Container contentPane = frame.getContentPane(); JPanel panel = new JPanel(); panel.setBackground(Color.CYAN); JButton bts = new JButton("send"); JButton btc = new JButton("close"); panel.add(bts); panel.add(btc); JTA.setEditable(false); JPanel panel_ = new JPanel(new BorderLayout()); panel_.add(JTF, BorderLayout.SOUTH);// panel_.add(JTA, BorderLayout.CENTER); panel_.add(JSP, BorderLayout.CENTER); contentPane.add(panel, BorderLayout.SOUTH); contentPane.add(panel_, BorderLayout.CENTER); frame.setVisible(true); frame.setLocationRelativeTo(null); frame.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; CloseAll(); System.out.println("已关闭窗口"); System.exit(0); &#125; &#125;); btc.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; CloseAll(); System.out.println("press the btc"); System.exit(0); &#125; &#125;); bts.addActionListener(new ButtonListener()); new Thread(new ClientTest()).start(); &#125; public class ButtonListener implements ActionListener&#123; public void actionPerformed(ActionEvent arg0) &#123; String str = new String(); str = JTF.getText(); Date date = new Date(); DateFormat format = new SimpleDateFormat("HH:mm:ss"); String time = format.format(date); str = name + " send at " + time + ":\n" + str; JTF.setText(""); try &#123; ops.write(str.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); CloseAll(); &#125; &#125; &#125; public static void main(String[] args) &#123; Client c = new Client(); c.makeWindow(); &#125; public void connect()&#123; try &#123; socket = new Socket(InetAddress.getByName("127.0.0.1"), 9090); ops = socket.getOutputStream(); System.out.println("Open the Socket"); &#125; catch (UnknownHostException e) &#123; CloseAll(); e.printStackTrace(); &#125; catch (IOException e) &#123; CloseAll(); e.printStackTrace(); &#125; &#125; public void CloseAll()&#123; if(ips != null)&#123; try &#123; ips.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(ops != null)&#123; try &#123; ops.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("Close All"); &#125; class ClientTest implements Runnable&#123; @Override public void run()&#123; try &#123; ips = socket.getInputStream(); byte[] b = new byte[1024]; int len; while((len = ips.read(b)) != -1)&#123; String receStr = new String(b, 0, len); String appear = new String(); appear = JTA.getText()+ receStr + '\n'; JTA.setText(appear); JTF.setText(""); &#125; &#125; catch (IOException e) &#123; System.out.println("I hava closed! Please don't send message!"); &#125; &#125; &#125; &#125; 服务端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.Vector; public class Server &#123; public Vector&lt;ServerTest&gt; v = new Vector&lt;ServerTest&gt;(); ServerSocket ss = null;// Socket s = null;// InputStream ips = null;// OutputStream ops = null; public void receive()&#123; try &#123; ss = new ServerSocket(9090); System.out.println("I am the Server"); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; try &#123; while(true)&#123; Socket s = ss.accept(); ServerTest st = new ServerTest(s);System.out.println("a client connected!"); v.add(st); new Thread(st).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(ss != null)&#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("I have close all!"); &#125; &#125; public static void main(String[] args) &#123; Server server = new Server(); server.receive(); &#125; class ServerTest implements Runnable&#123; Socket s = null; InputStream ips = null; OutputStream ops = null; public ServerTest(Socket s)&#123; this.s = s; &#125; public void run() &#123; try &#123; while(true) &#123; this.ips = this.s.getInputStream(); this.ops = this.s.getOutputStream(); byte[] b = new byte[1024]; int len; while((len = this.ips.read(b)) != -1)&#123; String str = new String(b, 0, len); for(int i = 0; i &lt; v.size(); i++)&#123; ServerTest st = v.get(i); st.ops.write(str.getBytes()); &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(ips != null)&#123; try &#123; ips.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(ops != null)&#123; try &#123; ops.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(s != null)&#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现简单数独游戏]]></title>
    <url>%2F2018%2F11%2F11%2FJava%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[本来打算晚上把javaFx需要的组件装好以后直接用javaFx的，但似乎eclipse的版本不对，安装了也不能用，非洲人非了一天… 数独代码是在大一寒假受命写的，学了一个月java的成果，现在看来有些不足但毕竟是第一个程序，就直接放上来，数独终盘的实现直接用了暴力，时间复杂度有点高，懒得改了直接放代码 终盘实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import java.util.Random; public class SudokuPuzzleGenerator &#123; private Random random = new Random(); private static final int MAX_CALL_RANDOM_ARRAY_TIMES = 220; private int currentTimes = 0; public int[][] generatePuzzleMatrix() &#123; int[][] randomMatrix = new int[9][9]; for (int row = 0; row &lt; 9; row++) &#123; if (row == 0) &#123; currentTimes = 0; randomMatrix[row] = buildRandomArray(); &#125; else &#123; int[] tempRandomArray = buildRandomArray(); for (int col = 0; col &lt; 9; col++) &#123; if (currentTimes &lt; MAX_CALL_RANDOM_ARRAY_TIMES) &#123; if (!isCandidateNmbFound(randomMatrix, tempRandomArray, row, col)) &#123; resetValuesInRowToZero(randomMatrix,row); row -= 1; col = 8; tempRandomArray = buildRandomArray(); &#125; &#125; else &#123; row = -1; col = 8; resetValuesToZeros(randomMatrix); currentTimes = 0; &#125; &#125; &#125; &#125; return randomMatrix; &#125; private void resetValuesInRowToZero(int[][] matrix, int row) &#123; for (int j = 0; j &lt; 9; j++) &#123; matrix[row][j] = 0; &#125; &#125; private void resetValuesToZeros(int[][] matrix) &#123; for (int row = 0; row &lt; 9; row++) &#123; for (int col = 0; col &lt; 9; col++) &#123; matrix[row][col] = 0; &#125; &#125; &#125; private boolean isCandidateNmbFound(int[][] randomMatrix, int[] randomArray, int row, int col) &#123; for (int i = 0; i &lt; 9; i++) &#123; randomMatrix[row][col] = randomArray[i]; if (noConflict(randomMatrix, row, col)) &#123; return true; &#125; &#125; return false; &#125; private boolean noConflict(int[][] candidateMatrix, int row, int col) &#123; return noConflictInRow(candidateMatrix, row, col)&amp;&amp;noConflictInColumn(candidateMatrix, row, col) &amp;&amp; noConflictInBlock(candidateMatrix, row, col); &#125; private boolean noConflictInRow(int[][] candidateMatrix, int row, int col) &#123; int currentValue = candidateMatrix[row][col]; for (int colNum = 0; colNum &lt; col; colNum++) &#123; if (currentValue == candidateMatrix[row][colNum]) &#123; return false; &#125; &#125; return true; &#125; private boolean noConflictInColumn(int[][] candidateMatrix, int row, int col) &#123; int currentValue = candidateMatrix[row][col]; for (int rowNum = 0; rowNum &lt; row; rowNum++) &#123; if (currentValue == candidateMatrix[rowNum][col]) &#123; return false; &#125; &#125; return true; &#125; private boolean noConflictInBlock(int[][] candidateMatrix, int row, int col) &#123; int baseRow = row / 3 * 3; int baseCol = col / 3 * 3; for (int rowNum = 0; rowNum &lt; 8; rowNum++) &#123; if (candidateMatrix[baseRow + rowNum / 3][baseCol + rowNum % 3] == 0) &#123; continue; &#125; for (int colNum = rowNum + 1; colNum &lt; 9; colNum++) &#123; if (candidateMatrix[baseRow + rowNum / 3][baseCol + rowNum % 3] == candidateMatrix[baseRow + colNum / 3][baseCol + colNum % 3]) &#123; return false; &#125; &#125; &#125; return true; &#125; private int[] buildRandomArray() &#123; currentTimes++; int[] array = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int randomInt = 0; for (int i = 0; i &lt; 20; i++) &#123; randomInt = random.nextInt(8) + 1; int temp = array[0]; array[0] = array[randomInt]; array[randomInt] = temp; &#125; return array; &#125; public int getCurrentTimes() &#123; return currentTimes; &#125; public void setCurrentTimes(int currentTimes) &#123; this.currentTimes = currentTimes; &#125; &#125; 界面及判断: 用swing写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import javax.swing.*; import java.awt.*;import java.awt.event.*;import java.util.Random; public class ShuD extends JFrame&#123; private static final long serialVersionUID = 5952689219411916553L; //序列化字段 private static JTextField a[][] = new JTextField[9][9]; //存储文本框中的数字 static int ans[][] = new int[9][9]; //存储输入后的两位数组 SudokuPuzzleGenerator example = new SudokuPuzzleGenerator(); public int right[][] = example.generatePuzzleMatrix(); public int rightans[][]; private int[][] Wk(int a[][])&#123; //挖空 Random r = new Random(); int a1, a2; a1 = r.nextInt(9); a2 = r.nextInt(9); for(int i = 0; i &lt; 100; i++) &#123; a[a1][a2] = 0; a1 = r.nextInt(9); a2 = r.nextInt(9); &#125; return a; &#125; public ShuD()&#123; Container c = getContentPane(); c.setLayout(new BorderLayout(2, 1)); //边框布局 JMenuItem jmiOk = new JMenuItem("提交"); //定义菜单 JMenuItem jmiExplain = new JMenuItem("详情"); JMenuItem jmiMessage = new JMenuItem("信息"); JPanel panel = new JPanel(); //定义一个容器 panel.add(jmiOk); //将菜单在容器内显示 panel.add(jmiExplain); panel.add(jmiMessage); JPanel p1 = new JPanel(new GridLayout(9, 9, 5, 5)); //定义9行9列的网格布局 add(panel,BorderLayout.NORTH); //将菜单放置在北面 add(p1,BorderLayout.CENTER); //将数字放置在正中间 rightans = Wk(right); for(int k = 0;k&lt;9; k ++) &#123; for(int n=0;n&lt;9;n++) &#123; if(rightans[k][n] != 0) &#123; a[k][n] = new JTextField("" + rightans[k][n]); a[k][n].setHorizontalAlignment(JTextField.CENTER);//将数字水平居中 a[k][n].setEditable(false); //只可显示不可修改 p1.add(a[k][n]); //添加文本框 &#125; else &#123; a[k][n] = new JTextField(); a[k][n].setHorizontalAlignment(JTextField.CENTER); p1.add(a[k][n]); &#125; &#125; &#125; add(p1); //将数字面板显示在容器里 jmiOk.addActionListener(new ActionListener()&#123;//匿名创建事件监听器 public void actionPerformed(ActionEvent e) &#123; if(gettext() == 1) &#123; if(judge() == true) &#123; JOptionPane.showMessageDialog(null, "Your answer is right!","Result",JOptionPane.INFORMATION_MESSAGE); &#125; else &#123; JOptionPane.showMessageDialog(null, "Your answer is wrong!","Result",JOptionPane.INFORMATION_MESSAGE); &#125; &#125; &#125; &#125;); explainListenerClass listener2 = new explainListenerClass(); jmiExplain.addActionListener(listener2); messageListenerClass listener3 = new messageListenerClass(); jmiMessage.addActionListener(listener3); &#125; static int gettext() //获取文本框的文字 &#123; int i,j; for(i = 0; i &lt; 9; i++) &#123; for(j = 0; j &lt; 9 ; j ++) &#123; ans[i][j] = 0; &#125; &#125; for(int k = 0;k &lt; 9; k++) &#123; for(int n = 0;n &lt; 9; n++) &#123; try //异常处理 &#123; ans[k][n] = Integer.parseInt(a[k][n].getText()); //将答案类型转换之后传给ans &#125; catch(NumberFormatException nfe) &#123; JOptionPane.showMessageDialog(null,"数据中包括非数字，请重新输入"); return 0; &#125; &#125; &#125; return 1; &#125; public static boolean judge() //判断输入的答案是否正确 &#123; int i,j,k; int [][]answer = ans; for(i = 0; i &lt; 9; i ++) &#123; if(judge9(answer[i]) == false) //判断每列是否有重复数字 return false; &#125; for(j = 0; j &lt; 9; j ++) //判断每行是否有重复数字 &#123; int[] newAnswerColumn = new int[9]; for(i = 0; i &lt; 9; i ++) &#123; newAnswerColumn[i] = answer[i][j]; &#125; if(judge9(newAnswerColumn) == false) return false; &#125; for(i = 0; i &lt; 3; i ++) //判断每个小九宫格内是否有重复数字 &#123; for(j = 0; j &lt; 3; j ++) &#123; k = 0; int[] newAnswer = new int[9]; for(int m = i * 3; m &lt; i * 3 + 3; m ++) &#123; for(int n = j * 3; n &lt; j * 3 + 3; n ++) &#123; newAnswer[k] = answer[m][n]; k++; &#125; &#125; if(judge9(newAnswer) == false) &#123; return false; &#125; &#125; &#125; return true; &#125; public static boolean judge9(int[] answer) &#123; int i,j; for(i = 0; i &lt; 9; i ++) &#123; for(j = 0; j &lt; 9; j ++) &#123; if(i == j) continue; if(answer[i] == answer[j]) //如果有重复的数字，返回false &#123; return false; &#125; &#125; &#125; return true; //没有重复数字，返回true &#125; public static void main(String[] args) &#123; JFrame frame = new ShuD(); frame.setTitle("SuDoku"); frame.setSize(600,900); frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); &#125;&#125;class explainListenerClass implements ActionListener&#123; //事件监听器 public void actionPerformed(ActionEvent e)&#123; JOptionPane.showMessageDialog(null, "填入数字保证每行每列及每个小的九宫格内数字无重复","Explain",JOptionPane.INFORMATION_MESSAGE); &#125;&#125;class messageListenerClass implements ActionListener&#123; public void actionPerformed(ActionEvent e)&#123; JOptionPane.showMessageDialog(null, "made by wyx","Message",JOptionPane.INFORMATION_MESSAGE); &#125;&#125;]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB mongo.exe启动及闪退解决]]></title>
    <url>%2F2018%2F11%2F11%2FMongoDB-mongo-exe%E5%90%AF%E5%8A%A8%E5%8F%8A%E9%97%AA%E9%80%80%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[启动：进入MongoDB安装目录下的bin目录，启动mongod.exe 出现如上图所示的提示行，打开：http://localhost:27017 若出现： 1It looks like you are trying to access MongoDB over HTTP on the native driver port. 则连接成功。 此时再打开刚刚的窗口，会新加几行，如下图 此时，不要关闭该窗口，新打开一个cmd，进入自己的MongoDB目录下的bin目录， 输入mongo，按下回车 若出现图示情况，则代表启动成功 闪退：在MongoDB所在盘下的根目录创建一个data文件夹，并在data文件夹里创建一个db文件夹 （例如，我的MongoDB在C盘的一个文件里，就在C盘根目录下创建data） 然后打开cmd，进入到MongoDB的bin目录下，输入mongod –dbpath c:/data 会出现图一所示情况，即修复成功，按上述步骤继续运行即可。 关闭：可以直接关闭mongod.exe窗口，也可以在该窗口下按 Ctrl+C 来关闭]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>闪退</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node下载的模块无法使用（Cannot find module）解决方法]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%85%B3%E4%BA%8Enode%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%A8%A1%E5%9D%97%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%EF%BC%88Cannot-find-module%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这个问题困扰了我很久，也按百度上各式各样的方法试了没有用 今天和导师远程，知道了问题在哪，我用webstorm编译器进行演示 若使用其他编译器，可按下述原理进行修改 原理(在当前工程文件夹下要有一个package.json文件，并在此工程下安装npm模块，安装后会出现一个node_modules文件夹，里面包含着下载的模块) 过程： 测试代码： 此时运行，结果如下图， 显示：Cannot find module 在Terminal面板对colors模块进行安装会出现如下错误： 此时，继续在该面板，输入 npm init 按下回车进行初始化，效果如图： 此时一直点击回车，直到出现” Is this ok? (yes) ” 输入yes 回车 此时，继续安装colors模块，提示安装成功： 重新运行程序，此时成功输出：]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断素数的算法]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0%E7%9A%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.根据定义求，时间复杂度为：O(n) 判断除了1和它本身外是否还有其他因数 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 1e6 + 5;int n;/** 根据定义求*/string is_Prime(int x)&#123; if(x == 1) return "no"; bool flag = true; for(int i = 2; i &lt; x; i++) &#123; if(x % i == 0) &#123; flag = false; break; &#125; &#125; return flag ? "yes" : "no";&#125;int main()&#123; while(scanf("%d", &amp;n) != EOF) &#123; printf("Is %d is a prime?\t", n); cout&lt;&lt;is_Prime(n)&lt;&lt;endl; &#125; return 0;&#125; 2.若该数为偶数，则必定不是素数至少可以被2整除且2为素数，时间复杂度O(n / 2) 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 1e6 + 5;int n;/** 去掉偶数*/string is_Prime(int x)&#123; if(x == 1) return "no"; for(int i = 3; i &lt; x; i += 2) &#123; if(x % i == 0) &#123; return "no"; &#125; &#125; return "yes";&#125;int main()&#123; while(scanf("%d", &amp;n) != EOF) &#123; printf("Is %d is a prime?\t", n); cout&lt;&lt;is_Prime(n)&lt;&lt;endl; &#125; return 0;&#125; 3.若要求n是否为素数，可以求在2-sqrt(n)中是否存在n的约数，若是不存在，在sqrt(n)-n - 1中也必定没有它的约数，时间复杂度O(sqrt(n)/2) 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 1e6 + 5;int n;/** sqrt(n)*/string is_Prime(int x)&#123; if(x == 1) return "no"; int m = sqrt(x); for(int i = 2; i &lt;= m; i++) &#123; if(x % i == 0) &#123; return "no"; &#125; &#125; return "yes";&#125;int main()&#123; while(scanf("%d", &amp;n) != EOF) &#123; printf("Is %d is a prime?\t", n); cout&lt;&lt;is_Prime(n)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>素数</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用命令行工具sqlite3打开数据库出现乱码的解决方案]]></title>
    <url>%2F2018%2F11%2F10%2F%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7sqlite3%E6%89%93%E5%BC%80%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[数据库中存储的数据本是中文，用 sqlite3 打开之后变成乱码 方法： （1）查看 dos 的编码方式，一般为 GBK（简体中文） Android 一般的编码方式都是 UTF-8，所以要将 dos 的编码方式也改为 UTF-8 （2）借用 chcp 命令改变编码方式 chcp 65001 （将编码方式改为UTF-8） chcp 936 （将编码方式改回GBK） （3）改为 UTF-8 后重新在命令行用 sqlite3 打开数据库，格式正确]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>sqlite3</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows关机命令与tomcat的shutdown命令冲突解决方法]]></title>
    <url>%2F2018%2F11%2F10%2Fwindows%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4%E4%B8%8Etomcat%E7%9A%84shutdown%E5%91%BD%E4%BB%A4%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[配置tomcat使其能在任意目录下启动之后，输入startup回车，如图 再输入shutdown会出现如下图问题 shutdown 默认为 Windows 的关机命令，若想执行tomcat的shutdown命令，只需执行全称shutdown.bat 成功关闭]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>shutdown 冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vmware Workstation 虚拟机出现 The VMware Authorization Service is not running 问题的解决方案]]></title>
    <url>%2F2018%2F11%2F10%2FVmware-Workstation-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%87%BA%E7%8E%B0-The-VMware-Authorization-Service-is-not-running-%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[点击开启虚拟机后，出现了如图所示的错误提示 解决方案： 打开任务管理器，点击服务 在名称里找到 VMAuthdService 右键点击选择启动 再次开启虚拟机即可成功]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>VM 虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云Ubuntu64位云服务器搭建JavaEE环境（JDK+Tomcat+Mysql）]]></title>
    <url>%2F2018%2F11%2F10%2F%E9%98%BF%E9%87%8C%E4%BA%91Ubuntu64%E4%BD%8D%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAJavaEE%E7%8E%AF%E5%A2%83%EF%BC%88JDK-Tomcat-Mysql%EF%BC%89%2F</url>
    <content type="text"><![CDATA[要想在服务器上部署自己的项目，首先要在服务器上安装JDK， Mysql， Tomcat，下面将先讲解如何安装这三项。由于我的电脑是win10系统，所以需要下载额外的辅助软件来实现与服务器的文件交互等。 准备工作：下载PuTTy，FileZilla，jdk（请无视截图的版本，不要下载10.0版本！！！来自踩坑选手的忠告），Tomcat，mysql 打开FileZilla，将云服务器的公有IP（若是腾讯云服务器，只需要将唯一IP填入即可）填入主机栏，其他信息填好之后点击快速连接 在左侧的本地站点中找到刚刚下载的jdk及Tomcat压缩包，选中后右键点击上传 上传成功后，打开PuTTy以连接到服务器，将云服务器的公有IP填入HostName栏，Port填写22（出于安全考虑，Linux默认只开放22端口，若需要连接其他端口，可以在控制台中进行设置） 点击open后跳转到如下图所示界面，输入用户名及密码后登录成功（Linux系统不会显示密码，输好密码后直接回车即可） 查看当前目录下的文件，即我们刚刚用FileFilla上传成功的压缩包 在root目录下新建一个javaee文件夹输入命令： 1tar zxvf jdk-10.0.2_linux-x64_bin.tar.gz -C javaee 从而将jdk压缩包解压至javaee目录下 注：想要给文件重命名一定要在进行配置之前改！！！ 本弱鸡在配置之后对文件进行了重命名，并且忘了改配置文件，卡了一个小时，生无可恋心态已崩 输入命令： 1vi /etc/profile 进入配置文件开始配置java环境变量 进入下图界面后，按下键盘上的’i’进行编辑，并在文件的最后追加如下配置，输入完成后按下Esc键，再输入“:wq!”保存文件并退出（具体参照Linux中VI编辑器的使用） 1234export JAVA_HOME=/root/javaee/jdk-10.0.2export JRE_HOME=/root/javaee/jdk-10.0.2/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH 输入两条命令，若出现下图所示提示则配置成功 12source /etc/profilejava -version 接下来进行Tomcat的安装配置将其解压至javaee文件夹下 进入Tomcat文件夹下，用 VI 编辑器打开 catalina.sh 1vi catalina.sh 在该文件的开头添加如下配置 12export JAVA_HOME=/root/javaee/jdk-10.0.2export JRE_HOME=/root/javaee/jdk-10.0.2/jre 退出后在Tomcat的bin目录下如下输入命令，显示Tomcat已成功启动 1./startup.sh 此时，从浏览器可以成功访问Tomcat页面（访问之前请确认是否打开防火墙或已按照文章最后附一的内容将8080端口添加进安全组） 接下来开始安装mysql由于mysql版本及原Linux系统存在残留mysql的问题，搞了一下午心态已崩，重新装了镜像，用了大佬们常用的更简便的方法在终端窗口中输入以下三条命令 123sudo apt-get install mysql-serversudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev 安装完成后，测试是否安装成功，输入登录指令及密码，密码即安装 mysql-server 时设置的密码，若出现下图所示情况，则安装成功，此时，可以查看与操作数据库中的数据表 至此，jdk， tomcat， mysql 全部安装成功 附一：开放其他可用端口：云服务器管理控制台-&gt;管理-&gt;本实例安全组-&gt;配置规则-&gt;添加安全组规则之后添加所需要访问的端口即可 下面是一些常用端口]]></content>
      <categories>
        <category>常用配置</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>云服务器</tag>
        <tag>JavaEE环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10环境配置Tomcat（9.0版本）]]></title>
    <url>%2F2018%2F11%2F10%2FWin10%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AETomcat%EF%BC%889-0%E7%89%88%E6%9C%AC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[由于博主今天中午脑子一抽重装了系统，电脑上所有的东西都被我干掉了，一朝回到解放前，被各种配置折磨了一下午，所以记录一下重装系统之后艰难的配置路线，以防以后再次冲动 首先去官网下载tomcat的压缩包并解压 然后去电脑的属性配置环境变量 这里需要配置两处：CATALINA_HOME 与 Path CATALINA_HOME的变量值是tomcat的根目录，如下图 其后，点击编辑Path新增一条：%CATALINA_HOME%\bin，随后一路确定 随后打开cmd，输入startup 此时会弹出另一个窗口 当出现如下图红框中日志时，打开浏览器，输入：http://localhost:8080/ 出现如下页面，则tomcat配置成功]]></content>
      <categories>
        <category>常用配置</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vi编辑器的方向键无法使用的解决方法]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%85%B3%E4%BA%8Evi%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%96%B9%E5%90%91%E9%94%AE%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对于刚开始用Linux编程的小白来说，vi是最基础的编辑器，可以用vi写出一些简单程序 而在vi中按下方向键或退格键会出现奇奇怪怪的字母 这种情况是由于vi不支持方向键和退格键，这些功能是由vim支持的，所以只需要重新下载vim即可 打开终端，依次输入以下命令: sudo apt-get remove vim-common sudo apt-get install vim 再次打开vi编辑器之后就可以正常使用方向键及退格键]]></content>
      <categories>
        <category>Linux 学习之路</category>
      </categories>
      <tags>
        <tag>vi</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot + WebSocket 学习笔记]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[WebSocket 协议是基于 TCP 的一种新的网络协议。它实现了浏览器与服务器全双工通信–允许服务器主动发送信息给客户端，实现客户端之间的交互。WebSocket 是从 Html5 中演化而出，但是相对于 HTTP的 不支持持久性连接，WebSocket 是一个持久化的协议。 实现 WebSocket 协议后，服务端只要与客户端进行过一次连接之后，就不需要再次连接，并且可以一直向客户端发送信息，即服务端主动向客户端发送消息。由于 WebSocket 协议在握手阶段采用了 HTTP 协议，能通过各种 HTTP 代理服务器。目前并不是所有的浏览器都实现了 WebSocket，对于没有实现该协议的浏览器，还需要通过 STOMP 协议来完成兼容。要想在 Spring Boot 项目中应用 WebSocket，首先要在 pom.xml 中加入依赖 12345678910111213 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; &lt;!-- Spring security 主要为了点对点时的安全登录，可以不使用 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 下面开发一个简单的 WebSocket 服务· 创建 java 配置文件 1234567891011121314import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter; @Configurationpublic class WebSocketConfig &#123; //创建服务器端点 @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125; &#125; · 定义 WebSocket 服务端站点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106 import org.springframework.stereotype.Service; import javax.websocket.*;import javax.websocket.server.ServerEndpoint;import java.io.IOException;import java.util.concurrent.CopyOnWriteArrayList; //创建 WebSocket 服务站点， 参数: 请求地址@ServerEndpoint("/ws")@Servicepublic class WebSocketServiceImpl &#123; //用来记录当前在线连接数，应该设置为线程安全 private static int onlineCount = 0; //保证线程安全的 WebSocketServiceImpl 对象的 Set private static CopyOnWriteArrayList&lt;WebSocketServiceImpl&gt; webSocketServices = new CopyOnWriteArrayList&lt;&gt;(); //与客户端的连接会话 private Session session; public Session getSession() &#123; return session; &#125; /** * 连接建立成功调用的方法 * @param session */ @OnOpen public void onOpen(Session session)&#123; this.session = session; webSocketServices.add(this); addOnlineCount(); System.out.println("有新连接加入， 当前在线人数: " + getOnlineCount()); try &#123; sendMessage("有新连接加入了"); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; /** * 连接关闭调用的方法 */ @OnClose public void onClose()&#123; webSocketServices.remove(this); subOnlineCount(); System.out.println("有一个连接关闭， 当前在线人数: " + getOnlineCount()); &#125; /** * 收到客户端消息后调用的方法 * @param message 客户端发送来的消息 * @param session */ @OnMessage public void onMessage(String message, Session session)&#123; System.out.println("收到客户端消息: " + message); //群发消息 for(WebSocketServiceImpl service : webSocketServices)&#123; try &#123; //获取当前用户名称 String userName = service.getSession().getUserPrincipal().getName(); System.out.println(userName); service.sendMessage(message); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** *发生错误时调用 */ @OnError public void onError(Session session, Throwable error)&#123; System.out.println("发生错误"); error.printStackTrace(); &#125; /** * 发送消息 * @param message 客户端消息 * @throws IOException */ private void sendMessage(String message) throws IOException&#123; this.session.getBasicRemote().sendText(message); &#125; //返回在线数 private static synchronized int getOnlineCount()&#123; return onlineCount; &#125; //增加连接人数 private static synchronized void addOnlineCount()&#123; WebSocketServiceImpl.onlineCount++; &#125; //减少连接人数 private static synchronized void subOnlineCount()&#123; WebSocketServiceImpl.onlineCount--; &#125; &#125; · WebSocket 页面（websocket.jsp） 12345678910111213141516171819202122&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;My WebSocket&lt;/title&gt; &lt;script type="text/javascript" src="/jquery-1.8.3.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/websocket.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 测试 WebSocket 站点 &lt;br&gt; &lt;input id = "message" type="text"&gt; &lt;button onclick="sendMessage()"&gt;发送消息&lt;/button&gt; &lt;button onclick="closeWebSocket()"&gt;关闭 WebSocket 连接&lt;/button&gt; &lt;div id="context"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; · WebSocket 客户端脚本(websocket.js) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var websocket = null;//判断当前浏览器是否支持 WebSocketif('WebSocket' in window)&#123; //创建 WebSocket 对象，连接服务器端点 websocket = new WebSocket("ws://localhost:8080/ws");&#125;else&#123; alert('Not support webSocket')&#125; //连接发生错误的回调方法websocket.onerror = function () &#123; appendMessage("error");&#125;; //连接成功建立的回调方法websocket.onopen = function (event) &#123; appendMessage("open");&#125;; //接收到消息的回调方法websocket.onmessage = function (event) &#123; appendMessage(event.data);&#125;; //连接关闭的回调方法websocket.onclose = function () &#123; appendMessage("close");&#125;; //监听窗口关闭事件，当窗口关闭时，主动关闭 websocket 连接//防止连接还没断开就关闭窗口， server 端会抛异常window.onbeforeunload = function () &#123; websocket.close();&#125;; //将消息显示在网页上function appendMessage(message) &#123; var context = $("#context").html() + "&lt;br/&gt;" + message; $("#context").html(context);&#125;; //关闭连接function closeWebSocket() &#123; websocket.close();&#125; //发送消息function sendMessage() &#123; var message = $("#message").val(); websocket.send(message);&#125; · WebSocket 控制器 123456789101112131415 import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; @RequestMapping(value = "/websocket")@RestControllerpublic class WebSocketController &#123; @GetMapping(value = "/index") public String websocket()&#123; return "websocket"; &#125; &#125; 启动控制器，跳转去客户端，打开两个页面发送消息]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 的 jsp文件中无法引入静态资源文件（js,css等文件）]]></title>
    <url>%2F2018%2F11%2F10%2Fjsp%E6%96%87%E4%BB%B6%E4%B8%AD%E6%97%A0%E6%B3%95%E5%BC%95%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%88js-css%E7%AD%89%E6%96%87%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[错误（net::ERR_ABORTED 404）报错信息： 报错时我的jsp文件中引入路径： 12&lt;script type="text/javascript" src="../../sources/static/jquery-1.8.3.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../../sources/static/websocket.js"&gt;&lt;/script&gt; 正确路径：删除掉static及其之前的全部路径 12&lt;script type="text/javascript" src="/jquery-1.8.3.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/websocket.js"&gt;&lt;/script&gt; 原因：在未对 application.properties 文件进行配置时，Spring Boot 默认从resources目录的static目录查找资源文件，所以 src 目录中无需加入 static 及其之前的路径 若想对资源路径进行配置，可以在 application.properties 配置文件中加入下面的配置 1spring.mvc.static-path-pattern=/**]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 创建 Maven + Spring Boot 项目并打包（jar 包）上传至 Linux 服务器上运行]]></title>
    <url>%2F2018%2F11%2F08%2FIDEA-%E5%88%9B%E5%BB%BA-Maven-Spring-Boot-%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%89%93%E5%8C%85%EF%BC%88jar-%E5%8C%85%EF%BC%89%E4%B8%8A%E4%BC%A0%E8%87%B3-Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[首先打开 IDEA 并点击 New Project，进入如下页面 点击 Maven，选中”Create from archetype” 选择 quickstart 然后 next GroupId 为 package 名，ArtifactId 为项目名称，点击 next 不用改动，直接 next（有教程说要添加一个什么东西来防止下载速度过慢，笔者用了另一种办法，后面描述，所以这里不需要改动） 这个页面也不用改动，直接 finish 进入项目后，先去修改 pom.xml 文件，首先添加图中圈出的三处（version 请视自己具体所用版本而定） 接着在 dependencies 标签内添加以下配置 12345678910111213141516171819202122232425262728293031323334&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 然后将 build 标签改为下图所示 此时右下角可能会出现下图所示的小窗口，并且一直停滞，这就是上面所提到的问题，此时，下载 archetype-catalog.xml 文件，并将其放在 C 盘 .m2 文件的根目录下 关闭项目后再次打开发现下载速度明显提升并且很快结束下载 然后在 main 目录下创建文件夹 resources 并且设置为 Resources Root 在 Resources 目录下创建 application.properties 文件并填写有关数据库的配置（这里配置端口是因为笔者的服务器中8080端口已被占用，所以使用了另外的端口） 123456spring.datasource.url=jdbc:mysql://localhost:3306/basketball?serverTimezone=GMT&amp;allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=root`# 设置 tomcat 端口为 8880server.port=8880 此时，正式开始代码部分 在 com.hello 包下创建 controller 包， 并在其下创建 HelloController 类 在其中编写代码 1234567891011121314package com.hello.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;@RestControllerpublic class HelloController &#123; @GetMapping(value = "/hello") public Map&lt;String, Object&gt; hello()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("hello", "Hello world!"); return map; &#125;&#125; 打开 App.java 为 App 添加注解 @SpringBootApplication，并在 Main 函数中运行 SpringApplication.run(App.class, args); 1234567891011package com.hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class App&#123; public static void main( String[] args ) &#123; SpringApplication.run(App.class, args); &#125;&#125; 此时，代码部分已经结束，开始进行下一步，按图中箭头所示进行操作 Name 可以自己取，Main class 选取添加了 @SpringBootApplication 注解的 App 类，直接 ok 运行后用 Postman（Get 方法也可以在浏览器地址栏直接访问） 访问 url，成功返回 接下来，将项目打包为 jar 包并上传至服务器 在 View 中的 Tool Windows 找到Maven Projects 并打开 先双击 clean （如果是第一次则不需要） 然后双击 install 此时，打包成功 在 target 目录下可以看到生成的 .jar 文件 然后利用 FileZilla 将 jar 包上传至服务器文件 利用 PuTTY 登录云服务器，进入到所上传 jar 包的目录下 运行 jar 包有两种方式 1234# 直接运行，当该窗口关闭时程序终止java -jar xxxx.jar# 持久运行，即便窗口关闭程序也不会终止nohup java -jar xxxx.jar &amp; 这里运用第二种方法 此时 hello.jar 已在运行，并且将日志存放在 nohup.out 文件中 12# 查看日志， Ctrl + C 退出查看tail -100f nohup.out 此时再次通过 Postman 访问路径，可以成功得到返回结果 若想关闭 jar 包的运行，首先要查看当前 jar 包的进程号，然后利用 kill 命令杀死进程 1234# 查看 xxxx.jar 运行的进程号ps -ef|grep xxxx.jar# 关闭进程号为 xx 的进程 kill xx]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Maven</tag>
        <tag>Linux 云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 项目在本地可以成功访问但是在服务器上无法访问 Controller 方法解决办法]]></title>
    <url>%2F2018%2F11%2F08%2FSpring-Boot-%E9%A1%B9%E7%9B%AE%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E4%BB%A5%E6%88%90%E5%8A%9F%E8%AE%BF%E9%97%AE%E4%BD%86%E6%98%AF%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE-Controller-%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这是一篇记录自己失了智的博客 晚上写了一个小 Demo 来测试在云服务器上同时运行两个 jar 包的情况 两个项目的端口分别为 8080 和 8880 以 8880 为端口的 Demo 在本地成功运行并且访问到了 Controller 中的方法 在服务器运行后从日志中也可以确定成功完成了映射 但是就是没有办法通过服务器的 url 进行访问 百度了 N 久都没有找到和我相同的问题，直到被大佬指点之后才意识到，我的服务器的安全组中没有添加 8880 这个端口，换言之，请求被防火墙拦截了。去将 8880 添加到安全组后，再次访问，成功返回 “Hello world!”]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>无法访问 Controller</tag>
      </tags>
  </entry>
</search>

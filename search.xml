<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库事务处理要点记录]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1.SQL 事务流程图： 2.对于声明式事务，是使用 @Transactional 进行标注的。可以标注类或方法，当它标注在类上时，代表这个类的所有公共非静态的方法都将启动事务功能 3.需要在启动文件中定义事务管理器，一般不需要自己创建而直接使用 IOC 容器中的 Bean 进行装配 4.@PostConstruct：后初始化方法，类对象被初始化后调用 5.数据库事务的四个基本特征：ACID&emsp;&emsp;Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性） 6.并发操作数据时会出现两类丢失更新：第一类丢失更新和第二类丢失更新&emsp;&emsp;第一类丢失更新：一个事务回滚另外一个事务提交而引发的数据不一致的情况（目前大部分数据库已经克服了这类问题）|时刻|事务1|事务2| :-: | :-: | :-: ||T1|初始库存100|初始库存100||T2|扣减库存，余99| - ||T3| - |扣减库存，余99||T4| - |提交事务，库存变为99||T5|回滚事务，库存100| - |&emsp;&emsp;第二类丢失更新：多个事务都提交引发的丢失更新0 |时刻|事务1|事务2 | :-: | :-: | :-: | |T1|初始库存100|初始库存100| |T2|扣减库存，余99| - | |T3| - |扣减库存，余99| |T4| - |提交事务，库存变为99| |T5|提交事务，库存变为99| - | 7.隔离级别：&emsp;&emsp;未提交读、读写提交、可重复读、串行化&emsp;&emsp;① 未提交读：允许一个事务读取另一个事务没有提交的数据&emsp;&emsp;&emsp;&emsp;危险的隔离级别，并发能力高，但是会出现脏读难以保证数据一致性&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;脏读现象 |时刻|事务1|事务2|备注 | :-: | :-: | :-: | :-: | |T0| …… | …… |商品库存初始化为2| |T1| 读取库存为2 | - | - | |T2|扣减库存| - | 库存为1 | |T3| - | 扣减库存 |库存为0，读取事务1未提交的库存数据| |T4| - |提交事务|库存保存为0| |T5|回滚事务| - |因为第一类丢失更新已经克服，所以不会回滚为2，库存为0，结果错误|&emsp;&emsp;② 读写提交：一个事务只能读取另外一个事务已经提交的数据，不能读取未提交的数据&emsp;&emsp;&emsp;&emsp;克服脏读现象，但是无法解决不可重复读现象&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;克服脏读 |时刻|事务1|事务2|备注 | :-: | :-: | :-: | :-: | |T0| …… | …… |商品库存初始化为2| |T1| 读取库存为2 | - | - | |T2|扣减库存| - | 库存为1 | |T3| - | 扣减库存 |库存为1，读取不到事务1未提交的库存数据| |T4| - |提交事务|库存保存为1| |T5|回滚事务| - |因为第一类丢失更新已经克服，所以不会回滚为2，库存为1，结果正确|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;不可重复读现象 |时刻|事务1|事务2|备注 | :-: | :-: | :-: | :-: | |T0| …… | …… |商品库存初始化为1| |T1| 读取库存为1 | - | - | |T2| 扣减库存 | - |事务未提交| |T3| - | 读取库存为1 |认为可扣减| |T4| 提交事务 | - |库存变为0| |T5| - | 扣减库存 |失败，因为此时库存为0，无法扣减|&emsp;&emsp;③ 可重复读：克服不可重复读现象，无法解决幻读现象&emsp;&emsp;&emsp;&emsp;克服不可重复读 |时刻|事务1|事务2|备注 | :-: | :-: | :-: | :-: | |T0| …… | …… |商品库存初始化为1| |T1| 读取库存为1 | - | - | |T2| 扣减库存 | - |事务未提交| |T3| - | 尝试读取库存 |不允许读取，等待事务1提交| |T4| 提交事务 | - |库存变为0| |T5| - | 读取库存 |库存为0，无法扣减|&emsp;&emsp;&emsp;&emsp;幻读现象 |时刻|事务1|事务2|备注 | :-: | :-: | :-: | :-: | |T1| 读去库存50件 | - | 商品库存初始化为100，现在已经销售50笔，库存50件 | |T2| - | 查询交易记录，50笔 | - | |T3| 扣减库存 | - | - | |T4| 插入1笔交易记录 | - | - | |T5| 提交事务 | - |库存49件，交易记录51笔| |T6| - | 打印交易记录，51笔 |这里与查询的不一致，在事务2看来有1笔试虚幻的，与之前查询的不一致|&emsp;&emsp;&emsp;&emsp;ps：这里的笔数是一个统计值而不是数据库存储的值，商品库存是数据库存储的值&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;幻读针对多条记录而言&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;可重复读是针对数据库的单一条记录&emsp;&emsp;④ 串行化：数据库最高的隔离级别，要求所有的 SQL 都按照顺序执行，能够完全保证数据的一致性&emsp;&emsp;&emsp;&emsp;隔离级别和可能发生的现象 |项目类型|脏读|不可重复读|幻读 | :-: | :-: | :-: | :-: | |未提交读| √ | √ | √ | |读写提交| × | √ | √ | |可重复读| × | × | √ | |串行化| × | × | × |&emsp;&emsp;ps：追求更高的隔离级别，它能更好地保证了数据的一致性，但是也要付出锁的代价。有了锁，就意味着性能的丢失 Spring Boot 可以通过配置文件指定默认的隔离级别12345678910# 隔离级别数字配置的含义：# -1: 数据库默认隔离级别# 1: 未提交读# 2: 读写提交# 3: 可重复读# 4: 串行化# tomcat 数据源默认隔离级别spring.datasource.tomcat.default-transaction-isolation=2# dbcp2 数据库连接池默认隔离级别# spring.datasource.dbcp2.default-transaction-isolation=2 8.传播行为：在 Spring 事务机制中对数据库存在 7 中传播行为，它是通过枚举类 Propagation 定义的1234567891011121314151617181920212223242526272829303132333435363738394041/*** 需要事务，是默认传播行为* 如果当前存在事务，就沿用当前事务，否则新建一个事务运行子方法**/REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED)/*** 支持事务* 如果当前存在事务，就沿用当前事务，如果不存在，则继续采用无事务的方式运行子方法**/SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS)/*** 必须使用事务* 如果当前存在事务，就沿用当前事务，如果不存在，则会抛出异常**/MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY)/*** 无论当前事务是否存在，都会创建新事务运行方法* 新事务可以拥有新的锁和隔离级别等特性，与当前事务相互独立**/REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW)/*** 不支持事务* 当前存在事务时，将挂起事务，运行方法**/NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED)/*** 不支持事务* 如果当前方法存在异常，则抛出异常，否则继续使用无事务机制运行**/NEVER(TransactionDefinition.PROPAGATION_NEVER)/*** 在当前方法调用子方法时，如果子方法发生异常* 只回滚子方法执行过的 SQL，而不回滚当前方法的事务**/NESTED(TransactionDefinition.PROPAGATION_NESTED) 9.@Transactional 自调用失效问题：&emsp;&emsp;如果两个标注了@Transactional 但是，是一个类中的方法之间的调用，即自调用，会存在被调用方法 @Transactional 失效问题&emsp;&emsp;原因：&emsp;&emsp;&emsp;&emsp;Spring 数据库事务的约定，其实现原理是 AOP，AOP 的原理是动态代理，自调用时是类自身的调用，不是代理对象去调用，不会产生 AOP，所以导致 @Transactional 失效&emsp;&emsp;解决：&emsp;&emsp;&emsp;&emsp;① 使用一个 Service 去调用另一个 Service&emsp;&emsp;&emsp;&emsp;② 从 Spring IOC 容器中获取代理对象去启用 AOP]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>springBoot</tag>
        <tag>事务处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全注解下的 Spring IOC 要点记录]]></title>
    <url>%2F2018%2F11%2F19%2F%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84-Spring-Ioc%2F</url>
    <content type="text"><![CDATA[1.Spring 的两大特性：IOC（Inversion of control， 控制反转） 和 AOP（Aspect Oriented Programming， 面向切面编程） 2.IOC 是一种通过描述来生成或获取对象的技术 3.Spring Boot 主要通过注解的描述生成对象，而 Spring 主要通过 XML 和 Java 配置文件（在类名上加入 @Configuration 注解来使其变为配置类）来配置生成对象 4.在 Spring IOC 容器中， Bean 默认为单例存在且 Bean 名称是其在 IOC 容器中的唯一标识 5.POJO（Plain Ordinary Java Object）： Java 简单对象 6.@Configuration：代表是一个 Java 配置文件 7.@Component：标明哪个类被扫描进入 Spring IOC 容器&emsp;&emsp;@ComponentScan：标明采用何种策略去扫描装配 Bean&emsp;&emsp;&emsp;&emsp;basePackageClasses 参数可以用正则式去匹配包名&emsp;&emsp;&emsp;&emsp;includeFilters 和 excludeFilters 参数定义满足（或不满足）过滤器条件的 Bean 才去扫描，需要通过一个注解 @Filter 去定义&emsp;&emsp;&emsp;&emsp;可以通过配置 lazyInit 设置是否在 Bean 定以后完成实例化及依赖注入，默认为不延迟初始化（false） 12345# classes 定义注解类# pattern 定义正则式类@ComponentScan(basePackages = &quot;com.springboot.*&quot;, excludeFilters = &#123;@Filter(classes = &#123;Service.class&#125;, pattern = &quot;&quot;)&#125;)# 标注了 @Service 的类将不被 IOC 容器扫描注入 8.@Service 注解注入了 @Component， 即标注了 @Service 的类在默认情况下可以被 Spring IOC 容器扫描装配，无需再加入 @Component 注解&emsp;&emsp;@SpringBootApplication 注入了 @ComponentScan。启动类可以同时加入这两个注解来配置扫描包 9.可以通过 @Bean 将第三方包中的类对象放入 Spring IOC 容器中&emsp;&emsp;Spring 会将该方法返回的 DataSource 对象用名称 “dataSource” 保存在 IOC 容器中（未配置 name 属性时以方法名为名称保存） 1234567891011121314151617181920@Configurationpublic class AppConfig&#123; @Bean(name = "dataSource") public DataSource getDataSource()&#123; Properties props = new Properties(); props.setProperty("driver", "com.mysql.jdbc.Driver"); props.setProperty("url", "jdbc:mysql://localhost:3306/xxx"); props.setProperty("username", "root"); props.setProperty("password", "root"); DataSource dataSource = null; try&#123; dataSource = BasicDataSourceFactory.createDataSource(props); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return dataSource; &#125; &#125; 10.@Autowired：默认必须找到对应 Bean，可以设置 required 属性配置是否必须找到，默认为 true&emsp;&emsp;匹配机制：@Autowired 可以标注属性（注入属性）、方法（注入参数）、方法参数（注入参数） 11.装配：将 Bean 放入 Spring IOC 容器中&emsp;&emsp;注入：从 Spring IOC 容器中找出 Bean 赋值 12.消除歧义：&emsp;&emsp;@Primary：是的 POJO 注入优先级更高，标注 POJO 类名&emsp;&emsp;@Qualifier：利用 type + BeanName 在 IOC 容器进行查找装配，无视优先级，标注属性 123456......@Component@Primarypublic class Cat implements Animal&#123; ......&#125; 123@Autowired@Qualifier(&quot;dog&quot;)private Animal animal = null; 13.第三方类可以用 @Bean 来配置自定义初始化和销毁方法 14.Bean 的生命周期：&emsp;&emsp;Bean 定义：资源定位 –&gt; 解析 –&gt; 将Bean发布至 IOC 容器&emsp;&emsp;Bean 初始化：实例化 –&gt; 依赖注入&emsp;&emsp;Bean 生存期&emsp;&emsp;Bean 的销毁 15.使用属性文件：&emsp;&emsp;@Value：为属性或方法参数赋值，可以标注属性或方法（@Autowired 也可以标注属性或方法）&emsp;&emsp;@ConfigurationProperties(“xx”)：将匹配字符串与属性名组成的全限定名去配置文件中查找&emsp;&emsp;&emsp;&emsp;eg： “xx.属性名”&emsp;&emsp;@Property(value={“”}, ignoreResourceFound=false)：配置要查找的配置文件，可以通过 value 配置多个配置文件&emsp;&emsp;&emsp;&emsp;classpath:xx //类文件路径&emsp;&emsp;&emsp;&emsp;ignoreResourceFound：是否忽略配置文件找不到的问题，默认为 false 16.条件装配 Bean：用 @Conditional 注解配合 Condition 接口来完成&emsp;&emsp;@Conditional(xxx.class)：xxx 类必须实现 Condition 接口，即实现其 matches 方法&emsp;&emsp;&emsp;&emsp;matches 方法工作原理：&emsp;&emsp;&emsp;&emsp;matches 方法返回值为 boolean 类型；true：装配， false: 不装配17.作用域：&emsp;&emsp;Web 容器的四种作用域：页面（page）；请求（request）；会话（session）；应用（application）&emsp;&emsp;Spring 不支持 page 作用域 18.在 Spring 中可以用 singleton 作用域 代替 application 作用域 19.@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)：设置作用域，默认为单例（singleton）作用域&emsp;&emsp;ConfigurableBeanFactory 只能提供单例（SCOPE_SINGLETON）和原型（SCOPE_PROTOTYPE）两种作用域20.SpringBoot 引入 XML 配置 Bean：&emsp;&emsp;@ImportResource(value = “”)：引入该 XML 文件并将该文件中定义的 Bean 装配至 IOC 容器中 21.Spring EL：&emsp;&emsp;’${}’：占位符，读取属性&emsp;&emsp;’#{}’：Spring 表达式，可以在其中进行运算，调用方法 12# ?: 判断这个属性是否为空，不为空时执行 toUpperCase() 方法@Value(&quot;#&#123;beanName.str?.toUpperCase()&#125;&quot;)]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>springBoot</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BindingException 解决方法]]></title>
    <url>%2F2018%2F11%2F18%2FBindingException-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[报错原因：1org.apache.ibatis.binding.BindingException: Parameter 'name' not found. Available parameters are [arg1, arg0, param1, param2] 原因：在 dao 的方法中，直接写了两个方法的参数， Mybatis 没有办法将其绑定12@Insert(&#123;"insert into ", TABLE_NAME, "(", INSERT_FILED, ") values(#&#123;name&#125;, #&#123;note&#125;)"&#125;)int insertUser(String name, String note); 解决方法：在参数前加入 @Param(“”) 进行绑定12@Insert(&#123;"insert into ", TABLE_NAME, "(", INSERT_FILED, ") values(#&#123;name&#125;, #&#123;note&#125;)"&#125;)int insertUser(@Param("name") String name, @Param("note") String note);]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酷酷的单词]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%85%B7%E9%85%B7%E7%9A%84%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[输入一些仅由小写字母组成的单词。你的任务是统计有多少个单词是“酷”的，即每种字母出现的次数都不同。比如ada是酷的，因为a出现2次，d出现1次，而1和2不同。再比如，banana也是酷的，因为a出现3次，n出现2次，b出现1次。但是，bbacccd不是酷的，因为a和d出现的次数相同（均为1次）。 Input输入包含不超过30组数据。每组数据第一行为单词个数n (1&lt;=n&lt;=10000)。以下n行各包含一个单词，字母个数为1~30。 Output对于每组数据，输出测试点编号和酷单词的个数。 Sample Input2adabbacccd2illnessaSample OutputCase 1: 1Case 2: 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std; int main()&#123; int n, j = 0; set&lt;int&gt; m; set&lt;char&gt; s; char ch[30]; int num[26]; while(cin&gt;&gt;n) &#123; int ans = 0; while(n--) &#123; m.clear(); s.clear(); cin&gt;&gt;ch; int x; memset(num, 0, sizeof(num)); for(int i = 0; i &lt; strlen(ch); i++) &#123; s.insert(ch[i]); num[ch[i]-97]++; &#125; x = s.size(); for(int i = 0; i &lt; 26; i++) &#123; if(num[i] != 0) m.insert(num[i]); &#125; if(x != 1) &#123; if(x == m.size()) ans++; &#125; &#125; cout&lt;&lt;"Case "&lt;&lt;++j&lt;&lt;": "&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合并果子]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%2F</url>
    <content type="text"><![CDATA[Description现在有n堆果子，第i堆有ai个果子。现在要把这些果子合并成一堆，每次合并的代价是两堆果子的总果子数。求合并所有果子的最小代价。 Input第一行包含一个整数T（T&lt;=50），表示数据组数。每组数据第一行包含一个整数n（2&lt;=n&lt;=1000），表示果子的堆数。第二行包含n个正整数ai（ai&lt;=100），表示每堆果子的果子数。 Output每组数据仅一行，表示最小合并代价。 Sample Input241 2 3 453 5 2 1 4Sample Output1933Hint 解题思路每次对新的果堆重新排序选取最小的两堆加和 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int g[1005];int main()&#123; int T, n, ans, k; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; ans = 0; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;g[i]; &#125; sort(g, g + n); k = g[0]; for(int i = 1; i &lt; n; i++) &#123; g[i - 1] = k; //将k放入果堆中 sort(g + i - 1, g + n); //对新的果堆个数排序 k = g[i - 1]; //令k为排序后最小堆得果子数 k += g[i]; ans += k; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 2037】 今年暑假不AC]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-2037%E3%80%91-%E4%BB%8A%E5%B9%B4%E6%9A%91%E5%81%87%E4%B8%8DAC%2F</url>
    <content type="text"><![CDATA[“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目） Input输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。 Output对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。 Sample Input121 33 40 73 815 1915 2010 158 186 125 104 142 90 Sample Output5 解题思路在可选的节目中，每次选择结束时间最早的节目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;struct node&#123; int x, y;&#125;;node s[105];bool cmp(node &amp;a, node &amp;b)&#123; if(a.y &lt; b.y) return true; else &#123; if(a.y == b.y) &#123; if(a.x &lt; b.x) return true; else return false; &#125; else return false; &#125;&#125;int main()&#123; int n, ans, t; while(cin&gt;&gt;n &amp;&amp; n) &#123; ans = 0; t = 0; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;s[i].x&gt;&gt;s[i].y; &#125; sort(s, s + n, cmp); for(int i = 0; i &lt; n; i++) &#123; if(t &lt;= s[i].x) &#123; ans++; t = s[i].y; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU - 1176】 免费馅饼]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1176%E3%80%91-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC%2F</url>
    <content type="text"><![CDATA[都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标： 为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼） Input输入数据有多组。每组数据的第一行为以正整数n(0&lt;n&lt;100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0&lt;T&lt;100000),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n=0时输入结束。 Output每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。 Sample Input65 14 16 17 27 28 30 Sample Output4 解题思路从结尾倒序循环，找出到出发点获利最大的路线 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n, x, t;int dp[100005][13];int main()&#123; int time = 0; while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;x, &amp;t); time = max(time, t); //算出最大时间 dp[t][x]++; &#125; for(int i = time - 1; i &gt;= 0; i--) //倒序循环 &#123; for(int j = 10; j &gt;= 0; j--) &#123; dp[i][j] += max(dp[i + 1][j - 1], max(dp[i + 1][j], dp[i + 1][j + 1])); //选出三个方案中获得馅饼最多的一个 &#125; &#125; cout&lt;&lt;dp[0][5]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU - 1241】 Oil Deposits]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1241%E3%80%91-Oil-Deposits%2F</url>
    <content type="text"><![CDATA[The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. InputThe input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either *&#39;, representing the absence of oil, or@’, representing an oil pocket. OutputFor each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. Sample Input1 13 5 @@@@@1 8@@**@5 5*@ @@@ @@@@@*@@@**@0 0 Sample Output0122 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std; const int N = 105;char pic[N][N];int m, n; void dfs(int r, int c)&#123; if(r &gt;= m || r &lt; 0 || c &gt;= n || c &lt; 0 || pic[r][c] != '@') return; pic[r][c] = '*'; for(int i = -1; i &lt;= 1; i++) for(int j = -1; j &lt;= 1; j++) &#123; if(i != 0 || j !=0) dfs(r+i, c+j); &#125;&#125;int main()&#123; while(cin&gt;&gt;m&gt;&gt;n &amp;&amp; m) &#123; int cnt = 0; for(int i = 0; i &lt; m; i++) for(int j = 0; j &lt; n; j++) cin&gt;&gt;pic[i][j]; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n ; j++) &#123; if(pic[i][j] == '@') &#123; dfs(i, j); cnt++; &#125; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU - 1312】 Red and Black]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1312%E3%80%91-Red-and-Black%2F</url>
    <content type="text"><![CDATA[There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. Write a program to count the number of black tiles which he can reach by repeating the moves described above. InputThe input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. ‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set) OutputFor each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input6 9….#.…..#………………………… #@…#.#..#.11 9.#……….#.#######..#.#…..#..#.#.###.#..#.#..@#.#..#.#####.#..#…….#..#########.………..11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#.. ###.###...@… ###.###..#.#....#.#..0 0 Sample Output4559613 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt; using namespace std; char ch[25][25]; int pic[25][25]; int m, n, ans; void dfs(int r, int c) &#123; if(r &lt; 0 || r &gt;= n || c &lt; 0 || c &gt;= m) return; if(ch[r][c] == '#') return; if(pic[r][c] == 1) return; ans++; pic[r][c] = 1; dfs(r + 1, c); dfs(r, c + 1); dfs(r - 1, c); dfs(r, c - 1); &#125; int main() &#123; while(cin&gt;&gt;m&gt;&gt;n &amp;&amp; m &amp;&amp; n) &#123; ans = 0; for(int i = 0; i &lt; n; i++) cin&gt;&gt;ch[i]; memset(pic, 0, sizeof(pic)); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(ch[i][j] == '@') &#123; dfs(i, j); &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU - 1548】 A strange lift]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1548%E3%80%91-A-strange-lift%2F</url>
    <content type="text"><![CDATA[There is a strange lift.The lift can stop can at every floor as you want, and there is a number Ki(0 &lt;= Ki &lt;= N) on every floor.The lift have just two buttons: up and down.When you at floor i,if you press the button “UP” , you will go up Ki floor,i.e,you will go to the i+Ki th floor,as the same, if you press the button “DOWN” , you will go down Ki floor,i.e,you will go to the i-Ki th floor. Of course, the lift can’t go up high than N,and can’t go down lower than 1. For example, there is a buliding with 5 floors, and k1 = 3, k2 = 3,k3 = 1,k4 = 2, k5 = 5.Begining from the 1 st floor,you can press the button “UP”, and you’ll go up to the 4 th floor,and if you press the button “DOWN”, the lift can’t do it, because it can’t go down to the -2 th floor,as you know ,the -2 th floor isn’t exist.Here comes the problem: when you are on floor A,and you want to go to floor B,how many times at least he has to press the button “UP” or “DOWN”? InputThe input consists of several test cases.,Each test case contains two lines.The first line contains three integers N ,A,B( 1 &lt;= N,A,B &lt;= 200) which describe above,The second line consist N integers k1,k2,….kn.A single 0 indicate the end of the input. OutputFor each case of the input output a interger, the least times you have to press the button when you on floor A,and you want to go to floor B.If you can’t reach floor B,printf “-1”. Sample Input5 1 53 3 1 2 50 Sample Output3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std; typedef struct Elevator&#123; int first,second;&#125;P;/*typedef pair&lt;int, int&gt; P;*/const int M = 205;int N, A, B, num = 0;int idx[M];int k[M]; int bfs()&#123; P p, p1; queue&lt;P&gt; q; memset(idx, 0, sizeof(idx)); p.first = A; p.second = 0; idx[p.first] = 1; q.push(p); while(!q.empty()) &#123; p = q.front(); q.pop(); if(p.first == B) return p.second; p1.first = p.first - k[p.first]; if(p1.first &gt; 0 &amp;&amp; p1.first &lt;= N &amp;&amp; !idx[p1.first]) &#123; p1.second = p.second + 1; idx[p.first] = 1; q.push(p1); &#125; p1.first = p.first + k[p.first]; if(p1.first &gt; 0 &amp;&amp; p1.first &lt;= N &amp;&amp; !idx[p1.first]) &#123; p1.second = p.second + 1; idx[p.first] = 1; q.push(p1); &#125; &#125; return -1;&#125;int main()&#123; while(cin&gt;&gt;N) &#123; if(!N) break; cin&gt;&gt;A&gt;&gt;B; for(int i = 1; i &lt;= N; i++) cin&gt;&gt;k[i]; cout&lt;&lt;bfs()&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>bfs</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 2571】 命运]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-2571%E3%80%91-%E5%91%BD%E8%BF%90%2F</url>
    <content type="text"><![CDATA[穿过幽谷意味着离大魔王lemon已经无限接近了！可谁能想到，yifenfei在斩杀了一些虾兵蟹将后，却再次面临命运大迷宫的考验，这是魔王lemon设下的又一个机关。要知道，不论何人，若在迷宫中被困1小时以上，则必死无疑！可怜的yifenfei为了去救MM，义无返顾地跳进了迷宫。让我们一起帮帮执着的他吧！命运大迷宫可以看成是一个两维的方格阵列，如下图所示: yifenfei一开始在左上角，目的当然是到达右下角的大魔王所在地。迷宫的每一个格子都受到幸运女神眷恋或者痛苦魔王的诅咒，所以每个格子都对应一个值，走到那里便自动得到了对应的值。现在规定yifenfei只能向右或者向下走，向下一次只能走一格。但是如果向右走，则每次可以走一格或者走到该行的列数是当前所在列数倍数的格子，即：如果当前格子是（x,y），下一步可以是（x+1,y），(x,y+1)或者(x,y*k) 其中k&gt;1。为了能够最大把握的消灭魔王lemon，yifenfei希望能够在这个命运大迷宫中得到最大的幸运值。 Input输入数据首先是一个整数C，表示测试数据的组数。每组测试数据的第一行是两个整数n,m，分别表示行数和列数(1&lt;=n&lt;=20,10&lt;=m&lt;=1000)；接着是n行数据，每行包含m个整数，表示n行m列的格子对应的幸运值K ( |k|&lt;100 )。Output请对应每组测试数据输出一个整数，表示yifenfei可以得到的最大幸运值。Sample Input13 89 10 10 10 10 -10 10 1010 -11 -1 0 2 11 10 -20-11 -11 10 11 2 10 -10 -10Sample Output52 解题思路从左上角开始逐渐转移状态，将开始的dp数组的值设为很小的负数值，每次将上次路线的幸运值和本次的值相比较选出更大的一个 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;cmath&gt;using namespace std;int C, n, m;int a[25], b[1005];int dp[25][1005], dex[25][1005]; int main()&#123; cin&gt;&gt;C; while(C--) &#123; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n &amp;&amp; m) &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; cin&gt;&gt;dex[i][j]; dp[i][j] = -999999999; //将二维数组的值设为最大 &#125; &#125; dp[1][1] = dex[1][1]; //改变开始点的值以进行后续扫描 for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; dp[i][j + 1] = max(dp[i][j + 1], dp[i][j] + dex[i][j + 1]); //向右一格 dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + dex[i + 1][j]); //向左一格 for(int k = 2; k * j &lt;= m; k++) //向右所在列的倍数格 &#123; dp[i][j * k] = max(dp[i][j * k], dp[i][j] + dex[i][j * k]); //在当前路线和上一次路线中选择更大的幸运值 &#125; &#125; &#125; cout&lt;&lt;dp[n][m]&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihoCoder 1015 KMP算法]]></title>
    <url>%2F2018%2F11%2F11%2FhihoCoder-1015-KMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[传送门：http://hihocoder.com/problemset/problem/1015 解题思路KMP算法是一种字符串匹配算法，我理解为对字符串暴搜的优化，难点在next函数的求值，看了两天还是没有完全弄懂next数组的意思 可以写出函数但是对其中的递归实现只是在看明白了的状态。 但是对next数组也有一点优化。 next数组中值：对应字符前的字符串的最大相同前后缀长度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std; const int MAX = 1e6 + 5; int Next[MAX];char S[MAX], P[MAX];int KMP(char *s1, char *s2)&#123; int m1 = strlen(s1), m2 = strlen(s2); Next[0] = 0; int ans, j; ans = 0; j = 1; while(j &lt; m2)&#123; int k = Next[j - 1]; while(s2[j] != s2[k] &amp;&amp; k)&#123; //两字符不等，函数值与上一字符函数值相同 k = Next[k - 1]; &#125; if(s2[j] == s2[k]) //新比较的字符相等，函数值加一 Next[j] = k + 1; else Next[j] = 0; //新比较字符不等，跳回首字符 j++; &#125; j = 0; for(int i = 0; i &lt; m1; i++)&#123; while(s1[i] != s2[j] &amp;&amp; j)&#123; //出现不匹配的情况，根据next函数值右移指定大小 j = Next[j - 1]; &#125; if(s1[i] == s2[j]) //相匹配后，右移继续判断 j++; if(j == m2)&#123; //出现成功匹配的情况，答案加一 ans++; &#125; &#125; return ans;&#125;int main()&#123; int N; cin&gt;&gt;N; while(N--)&#123; cin&gt;&gt;P; cin&gt;&gt;S; cout&lt;&lt;KMP(S, P)&lt;&lt;endl; &#125; return 0;&#125; ##这里有一个大坑需要注意因为其他大佬博客上的讲解都是next值，所以我直接把数组命名为next，写完之后再Dev-C++里跑起来运行结果也是正确的，然后自信满满的提交，于是，我就CE了，下图从下数第三个AC是我直接换了大佬的代码提交来实验的，发现可以过，然后一直改一直改，直到把next全部改为Next才AC，但是因为当时改了不止这一项，就一个个还原看究竟是哪里出了问题，最终发现罪魁祸首是next，之后也在网上查了这个问题，next并不是C++关键字，但是在C++里开next[] 必须初始化，但是其他数组名不受此限制。]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>hihoCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihoCoder 1014 Trie树]]></title>
    <url>%2F2018%2F11%2F11%2FhihoCoder-1014-Trie%E6%A0%91%2F</url>
    <content type="text"><![CDATA[传送门：http://www.hihocoder.com/problemset/problem/1014 解题思路Trie树（字典树或前缀树）的根节点是没有字符的，其他节点顺序连接构成一个字符串且每条路径包含的字符串都不同 此算法利用空间换时间，对内存消耗大但比哈希表更省时间 本题中，每个节点包含着二十六个字母对应的子节点已经通过该节点的字符串的个数 每添加一个字符串，就新建一个若干节点，途径的所有节点的num变量加一 最终输出最后的节点的num值或返回0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; node *next[26]; int num; node() &#123; num = 0; for(int i = 0; i &lt; 26; i++) next[i] = NULL; &#125;&#125;;node *root;void insert(char *s)&#123; int index; node *tree = root; for(int i = 0; i &lt; strlen(s); i++) &#123; index = s[i] - 'a'; if(tree -&gt; next[index] == NULL) &#123; node *new_tree = new node; tree -&gt; next[index] = new_tree; &#125; tree = tree -&gt; next[index]; tree -&gt; num ++; &#125;&#125;int check(char *s)&#123; node *tree = root; int index, ans; for(int i = 0; i &lt; strlen(s); i++) &#123; index = s[i] - 'a'; if(tree -&gt; next[index] == NULL) return 0; else tree = tree -&gt; next[index]; &#125; ans = tree -&gt; num; return ans;&#125;int main()&#123; char ch[15], ch1[15]; int m, n, ans; cin&gt;&gt;m; root = new node; while(m--) &#123; cin&gt;&gt;ch; insert(ch); &#125; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;ch1; ans = check(ch1); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>hihoCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihoCoder 1032 最长回文串]]></title>
    <url>%2F2018%2F11%2F11%2FhihoCoder-1032-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[传送门：http://www.hihocoder.com/problemset/problem/1032 解题思路我理解为在枚举的基础上优化算法，奇数可以直接利用算法，但偶数要在输入的字符串中插入辅助字符来帮助解题 网上有四种算法，我这个应该算是Manacher法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int N, ans;char ch[1000005];int p[2000005];char new_ch[2000005];int id, mx;int main()&#123; cin&gt;&gt;N; for(int i = 0; i &lt; N; i++) &#123; cin&gt;&gt;ch; ans = 0; id = 0; mx = 0; new_ch[0] = '$'; new_ch[1] = '#'; int n = strlen(ch); for(int j = 0; j &lt; n; j++) &#123; new_ch[2 * j + 2] = ch[j]; new_ch[2 * j + 3] = '#'; &#125; n = 2 * n + 2; new_ch[n] = '\0'; for(int j = 0; j &lt; n; j++) &#123; if(mx &gt; j) p[j] = min(p[2 * id - j], mx - j); else p[j] = 1; while(new_ch[j + p[j]] == new_ch[j - p[j]] &amp;&amp; j + p[j] &lt; n &amp;&amp; j - p[j] &gt; 0) p[j]++; if(mx &lt; p[j] + j) &#123; mx = p[j] + j; id = j; &#125; if(ans &lt; p[j]) ans = p[j]; &#125; ch[0] = '\0'; new_ch[0] = '\0'; cout&lt;&lt;ans - 1&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>hihoCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihoCoder 1036 Trie图]]></title>
    <url>%2F2018%2F11%2F11%2FhihoCoder-1036-Trie%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[传送门：http://hihocoder.com/problemset/problem/1036 解题思路自动机即在Trie树中利用KMP算法的next数组进行优化搜索，并且利用了BFS进行遍历建树 在建树时不能用for循环遍历26个字母，否则会超时，TL的教训 每走到一个节点，计算它的后缀节点和该节点表示的字符串加上任一字符后所生成的字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std; int n;char s[1000005]; struct node&#123; node *son[26]; //二十六个子节点 node *next; //后缀节点 bool end_; node():end_(false), next(NULL)&#123; memset(son, NULL, sizeof(son)); &#125;&#125;;node *root;void insert(char *c)&#123; int index; node *tree = root; while(*c) //用for循环遍历26个字母会超时 &#123; index = *c - 'a'; if(tree -&gt; son[index] == NULL) //没有子节点则直接新建一个子节点 &#123; tree -&gt; son[index] = new node(); &#125; tree = tree -&gt; son[index]; //指向刚添加的子节点 ++c; &#125; tree -&gt; end_ = true; //对每个字符串的结尾进行标记表示已经结束&#125;void build()&#123; queue&lt;node *&gt; que; node *tree = root; for(int i = 0; i &lt; 26; i++) &#123; if(root -&gt; son[i] != NULL) //当存在有该字母的边连接的子节点 &#123; tree -&gt; son[i] -&gt; next = root; //根节点的所有子节点的后缀节点都是根节点 que.push(tree -&gt; son[i]); //利用BFS进行遍历 &#125; &#125; while(!que.empty()) &#123; tree = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) &#123; if(tree -&gt; son[i] != NULL) //存在对应字母的节点 &#123; while(tree -&gt; next != NULL) //后缀节点不为空 &#123; if(tree -&gt; next -&gt; son[i] != NULL) &#123; tree -&gt; son[i] -&gt; next = tree -&gt; next -&gt; son[i]; //子节点的后缀节点为父节点的后缀节点加子节点比父节点多的字母 if(tree -&gt; next -&gt; son[i] -&gt; end_) tree -&gt; son[i] -&gt; end_ = true; //后缀节点为标记节点的节点也需要被标记 即字符串结束的标记 break; //当前字母成功匹配，退出循环，比较下一个字符 &#125; tree -&gt; next = tree -&gt; next -&gt; next; &#125; if(tree -&gt; son[i] -&gt; next == NULL) //若无对应的后缀节点则将root作为后缀节点 tree -&gt; son[i] -&gt; next = root; que.push(tree -&gt; son[i]); &#125; &#125; &#125;&#125;bool check(char *c)&#123; int index; node *tree = root; while(*c) &#123; index = *c - 'a'; while(tree != NULL)&#123; if(tree -&gt; son[index] != NULL)&#123; tree = tree -&gt; son[index]; if(tree -&gt; end_ == true) return true; break; &#125; tree = tree -&gt; next; &#125; if(tree == NULL) //图中不存在该字符，则从root开始重新查找 tree = root; ++c; &#125; return false;&#125;int main()&#123; root = new node(); bool ans; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;s; insert(s); &#125; build(); cin&gt;&gt;s; ans = check(s); if(ans) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>hihoCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihoCoder 1037 数字三角形]]></title>
    <url>%2F2018%2F11%2F11%2FhihoCoder-1037-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[问题描述小Hi和小Ho在经历了螃蟹先生的任务之后被奖励了一次出国旅游的机会，于是他们来到了大洋彼岸的美国。美国人民的生活非常有意思，经常会有形形色色、奇奇怪怪的活动举办，这不，小Hi和小Ho刚刚下飞机，就赶上了当地的迷宫节活动。迷宫节里展览出来的迷宫都特别的有意思，但是小Ho却相中了一个其实并不怎么像迷宫的迷宫——因为这个迷宫的奖励非常丰富~]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>hihoCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihoCoder 1049 后序遍历]]></title>
    <url>%2F2018%2F11%2F11%2FhihoCoder-1049-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[问题描述在参与过了美食节之后，小Hi和小Ho在别的地方又玩耍了一阵子，在这个过程中，小Ho得到了一个非常有意思的玩具——一棵由小球和木棍连接起来的二叉树！ 小Ho对这棵二叉树爱不释手，于是给它的每一个节点都标记了一个标号——一个属于A..Z的大写字母，并且没有任意两个节点的标号是一样的。小Hi也瞅准了这个机会，重新巩固了一下小Ho关于二叉树遍历的基础知识~就这样，日子安稳的过了两天。 这天，小Ho正好在求解这棵二叉树的前序、中序和后序遍历的结果，但是却在求出前序遍历和中序遍历之后不小心把二叉树摔到了地上，小球和木棍等零件散落了一地！ 小Ho损失了心爱的玩具，正要嚎啕大哭起来，所幸被小Hi发现了，劝说道：“别着急，这不是零件都还在么？拼起来不就是了？” “可是我忘记了二叉树长什么样子了！”小Ho沮丧道。 “这个简单，你不是刚刚求出了这棵二叉树的前序和中序遍历的结果么，利用这两个信息就可以还原出整棵二叉树来哦！” “这样么？！！”小Ho止住了泪水，问道：“那要怎么做呢？” 没错！小Ho在这一周遇到的问题便是：给出一棵二叉树的前序和中序遍历的结果，还原这棵二叉树并输出其后序遍历的结果。 提示：分而治之——化大为小，化小为无输入每个测试点（输入文件）有且仅有一组测试数据。 每组测试数据的第一行为一个由大写英文字母组成的字符串，表示该二叉树的前序遍历的结果。 每组测试数据的第二行为一个由大写英文字母组成的字符串，表示该二叉树的中序遍历的结果。 对于100%的数据，满足二叉树的节点数小于等于26。 输出对于每组测试数据，输出一个由大写英文字母组成的字符串，表示还原出的二叉树的后序遍历的结果。 样例输入ABBA样例输出BA 感觉这道题用java会比较容易一点，java对于数组的一些功能比C/C++更好用一些，但是第一次用java答题，有一个坑就是类名必须是Main，不用Main的结果如图 报错原因： 解题思路post_order(str1, str2)=post_order(str1l, str2l)+post_order(str1r, str2r)+root 利用前序遍历找出根节点，递归，直到当前节点是叶子节点 1234567891011121314151617181920212223242526272829303132import java.util.Scanner; public class Main &#123; public static String post_order(String str1, String str2)&#123; if(str1.length() &gt; 0 &amp;&amp; str1.length() == str2.length())&#123; char root = str1.charAt(0); int index = str2.indexOf(root); if(index != -1) &#123; String left = str2.substring(0, index); String right = str2.substring(index+1); return post_order(str1.substring(1, left.length()+1),left) +post_order(str1.substring(left.length()+1),right) +root; &#125; else return ""; &#125; else return ""; &#125; public static void main(String[] args) &#123; String str1 = new String(); String str2 = new String(); Scanner input = new Scanner(System.in); str1 = input.nextLine(); str2 = input.nextLine(); System.out.println(post_order(str1, str2)); &#125; &#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>hihoCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现简单聊天程序（集合，线程，I/O，网络编程）]]></title>
    <url>%2F2018%2F11%2F11%2FJava%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8CI-O%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这半个月的大作业，程序有一些不完善的地方有待提高，但是基本的聊天室功能已经可以实现 还没有接触javaFx所以用了swing做了简陋的界面 补充：{ 今天突然记起来，把这个大作业交了，然后大佬突然问我这个程序有没有线程安全问题，怎么处理的。我以为这只是把socket传入的字节重新传到客户端不存在修改也不存在线程的安全问题，大佬说只要有多个线程共享的数据，就有可能有线程安全问题！！！切记我恰好在服务器端用了vector集合存储了线程，所以避免了安全性问题，但是如果用了其他的容器还是会出现线程安全问题。例如，ArrayList里，容量是有一个上限的，在当前容量已满的情况下，会进行扩容，先判断是否达到容量上限，如果没有，就将进行扩容，如果达到则会报异常。如果没有给线程上锁，当有两个对象同时加入ArrayList里且容量只够再一次扩容时，会爆内存。而使用vector则没有这种担忧，看过vector源码的API就会知道，vector的实现方法都用synchronized包装了。synchronized：这是java语言的关键字，被它修饰的方法或代码块在执行的时候能够保证在同一时刻最多只有一个线程执行该段代码，相当于一个上锁的操作。 } 客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import java.awt.BorderLayout;import java.awt.Color;import java.awt.Container;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTextArea;import javax.swing.JTextField; public class Client extends JFrame &#123; private static final long serialVersionUID = 1L; JTextField JTF = new JTextField(); JTextArea JTA = new JTextArea(); JScrollPane JSP = new JScrollPane(JTA); Socket socket = null; OutputStream ops = null; InputStream ips = null; String name = new String(); public void makeWindow()&#123; name = JOptionPane.showInputDialog(null, "请输入用户名字", "输入用户名", JOptionPane.INFORMATION_MESSAGE); connect(); JFrame frame = new JFrame("聊天窗口"); frame.setSize(500, 400); Container contentPane = frame.getContentPane(); JPanel panel = new JPanel(); panel.setBackground(Color.CYAN); JButton bts = new JButton("send"); JButton btc = new JButton("close"); panel.add(bts); panel.add(btc); JTA.setEditable(false); JPanel panel_ = new JPanel(new BorderLayout()); panel_.add(JTF, BorderLayout.SOUTH);// panel_.add(JTA, BorderLayout.CENTER); panel_.add(JSP, BorderLayout.CENTER); contentPane.add(panel, BorderLayout.SOUTH); contentPane.add(panel_, BorderLayout.CENTER); frame.setVisible(true); frame.setLocationRelativeTo(null); frame.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; CloseAll(); System.out.println("已关闭窗口"); System.exit(0); &#125; &#125;); btc.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; CloseAll(); System.out.println("press the btc"); System.exit(0); &#125; &#125;); bts.addActionListener(new ButtonListener()); new Thread(new ClientTest()).start(); &#125; public class ButtonListener implements ActionListener&#123; public void actionPerformed(ActionEvent arg0) &#123; String str = new String(); str = JTF.getText(); Date date = new Date(); DateFormat format = new SimpleDateFormat("HH:mm:ss"); String time = format.format(date); str = name + " send at " + time + ":\n" + str; JTF.setText(""); try &#123; ops.write(str.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); CloseAll(); &#125; &#125; &#125; public static void main(String[] args) &#123; Client c = new Client(); c.makeWindow(); &#125; public void connect()&#123; try &#123; socket = new Socket(InetAddress.getByName("127.0.0.1"), 9090); ops = socket.getOutputStream(); System.out.println("Open the Socket"); &#125; catch (UnknownHostException e) &#123; CloseAll(); e.printStackTrace(); &#125; catch (IOException e) &#123; CloseAll(); e.printStackTrace(); &#125; &#125; public void CloseAll()&#123; if(ips != null)&#123; try &#123; ips.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(ops != null)&#123; try &#123; ops.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("Close All"); &#125; class ClientTest implements Runnable&#123; @Override public void run()&#123; try &#123; ips = socket.getInputStream(); byte[] b = new byte[1024]; int len; while((len = ips.read(b)) != -1)&#123; String receStr = new String(b, 0, len); String appear = new String(); appear = JTA.getText()+ receStr + '\n'; JTA.setText(appear); JTF.setText(""); &#125; &#125; catch (IOException e) &#123; System.out.println("I hava closed! Please don't send message!"); &#125; &#125; &#125; &#125; 服务端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.Vector; public class Server &#123; public Vector&lt;ServerTest&gt; v = new Vector&lt;ServerTest&gt;(); ServerSocket ss = null;// Socket s = null;// InputStream ips = null;// OutputStream ops = null; public void receive()&#123; try &#123; ss = new ServerSocket(9090); System.out.println("I am the Server"); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; try &#123; while(true)&#123; Socket s = ss.accept(); ServerTest st = new ServerTest(s);System.out.println("a client connected!"); v.add(st); new Thread(st).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(ss != null)&#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("I have close all!"); &#125; &#125; public static void main(String[] args) &#123; Server server = new Server(); server.receive(); &#125; class ServerTest implements Runnable&#123; Socket s = null; InputStream ips = null; OutputStream ops = null; public ServerTest(Socket s)&#123; this.s = s; &#125; public void run() &#123; try &#123; while(true) &#123; this.ips = this.s.getInputStream(); this.ops = this.s.getOutputStream(); byte[] b = new byte[1024]; int len; while((len = this.ips.read(b)) != -1)&#123; String str = new String(b, 0, len); for(int i = 0; i &lt; v.size(); i++)&#123; ServerTest st = v.get(i); st.ops.write(str.getBytes()); &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(ips != null)&#123; try &#123; ips.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(ops != null)&#123; try &#123; ops.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(s != null)&#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现简单数独游戏]]></title>
    <url>%2F2018%2F11%2F11%2FJava%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[本来打算晚上把javaFx需要的组件装好以后直接用javaFx的，但似乎eclipse的版本不对，安装了也不能用，非洲人非了一天… 数独代码是在大一寒假受命写的，学了一个月java的成果，现在看来有些不足但毕竟是第一个程序，就直接放上来，数独终盘的实现直接用了暴力，时间复杂度有点高，懒得改了直接放代码 终盘实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import java.util.Random; public class SudokuPuzzleGenerator &#123; private Random random = new Random(); private static final int MAX_CALL_RANDOM_ARRAY_TIMES = 220; private int currentTimes = 0; public int[][] generatePuzzleMatrix() &#123; int[][] randomMatrix = new int[9][9]; for (int row = 0; row &lt; 9; row++) &#123; if (row == 0) &#123; currentTimes = 0; randomMatrix[row] = buildRandomArray(); &#125; else &#123; int[] tempRandomArray = buildRandomArray(); for (int col = 0; col &lt; 9; col++) &#123; if (currentTimes &lt; MAX_CALL_RANDOM_ARRAY_TIMES) &#123; if (!isCandidateNmbFound(randomMatrix, tempRandomArray, row, col)) &#123; resetValuesInRowToZero(randomMatrix,row); row -= 1; col = 8; tempRandomArray = buildRandomArray(); &#125; &#125; else &#123; row = -1; col = 8; resetValuesToZeros(randomMatrix); currentTimes = 0; &#125; &#125; &#125; &#125; return randomMatrix; &#125; private void resetValuesInRowToZero(int[][] matrix, int row) &#123; for (int j = 0; j &lt; 9; j++) &#123; matrix[row][j] = 0; &#125; &#125; private void resetValuesToZeros(int[][] matrix) &#123; for (int row = 0; row &lt; 9; row++) &#123; for (int col = 0; col &lt; 9; col++) &#123; matrix[row][col] = 0; &#125; &#125; &#125; private boolean isCandidateNmbFound(int[][] randomMatrix, int[] randomArray, int row, int col) &#123; for (int i = 0; i &lt; 9; i++) &#123; randomMatrix[row][col] = randomArray[i]; if (noConflict(randomMatrix, row, col)) &#123; return true; &#125; &#125; return false; &#125; private boolean noConflict(int[][] candidateMatrix, int row, int col) &#123; return noConflictInRow(candidateMatrix, row, col)&amp;&amp;noConflictInColumn(candidateMatrix, row, col) &amp;&amp; noConflictInBlock(candidateMatrix, row, col); &#125; private boolean noConflictInRow(int[][] candidateMatrix, int row, int col) &#123; int currentValue = candidateMatrix[row][col]; for (int colNum = 0; colNum &lt; col; colNum++) &#123; if (currentValue == candidateMatrix[row][colNum]) &#123; return false; &#125; &#125; return true; &#125; private boolean noConflictInColumn(int[][] candidateMatrix, int row, int col) &#123; int currentValue = candidateMatrix[row][col]; for (int rowNum = 0; rowNum &lt; row; rowNum++) &#123; if (currentValue == candidateMatrix[rowNum][col]) &#123; return false; &#125; &#125; return true; &#125; private boolean noConflictInBlock(int[][] candidateMatrix, int row, int col) &#123; int baseRow = row / 3 * 3; int baseCol = col / 3 * 3; for (int rowNum = 0; rowNum &lt; 8; rowNum++) &#123; if (candidateMatrix[baseRow + rowNum / 3][baseCol + rowNum % 3] == 0) &#123; continue; &#125; for (int colNum = rowNum + 1; colNum &lt; 9; colNum++) &#123; if (candidateMatrix[baseRow + rowNum / 3][baseCol + rowNum % 3] == candidateMatrix[baseRow + colNum / 3][baseCol + colNum % 3]) &#123; return false; &#125; &#125; &#125; return true; &#125; private int[] buildRandomArray() &#123; currentTimes++; int[] array = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int randomInt = 0; for (int i = 0; i &lt; 20; i++) &#123; randomInt = random.nextInt(8) + 1; int temp = array[0]; array[0] = array[randomInt]; array[randomInt] = temp; &#125; return array; &#125; public int getCurrentTimes() &#123; return currentTimes; &#125; public void setCurrentTimes(int currentTimes) &#123; this.currentTimes = currentTimes; &#125; &#125; 界面及判断: 用swing写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import javax.swing.*; import java.awt.*;import java.awt.event.*;import java.util.Random; public class ShuD extends JFrame&#123; private static final long serialVersionUID = 5952689219411916553L; //序列化字段 private static JTextField a[][] = new JTextField[9][9]; //存储文本框中的数字 static int ans[][] = new int[9][9]; //存储输入后的两位数组 SudokuPuzzleGenerator example = new SudokuPuzzleGenerator(); public int right[][] = example.generatePuzzleMatrix(); public int rightans[][]; private int[][] Wk(int a[][])&#123; //挖空 Random r = new Random(); int a1, a2; a1 = r.nextInt(9); a2 = r.nextInt(9); for(int i = 0; i &lt; 100; i++) &#123; a[a1][a2] = 0; a1 = r.nextInt(9); a2 = r.nextInt(9); &#125; return a; &#125; public ShuD()&#123; Container c = getContentPane(); c.setLayout(new BorderLayout(2, 1)); //边框布局 JMenuItem jmiOk = new JMenuItem("提交"); //定义菜单 JMenuItem jmiExplain = new JMenuItem("详情"); JMenuItem jmiMessage = new JMenuItem("信息"); JPanel panel = new JPanel(); //定义一个容器 panel.add(jmiOk); //将菜单在容器内显示 panel.add(jmiExplain); panel.add(jmiMessage); JPanel p1 = new JPanel(new GridLayout(9, 9, 5, 5)); //定义9行9列的网格布局 add(panel,BorderLayout.NORTH); //将菜单放置在北面 add(p1,BorderLayout.CENTER); //将数字放置在正中间 rightans = Wk(right); for(int k = 0;k&lt;9; k ++) &#123; for(int n=0;n&lt;9;n++) &#123; if(rightans[k][n] != 0) &#123; a[k][n] = new JTextField("" + rightans[k][n]); a[k][n].setHorizontalAlignment(JTextField.CENTER);//将数字水平居中 a[k][n].setEditable(false); //只可显示不可修改 p1.add(a[k][n]); //添加文本框 &#125; else &#123; a[k][n] = new JTextField(); a[k][n].setHorizontalAlignment(JTextField.CENTER); p1.add(a[k][n]); &#125; &#125; &#125; add(p1); //将数字面板显示在容器里 jmiOk.addActionListener(new ActionListener()&#123;//匿名创建事件监听器 public void actionPerformed(ActionEvent e) &#123; if(gettext() == 1) &#123; if(judge() == true) &#123; JOptionPane.showMessageDialog(null, "Your answer is right!","Result",JOptionPane.INFORMATION_MESSAGE); &#125; else &#123; JOptionPane.showMessageDialog(null, "Your answer is wrong!","Result",JOptionPane.INFORMATION_MESSAGE); &#125; &#125; &#125; &#125;); explainListenerClass listener2 = new explainListenerClass(); jmiExplain.addActionListener(listener2); messageListenerClass listener3 = new messageListenerClass(); jmiMessage.addActionListener(listener3); &#125; static int gettext() //获取文本框的文字 &#123; int i,j; for(i = 0; i &lt; 9; i++) &#123; for(j = 0; j &lt; 9 ; j ++) &#123; ans[i][j] = 0; &#125; &#125; for(int k = 0;k &lt; 9; k++) &#123; for(int n = 0;n &lt; 9; n++) &#123; try //异常处理 &#123; ans[k][n] = Integer.parseInt(a[k][n].getText()); //将答案类型转换之后传给ans &#125; catch(NumberFormatException nfe) &#123; JOptionPane.showMessageDialog(null,"数据中包括非数字，请重新输入"); return 0; &#125; &#125; &#125; return 1; &#125; public static boolean judge() //判断输入的答案是否正确 &#123; int i,j,k; int [][]answer = ans; for(i = 0; i &lt; 9; i ++) &#123; if(judge9(answer[i]) == false) //判断每列是否有重复数字 return false; &#125; for(j = 0; j &lt; 9; j ++) //判断每行是否有重复数字 &#123; int[] newAnswerColumn = new int[9]; for(i = 0; i &lt; 9; i ++) &#123; newAnswerColumn[i] = answer[i][j]; &#125; if(judge9(newAnswerColumn) == false) return false; &#125; for(i = 0; i &lt; 3; i ++) //判断每个小九宫格内是否有重复数字 &#123; for(j = 0; j &lt; 3; j ++) &#123; k = 0; int[] newAnswer = new int[9]; for(int m = i * 3; m &lt; i * 3 + 3; m ++) &#123; for(int n = j * 3; n &lt; j * 3 + 3; n ++) &#123; newAnswer[k] = answer[m][n]; k++; &#125; &#125; if(judge9(newAnswer) == false) &#123; return false; &#125; &#125; &#125; return true; &#125; public static boolean judge9(int[] answer) &#123; int i,j; for(i = 0; i &lt; 9; i ++) &#123; for(j = 0; j &lt; 9; j ++) &#123; if(i == j) continue; if(answer[i] == answer[j]) //如果有重复的数字，返回false &#123; return false; &#125; &#125; &#125; return true; //没有重复数字，返回true &#125; public static void main(String[] args) &#123; JFrame frame = new ShuD(); frame.setTitle("SuDoku"); frame.setSize(600,900); frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); &#125;&#125;class explainListenerClass implements ActionListener&#123; //事件监听器 public void actionPerformed(ActionEvent e)&#123; JOptionPane.showMessageDialog(null, "填入数字保证每行每列及每个小的九宫格内数字无重复","Explain",JOptionPane.INFORMATION_MESSAGE); &#125;&#125;class messageListenerClass implements ActionListener&#123; public void actionPerformed(ActionEvent e)&#123; JOptionPane.showMessageDialog(null, "made by wyx","Message",JOptionPane.INFORMATION_MESSAGE); &#125;&#125;]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【codeforces 749A】Bachgold Problem]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90codeforces-749A%E3%80%91Bachgold-Problem%2F</url>
    <content type="text"><![CDATA[Bachgold problem is very easy to formulate. Given a positive integer n represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than 1. Recall that integer k is called prime if it is greater than 1 and has exactly two positive integer divisors — 1 and k. InputThe only line of the input contains a single integer n (2 ≤ n ≤ 100 000). OutputThe first line of the output contains a single integer k — maximum possible number of primes in representation. The second line should contain k primes with their sum equal to n. You can print them in any order. If there are several optimal solution, print any of them. ExampleInput5Output22 3Input6Output32 2 2 解题思路一道简单的贪心，只需要输出2或3 #include #include #include #includeusing namespace std; int n;int main(){ int k; while(cin&gt;&gt;n) { k = n / 2; n = n - (k * 2); if(n == 1) { k–; cout&lt;&lt;k + 1&lt;&lt;endl; for(int i = 0; i &lt; k; i++) cout&lt;&lt;2&lt;&lt;” “; cout&lt;&lt;3&lt;&lt;endl; } else { cout&lt;&lt;k&lt;&lt;endl; for(int i = 0; i &lt; k - 1; i++) cout&lt;&lt;2&lt;&lt;” “; cout&lt;&lt;2&lt;&lt;endl; } } return 0;}]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【codeforces 747A】Display Size]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90codeforces-747A%E3%80%91Display-Size%2F</url>
    <content type="text"><![CDATA[A big company decided to launch a new series of rectangular displays, and decided that the display must have exactly n pixels. Your task is to determine the size of the rectangular display — the number of lines (rows) of pixels a and the number of columns of pixels b, so that: there are exactly n pixels on the display;the number of rows does not exceed the number of columns, it means a ≤ b;the difference b - a is as small as possible. InputThe first line contains the positive integer n (1 ≤ n ≤ 106) — the number of pixels display should have. OutputPrint two integers — the number of rows and columns on the display. ExampleInput8Output2 4Input64Output8 8Input5Output1 5Input999999Output999 1001NoteIn the first example the minimum possible difference equals 2, so on the display should be 2 rows of 4 pixels. In the second example the minimum possible difference equals 0, so on the display should be 8 rows of 8 pixels. In the third example the minimum possible difference equals 4, so on the display should be 1 row of 5 pixels. 解题思路贪心，开平方之后从大到小找第一个解，math函数库里的sqrt函数的参数不能放int不然会CE，重载调用的问题，可以强转 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; double m; while(cin&gt;&gt;m) &#123; int a, b; double y = sqrt(m); int x = (int)y; int n = int(m); if(n % x == 0) &#123; a = x; b = n / x; &#125; else &#123; while(n % x != 0) &#123; x--; &#125; a = x; b = n / x; &#125; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【codeforces 746A】Compote]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90codeforces-746A%E3%80%91Compote%2F</url>
    <content type="text"><![CDATA[Nikolay has a lemons, b apples and c pears. He decided to cook a compote. According to the recipe the fruits should be in the ratio 1: 2: 4. It means that for each lemon in the compote should be exactly 2 apples and exactly 4 pears. You can’t crumble up, break up or cut these fruits into pieces. These fruits — lemons, apples and pears — should be put in the compote as whole fruits. Your task is to determine the maximum total number of lemons, apples and pears from which Nikolay can cook the compote. It is possible that Nikolay can’t use any fruits, in this case print 0. InputThe first line contains the positive integer a (1 ≤ a ≤ 1000) — the number of lemons Nikolay has. The second line contains the positive integer b (1 ≤ b ≤ 1000) — the number of apples Nikolay has. The third line contains the positive integer c (1 ≤ c ≤ 1000) — the number of pears Nikolay has. OutputPrint the maximum total number of lemons, apples and pears from which Nikolay can cook the compote. ExampleInput257Output7Input4713Output21Input232Output0NoteIn the first example Nikolay can use 1 lemon, 2 apples and 4 pears, so the answer is 1 + 2 + 4 = 7. In the second example Nikolay can use 3 lemons, 6 apples and 12 pears, so the answer is 3 + 6 + 12 = 21. In the third example Nikolay don’t have enough pears to cook any compote, so the answer is 0. 解题思路分别用个数除以比例的值的最小的一个乘以比例的数字和 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std; int main()&#123; int a, b, c; int ans, flag; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c) &#123; int x, y, z; x = a; y = b / 2; z = c / 4; flag = min(x, min(y, z)); ans = flag * 7; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【 codeforces 749C 】 Voting]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90codeforces-749C%E3%80%91-Voting%2F</url>
    <content type="text"><![CDATA[There are n employees in Alternative Cake Manufacturing (ACM). They are now voting on some very important question and the leading world media are trying to predict the outcome of the vote. Each of the employees belongs to one of two fractions: depublicans or remocrats, and these two fractions have opposite opinions on what should be the outcome of the vote. The voting procedure is rather complicated: Each of n employees makes a statement. They make statements one by one starting from employees 1 and finishing with employee n. If at the moment when it’s time for the i-th employee to make a statement he no longer has the right to vote, he just skips his turn (and no longer takes part in this voting).When employee makes a statement, he can do nothing or declare that one of the other employees no longer has a right to vote. It’s allowed to deny from voting people who already made the statement or people who are only waiting to do so. If someone is denied from voting he no longer participates in the voting till the very end.When all employees are done with their statements, the procedure repeats: again, each employees starting from 1 and finishing with n who are still eligible to vote make their statements.The process repeats until there is only one employee eligible to vote remaining and he determines the outcome of the whole voting. Of course, he votes for the decision suitable for his fraction.You know the order employees are going to vote and that they behave optimal (and they also know the order and who belongs to which fraction). Predict the outcome of the vote. InputThe first line of the input contains a single integer n (1 ≤ n ≤ 200 000) — the number of employees. The next line contains n characters. The i-th character is ‘D’ if the i-th employee is from depublicans fraction or ‘R’ if he is from remocrats. OutputPrint ‘D’ if the outcome of the vote will be suitable for depublicans and ‘R’ if remocrats will win. ExampleInput5DDRRROutputDInput6DDRRRROutputRNoteConsider one of the voting scenarios for the first sample: Employee 1 denies employee 5 to vote.Employee 2 denies employee 3 to vote.Employee 3 has no right to vote and skips his turn (he was denied by employee 2).Employee 4 denies employee 2 to vote.Employee 5 has no right to vote and skips his turn (he was denied by employee 1).Employee 1 denies employee 4.Only employee 1 now has the right to vote so the voting ends with the victory of depublicans 解题思路通过放在两个队列里实现循环，每个队列按出现的先后顺序抵消，直至有一个队列为空，不为空的则获胜 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;int n;char ch[200005];queue&lt;int&gt; d, r;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;ch[i]; if(ch[i] == 'D') d.push(i); else r.push(i); &#125; while(!d.empty() &amp;&amp; !r.empty()) &#123; int a, b; a = d.front(); b = r.front(); d.pop(); r.pop(); if(a &lt; b) &#123; d.push(a + n); &#125; else r.push(b + n); &#125; if(d.empty()) cout&lt;&lt;"R"&lt;&lt;endl; else cout&lt;&lt;"D"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【codeforces 746B】 Decoding]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90codeforces-746B%E3%80%91-Decoding%2F</url>
    <content type="text"><![CDATA[Polycarp is mad about coding, that is why he writes Sveta encoded messages. He calls the median letter in a word the letter which is in the middle of the word. If the word’s length is even, the median letter is the left of the two middle letters. In the following examples, the median letter is highlighted: contest, info. If the word consists of single letter, then according to above definition this letter is the median letter. Polycarp encodes each word in the following way: he writes down the median letter of the word, then deletes it and repeats the process until there are no letters left. For example, he encodes the word volga as logva. You are given an encoding s of some word, your task is to decode it. InputThe first line contains a positive integer n (1 ≤ n ≤ 2000) — the length of the encoded word. The second line contains the string s of length n consisting of lowercase English letters — the encoding. OutputPrint the word that Polycarp encoded. ExampleInput5logvaOutputvolgaInput2noOutputnoInput4abbaOutputbabaNoteIn the first example Polycarp encoded the word volga. At first, he wrote down the letter l from the position 3, after that his word looked like voga. After that Polycarp wrote down the letter o from the position 2, his word became vga. Then Polycarp wrote down the letter g which was at the second position, the word became va. Then he wrote down the letter v, then the letter a. Thus, the encoding looked like logva. In the second example Polycarp encoded the word no. He wrote down the letter n, the word became o, and he wrote down the letter o. Thus, in this example, the word and its encoding are the same. In the third example Polycarp encoded the word baba. At first, he wrote down the letter a, which was at the position 2, after that the word looked like bba. Then he wrote down the letter b, which was at the position 2, his word looked like ba. After that he wrote down the letter b, which was at the position 1, the word looked like a, and he wrote down that letter a. Thus, the encoding is abba. 解题思路贪心，将新的字符串从后往前填入原字符串中，可知规律为后一前一 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std; int main()&#123; int n; while(cin&gt;&gt;n) &#123; char ch[2005]; cin&gt;&gt;ch; char rch[2005]; for(int i = 0; i &lt; 2005; i++) rch[i] = NULL; if(n % 2 != 0) &#123; rch[n / 2] = ch[0]; int sign = n - 1; for(int i = 0; i &lt; n / 2; i++) &#123; rch[n - i - 1] = ch[sign--]; rch[i] = ch[sign--]; &#125; &#125; else &#123; int sign = n - 1; for(int i = 0; i &lt; n / 2; i++) &#123; rch[n - i - 1] = ch[sign--]; rch[i] = ch[sign--]; &#125; &#125; for(int i = 0; i &lt; n; i++) cout&lt;&lt;rch[i]; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【codeforces 752C】Santa Claus and Robot]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90codeforces-752C%E3%80%91Santa-Claus-and-Robot%2F</url>
    <content type="text"><![CDATA[Santa Claus has Robot which lives on the infinite grid and can move along its lines. He can also, having a sequence of m points p1, p2, …, pm with integer coordinates, do the following: denote its initial location by p0. First, the robot will move from p0 to p1 along one of the shortest paths between them (please notice that since the robot moves only along the grid lines, there can be several shortest paths). Then, after it reaches p1, it’ll move to p2, again, choosing one of the shortest ways, then to p3, and so on, until he has visited all points in the given order. Some of the points in the sequence may coincide, in that case Robot will visit that point several times according to the sequence order. While Santa was away, someone gave a sequence of points to Robot. This sequence is now lost, but Robot saved the protocol of its unit movements. Please, find the minimum possible length of the sequence. InputThe first line of input contains the only positive integer n (1 ≤ n ≤ 2·105) which equals the number of unit segments the robot traveled. The second line contains the movements protocol, which consists of n letters, each being equal either L, or R, or U, or D. k-th letter stands for the direction which Robot traveled the k-th unit segment in: L means that it moved to the left, R — to the right, U — to the top and D — to the bottom. Have a look at the illustrations for better explanation. OutputThe only line of input should contain the minimum possible length of the sequence. ExampleInput4RURDOutput2Input6RRULDDOutput2Input26RRRULURURUULULLLDLDDRDRDLDOutput7Input3RLLOutput2Input4LRLROutput4NoteThe illustrations to the first three tests are given below. The last example illustrates that each point in the sequence should be counted as many times as it is presented in the sequence. 解题思路开始看到附图以为比较复杂就留在了后面做，最后看懂题目之后发现算是一道贪心，用数字表示方向，初始方向设0，可知，如果方向改变，就代表该方向上有一所求点，ans++即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;char str[200005];int n;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i = 0; i &lt; n; i++) cin&gt;&gt;str[i]; int a = 0, b = 0, ans = 1; for(int i = 0; i &lt; n; i++) &#123; if(str[i] == 'L') &#123; if(a == 2)&#123; b = 0; ans++; &#125; a = 1; &#125; else if(str[i] == 'R') &#123; if(a == 1)&#123; b = 0; ans++; &#125; a = 2; &#125; else if(str[i] == 'U') &#123; if(b == 2)&#123; a = 0; ans++; &#125; b = 1; &#125; else if(str[i] == 'D') &#123; if(b == 1) &#123; a = 0; ans++; &#125; b = 2; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【codeforces 747C】Servers]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90codeforces-747C%E3%80%91Servers%2F</url>
    <content type="text"><![CDATA[There are n servers in a laboratory, each of them can perform tasks. Each server has a unique id — integer from 1 to n. It is known that during the day q tasks will come, the i-th of them is characterized with three integers: ti — the moment in seconds in which the task will come, ki — the number of servers needed to perform it, and di — the time needed to perform this task in seconds. All ti are distinct. To perform the i-th task you need ki servers which are unoccupied in the second ti. After the servers begin to perform the task, each of them will be busy over the next di seconds. Thus, they will be busy in seconds ti, ti + 1, …, ti + di - 1. For performing the task, ki servers with the smallest ids will be chosen from all the unoccupied servers. If in the second ti there are not enough unoccupied servers, the task is ignored. Write the program that determines which tasks will be performed and which will be ignored. InputThe first line contains two positive integers n and q (1 ≤ n ≤ 100, 1 ≤ q ≤ 105) — the number of servers and the number of tasks. Next q lines contains three integers each, the i-th line contains integers ti, kiand di (1 ≤ ti ≤ 106, 1 ≤ ki ≤ n, 1 ≤ di ≤ 1000) — the moment in seconds in which the i-th task will come, the number of servers needed to perform it, and the time needed to perform this task in seconds. The tasks are given in a chronological order and they will come in distinct seconds. OutputPrint q lines. If the i-th task will be performed by the servers, print in the i-th line the sum of servers’ ids on which this task will be performed. Otherwise, print -1. ExampleInput4 31 3 22 2 13 4 3Output6-110Input3 23 2 35 1 2Output33Input8 61 3 204 2 16 5 510 1 115 3 621 8 8Output6930-11536NoteIn the first example in the second 1 the first task will come, it will be performed on the servers with ids 1, 2 and 3 (the sum of the ids equals 6) during two seconds. In the second 2 the second task will come, it will be ignored, because only the server 4 will be unoccupied at that second. In the second 3 the third task will come. By this time, servers with the ids 1, 2 and 3 will be unoccupied again, so the third task will be done on all the servers with the ids 1, 2, 3 and 4 (the sum of the ids is 10). In the second example in the second 3 the first task will come, it will be performed on the servers with ids 1 and 2 (the sum of the ids is 3) during three seconds. In the second 5 the second task will come, it will be performed on the server 3, because the first two servers will be busy performing the first task. 解题思路利用两个优先队列随时排序，最先完成工作队列和编号从小到大的队列，从队首选取最优选择 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std;int n, q;int t[100005], k[100005], d[100005];struct Node&#123; int t, id; bool operator &lt; (const Node &amp;a) const&#123; return a.t &lt; t; &#125;&#125;;Node node;int main()&#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; ID; priority_queue&lt;Node&gt; T; while(cin&gt;&gt;n&gt;&gt;q) &#123; while(!ID.empty()) ID.pop(); while(!T.empty()) T.pop(); for(int i = 0; i &lt; q; i++) &#123; cin&gt;&gt;t[i]&gt;&gt;k[i]&gt;&gt;d[i]; &#125; for(int i = 1; i &lt;= n; i++) ID.push(i); for(int i = 0; i &lt; q; i++) &#123; while(!T.empty()) &#123; node = T.top(); if(node.t &gt; t[i]) break; T.pop(); ID.push(node.id); &#125; if(ID.size() &lt; k[i]) cout&lt;&lt;-1&lt;&lt;endl; else &#123; int ans = 0; for(int j = 0; j &lt; k[i]; j++) &#123; node.id = ID.top(); ID.pop(); node.t = t[i] + d[i]; ans += node.id; T.push(node); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【codeforces 749B】 Parallelogram is Back]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90codeforces-749B%E3%80%91-Parallelogram-is-Back%2F</url>
    <content type="text"><![CDATA[Long time ago Alex created an interesting problem about parallelogram. The input data for this problem contained four integer points on the Cartesian plane, that defined the set of vertices of some non-degenerate (positive area) parallelogram. Points not necessary were given in the order of clockwise or counterclockwise traversal. Alex had very nice test for this problem, but is somehow happened that the last line of the input was lost and now he has only three out of four points of the original parallelogram. He remembers that test was so good that he asks you to restore it given only these three points. InputThe input consists of three lines, each containing a pair of integer coordinates xiand yi ( - 1000 ≤ xi, yi ≤ 1000). It’s guaranteed that these three points do not lie on the same line and no two of them coincide. OutputFirst print integer k — the number of ways to add one new integer point such that the obtained set defines some parallelogram of positive area. There is no requirement for the points to be arranged in any special order (like traversal), they just define the set of vertices. Then print k lines, each containing a pair of integer — possible coordinates of the fourth point. ExampleInput0 01 00 1Output31 -1-1 11 1NoteIf you need clarification of what parallelogram is, please check Wikipedia page: https://en.wikipedia.org/wiki/Parallelogram 解题思路已知平行四边形的三个顶点求最后一个，根据数学公式求解 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std; int main()&#123; int a[3][2]; while(cin&gt;&gt;a[0][0]&gt;&gt;a[0][1] &amp;&amp; cin&gt;&gt;a[1][0]&gt;&gt;a[1][1] &amp;&amp; cin&gt;&gt;a[2][0]&gt;&gt;a[2][1]) &#123; int k = 3; int b[3][2]; b[0][0] = a[0][0] + a[1][0] - a[2][0]; b[0][1] = a[0][1] + a[1][1] - a[2][1]; b[1][0] = a[0][0] + a[2][0] - a[1][0]; b[1][1] = a[0][1] + a[2][1] - a[1][1]; b[2][0] = a[1][0] + a[2][0] - a[0][0]; b[2][1] = a[1][1] + a[2][1] - a[0][1]; cout&lt;&lt;k&lt;&lt;endl; for(int i = 0; i &lt; 3; i++) &#123; cout&lt;&lt;b[i][0]&lt;&lt;" "&lt;&lt;b[i][1]&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【codeforces 747B】Mammoth's Genome Decoding]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90codeforces-747B%E3%80%91Mammoth-s-Genome-Decoding%2F</url>
    <content type="text"><![CDATA[The process of mammoth’s genome decoding in Berland comes to its end! One of the few remaining tasks is to restore unrecognized nucleotides in a found chain s. Each nucleotide is coded with a capital letter of English alphabet: ‘A’, ‘C’, ‘G’ or ‘T’. Unrecognized nucleotides are coded by a question mark ‘?’. Thus, sis a string consisting of letters ‘A’, ‘C’, ‘G’, ‘T’ and characters ‘?’. It is known that the number of nucleotides of each of the four types in the decoded genome of mammoth in Berland should be equal. Your task is to decode the genome and replace each unrecognized nucleotide with one of the four types so that the number of nucleotides of each of the four types becomes equal. InputThe first line contains the integer n (4 ≤ n ≤ 255) — the length of the genome. The second line contains the string s of length n — the coded genome. It consists of characters ‘A’, ‘C’, ‘G’, ‘T’ and ‘?’. OutputIf it is possible to decode the genome, print it. If there are multiple answer, print any of them. If it is not possible, print three equals signs in a row: “===” (without quotes). ExampleInput8AG?C??CTOutputAGACGTCTInput4AGCTOutputAGCTInput6????G? OutputInput4AA?? OutputNoteIn the first example you can replace the first question mark with the letter ‘A’, the second question mark with the letter ‘G’, the third question mark with the letter ‘T’, then each nucleotide in the genome would be presented twice. In the second example the genome is already decoded correctly and each nucleotide is exactly once in it. In the third and the fourth examples it is impossible to decode the genom. 解题思路先将各个字符的个数统计，之后遍历字符串，若是‘?’,则选取个数未到n/4的字符填入，若最后？个数大于0或其他字符大于n/4，则输出“===”否则顺序输出字符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std; int n;char ch[300];int main()&#123; while(cin&gt;&gt;n) &#123; int a[5] = &#123;0, 0, 0, 0, 0&#125;; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;ch[i]; if(ch[i] == 'A') a[0]++; else if(ch[i] == 'G') a[1]++; else if(ch[i] == 'C') a[2]++; else if(ch[i] == 'T') a[3]++; else a[4]++; &#125; int maxNum = n / 4; for(int i = 0; i &lt; n; i++) &#123; if(ch[i] == '?') &#123; for(int j = 0; j &lt; 4; j++) &#123; if(a[j] &lt; maxNum) &#123; if(j == 0) ch[i] = 'A', a[0]++; else if(j == 1) ch[i] = 'G', a[1]++; else if(j == 2) ch[i] = 'C', a[2]++; else if(j == 3) ch[i] = 'T', a[3]++; a[4]--; break; &#125; &#125; &#125; &#125; if(a[4] &gt; 0 || a[0] &gt; n / 4 || a[1] &gt; n / 4 || a[2] &gt; n / 4 || a[3] &gt; n / 4) cout&lt;&lt;"==="&lt;&lt;endl; else &#123; for(int i = 0; i &lt; n; i++) cout&lt;&lt;ch[i]; cout&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51Nod X^2 Mod P]]></title>
    <url>%2F2018%2F11%2F11%2F51Nod-X-2-Mod-P%2F</url>
    <content type="text"><![CDATA[X*X mod P = A，其中P为质数。给出P和A，求&lt;=P的所有X。 Input两个数P A，中间用空格隔开。(1 &lt;= A &lt; P &lt;= 1000000, P为质数)Output输出符合条件的X，且0 &lt;= X &lt;= P，如果有多个，按照升序排列，中间用空格隔开。如果没有符合条件的X，输出：No Solution Sample Input13 3Sample Output4 9 解题思路数据较大会爆int，将变量设为long long即可 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;long long p, a;long long x[1000005];int main()&#123; while(cin&gt;&gt;p&gt;&gt;a) &#123; long long index = 0; for(long long i = 0; i &lt;= p; i++) &#123; if((i * i) % p == a) &#123; x[index++] = i; &#125; &#125; if(index == 0) cout&lt;&lt;"No Solution"&lt;&lt;endl; else &#123; for(long long i = 0; i &lt;index - 1; i++) cout&lt;&lt;x[i]&lt;&lt;" "; cout&lt;&lt;x[index - 1]&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>51Nod</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Light oj 1132 Summing up Powers （矩阵快速幂）]]></title>
    <url>%2F2018%2F11%2F11%2FLight-oj-1132-Summing-up-Powers-%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Given N and K, you have to find (1K + 2K + 3K + … + NK) % 232 InputInput starts with an integer T (≤ 200), denoting the number of test cases. Each case contains two integers N (1 ≤ N ≤ 1015) and K (0 ≤ K ≤ 50) in a single line. OutputFor each case, print the case number and the result. Sample Input3 3 1 4 2 3 3 Sample OutputCase 1: 6 Case 2: 30 Case 3: 36 解题思路 图源：https://blog.csdn.net/shiyuankongbu/article/details/8988881 解题思路矩阵快速幂，D^(x - 1) * f(1) = f(x) C(m,n)用杨辉三角的对应关系求得较为简单易得 D * f(x) = f(x + 1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;cmath&gt;using namespace std;#define ll long longconst ll mod = ((ll) 1 &lt;&lt; 32);struct jz&#123; ll m[55][55];&#125;f, d;ll N, K;ll C[55][55];void yh() //利用杨辉三角值求C(m,n)&#123; for(int i = 0; i &lt;= 50; i++) &#123; C[i][0] = 1; C[i][i] = 1; C[i][1] = i; &#125; for(int i = 2; i &lt;= 50; i++) &#123; for(int j = 1; j &lt;= i; j++) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; &#125;&#125;jz mul(jz A, jz B)//A*B&#123; jz c; for(int i = 1; i &lt;= K + 2; i++) &#123; for(int k = 1; k &lt;= K + 2; k++) &#123; c.m[i][k] = 0; for(int j = 1; j &lt;= K + 2; j++) c.m[i][k] = (c.m[i][k] + A.m[i][j] * B.m[j][k]) % mod; &#125; &#125; return c;&#125;jz pow_(jz A, ll n) //A^n&#123; jz ans = f; while(n) &#123; if(n &amp; 1) &#123; n--; ans = mul(ans, A); &#125; else &#123; n /= 2; A = mul(A, A); &#125; &#125; return ans;&#125;void D()&#123; for(int i = 1; i &lt;= K + 2; i++) &#123; for(int j = 1; j &lt;= K + 2; j++) &#123; d.m[i][j] = 0; &#125; &#125; d.m[1][1] = 1; for(int i = 2; i &lt;= K + 2; i++) d.m[1][i] = C[K][i - 2]; for(int i = 2; i &lt;= K + 2; i++) &#123; for(int j = i; j &lt;= K + 2; j++) &#123; d.m[i][j] = C[K - i + 2][j - i]; &#125; &#125; &#125;void F() //f(1)&#123; for(int i = 1; i &lt;= K + 2; i++) &#123; f.m[i][1] = 1; &#125;&#125;int main()&#123; int T; cin&gt;&gt;T; yh(); for(int j = 1; j &lt;= T; j++) &#123; cin&gt;&gt;N&gt;&gt;K; F(); D(); jz flag = pow_(d, N - 1); jz ans = mul(flag, f); printf("Case %d: %lld\n", j, ans.m[1][1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Light oj</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51Nod 1116 K进制下的大数]]></title>
    <url>%2F2018%2F11%2F11%2F51Nod-1116-K%E8%BF%9B%E5%88%B6%E4%B8%8B%E7%9A%84%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有一个字符串S，记录了一个大数，但不知这个大数是多少进制的，只知道这个数在K进制下是K - 1的倍数。现在由你来求出这个最小的进制K。例如：给出的数是A1A，有A则最少也是11进制，然后发现A1A在22进制下等于4872,4872 mod 21 = 0，并且22是最小的，因此输出k = 22(大数的表示中A对应10，Z对应35)。 Input输入大数对应的字符串S。S的长度小于10^5。Output输出对应的进制K，如果在2 - 36范围内没有找到对应的解，则输出No Solution。 Sample InputA1ASample Output22 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;char ch[100005];int exchange(char a)&#123; if(a == '0') return 0; else if(a == '1') return 1; else if(a == '2') return 2; else if(a == '3') return 3; else if(a == '4') return 4; else if(a == '5') return 5; else if(a == '6') return 6; else if(a == '7') return 7; else if(a == '8') return 8; else if(a == '9') return 9; else &#123; return (a - 'A' + 10); &#125;&#125;int pow_(int a, int b)&#123; int c = 1; for(int i = 1; i &lt;= b; i++) c *= a; return c;&#125;int main()&#123; while(cin&gt;&gt;ch) &#123; int k, sign = 2; long long number = 0; for(int i = 0; i &lt; strlen(ch); i++) &#123; sign = max(sign, exchange(ch[i])); &#125; if(sign == 0 || sign == 1) cout&lt;&lt;"No Solution"&lt;&lt;endl; int i; for(i = sign + 1; i &lt;= 36; i++) &#123; number = 0; for(int j = 0; j &lt; strlen(ch); j++) &#123; number += exchange(ch[j]); &#125; if(number % (i - 1) == 0) &#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; if(i &gt; 36) cout&lt;&lt;"No Solution"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>51Nod</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3104 Drying]]></title>
    <url>%2F2018%2F11%2F11%2FPOJ-3104-Drying%2F</url>
    <content type="text"><![CDATA[It is very hard to wash and especially to dry clothes in winter. But Jane is a very smart girl. She is not afraid of this boring process. Jane has decided to use a radiator to make drying faster. But the radiator is small, so it can hold only one thing at a time. Jane wants to perform drying in the minimal possible time. She asked you to write a program that will calculate the minimal time for a given set of clothes. There are n clothes Jane has just washed. Each of them took ai water during washing. Every minute the amount of water contained in each thing decreases by one (of course, only if the thing is not completely dry yet). When amount of water contained becomes zero the cloth becomes dry and is ready to be packed. Every minute Jane can select one thing to dry on the radiator. The radiator is very hot, so the amount of water in this thing decreases by k this minute (but not less than zero — if the thing contains less than k water, the resulting amount of water will be zero). The task is to minimize the total time of drying by means of using the radiator effectively. The drying process ends when all the clothes are dry. InputThe first line contains a single integer n (1 ≤ n ≤ 100 000). The second line contains ai separated by spaces (1 ≤ ai ≤ 109). The third line contains k (1 ≤ k≤ 109). OutputOutput a single integer — the minimal possible number of minutes required to dry all clothes. Sample Inputsample input #132 3 95 sample input #232 3 65Sample Outputsample output #13 sample output #22 解题思路二分，相当于每秒所有的衣服都烘干1，烘干机烘干k-1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;cmath&gt;using namespace std;int n;long long a[100005];long long k;int check(long long m)&#123; long long x = 0; for(int i = 0; i &lt;n; i++) &#123; if(a[i] &gt; m) &#123; x += (a[i] - m) / (k - 1); if((a[i] - m) % (k - 1) != 0) x++; &#125; if(x &gt; m) return 0; &#125; return 1;&#125;int main()&#123; while(scanf("%lld", &amp;n) != EOF) &#123; long long ans = 0; long long max_ = -1; for(int i = 0; i &lt; n; i++) &#123; scanf("%lld", &amp;a[i]); if(max_ &lt; a[i]) max_ = a[i]; &#125; scanf("%lld", &amp;k); if(k == 1) ans = max_; else &#123; long long left = 1, right = max_, mid; while(left &lt;= right) &#123; mid = (left + right) &gt;&gt; 1; if(check(mid) == 1) &#123; ans = mid; right = mid - 1; &#125; else left = mid + 1; &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>POJ</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1655 Balancing Act]]></title>
    <url>%2F2018%2F11%2F11%2FPOJ-1655-Balancing-Act%2F</url>
    <content type="text"><![CDATA[Consider a tree T with N (1 &lt;= N &lt;= 20,000) nodes numbered 1…N. Deleting any node from the tree yields a forest: a collection of one or more trees. Define the balance of a node to be the size of the largest tree in the forest T created by deleting that node from T.For example, consider the tree: Deleting node 4 yields two trees whose member nodes are {5} and {1,2,3,6,7}. The larger of these two trees has five nodes, thus the balance of node 4 is five. Deleting node 1 yields a forest of three trees of equal size: {2,6}, {3,7}, and {4,5}. Each of these trees has two nodes, so the balance of node 1 is two. For each input tree, calculate the node that has the minimum balance. If multiple nodes have equal balance, output the one with the lowest number. InputThe first line of input contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. The first line of each test case contains an integer N (1 &lt;= N &lt;= 20,000), the number of congruence. The next N-1 lines each contains two space-separated node numbers that are the endpoints of an edge in the tree. No edge will be listed twice, and all edges will be listed.OutputFor each test case, print a line containing two integers, the number of the node with minimum balance and the balance of that node.Sample Input172 61 21 44 53 73 1Sample Output1 2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stdio.h&gt;#include&lt;cmath&gt;using namespace std;vector&lt;int&gt; a[40005];int N, T;int sizex[40005], sizey[40005], ans;void dp(int m, int n)&#123; sizex[m] = 1; for(int i = 0; i &lt; a[m].size(); i++) &#123; int y = a[m][i]; if(y == n) continue; dp(y, m); sizex[m] += sizex[y]; sizey[m] = max(sizey[m], sizex[y]); &#125; sizey[m] = max(sizey[m], N - sizex[m]); if(sizey[m] &lt; sizey[ans]) ans = m; if(sizey[m] == sizey[ans]) ans = min(ans, m);&#125;int main()&#123; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;N); ans = 0; sizey[0] = 0x7fffffff; for(int i = 1; i &lt; N; i++) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); a[y].push_back(x); a[x].push_back(y); &#125; dp(1, 0); cout&lt;&lt;ans&lt;&lt;" "&lt;&lt;sizey[ans]&lt;&lt;endl; for(int i = 1; i &lt;= N; i++) a[i].clear(); memset(sizex, 0, sizeof(sizex)); memset(sizey, 0, sizeof(sizey)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>POJ</tag>
        <tag>树形 dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CodeForces 792E】Colored Balls]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90CodeForces-792E%E3%80%91Colored-Balls%2F</url>
    <content type="text"><![CDATA[There are n boxes with colored balls on the table. Colors are numbered from 1 to n. i-th box contains ai balls, all of which have color i. You have to write a program that will divide all balls into sets such that: each ball belongs to exactly one of the sets,there are no empty sets,there is no set containing two (or more) balls of different colors (each set contains only balls of one color),there are no two sets such that the difference between their sizes is greater than 1.Print the minimum possible number of sets. InputThe first line contains one integer number n (1 ≤ n ≤ 500). The second line contains n integer numbers a1, a2, … , an (1 ≤ ai ≤ 109). OutputPrint one integer number — the minimum possible number of sets. ExampleInput34 7 8Output5Input22 7Output4NoteIn the first example the balls can be divided into sets like that: one set with 4balls of the first color, two sets with 3 and 4 balls, respectively, of the second color, and two sets with 4 balls of the third color. 解题思路每堆放置的球数应该为最小堆球数到1之间选取，规律： q + p &gt;= x + 1（x为堆数，q为a[i]/x, q为a[i]%x）时可以放置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;int n;ll a[505];ll check(int x)&#123; ll sum = 0; for(int i = 0; i &lt; n; i++) &#123; int q = a[i] / x; int p = a[i] % x; if(p == 0 || q + p &gt;= x - 1) &#123; sum += q; if(p != 0) sum++; &#125; else return 0; &#125; return sum;&#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a, a + n); ll ans; for(int i = 1; i &lt;= a[0]; i++) &#123; ans = check(a[0] / i + 1); if(ans != 0) break; ans = check(a[0] / i); if(ans != 0) break; ans = check(a[0] / i - 1); if(ans != 0) break; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 1869】六度分离]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1869%E3%80%91%E5%85%AD%E5%BA%A6%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[1967年，美国著名的社会学家斯坦利·米尔格兰姆提出了一个名为“小世界现象(small world phenomenon)”的著名假说，大意是说，任何2个素不相识的人中间最多只隔着6个人，即只用6个人就可以将他们联系在一起，因此他的理论也被称为“六度分离”理论(six degrees of separation)。虽然米尔格兰姆的理论屡屡应验，一直也有很多社会学家对其兴趣浓厚，但是在30多年的时间里，它从来就没有得到过严谨的证明，只是一种带有传奇色彩的假说而已。 Lele对这个理论相当有兴趣，于是，他在HDU里对N个人展开了调查。他已经得到了他们之间的相识关系，现在就请你帮他验证一下“六度分离”是否成立吧。 Input本题目包含多组测试，请处理到文件结束。对于每组测试，第一行包含两个整数N,M(0&lt;N&lt;100,0&lt;M&lt;200),分别代表HDU里的人数（这些人分别编成0~N-1号)，以及他们之间的关系。接下来有M行，每行两个整数A,B(0&lt;=A,B&lt;N)表示HDU里编号为A和编号B的人互相认识。除了这M组关系，其他任意两人之间均不相识。Output对于每组测试，如果数据符合“六度分离”理论就在一行里输出”Yes”，否则输出”No”。 Sample Input8 70 11 22 33 44 55 66 78 80 11 22 33 44 55 66 77 0Sample OutputYesYes 解题思路利用一个数组flag数组保存从一个人到另一个所需的最短路径，最后判断，如果大于7（flag初始为1），break，输出弄No，如果循环结束而未break，则输出Yes 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;using namespace std;int N, M, flag[102][102];int main()&#123; int a, b; while(scanf("%d%d", &amp;N, &amp;M) != EOF) &#123; memset(flag, 999999, sizeof(flag)); for(int i = 0; i &lt; M; i++) &#123; scanf("%d%d", &amp;a, &amp;b); flag[a][b] = flag[b][a] = 1; &#125; for(int x = 0; x &lt; N; x++) &#123; for(int i = 0; i &lt; N; i++) &#123; for(int j = 0; j &lt; N; j++) &#123; if(flag[i][x] + flag[x][j] &lt; flag[i][j]) &#123; flag[i][j] = flag[i][x] + flag[x][j]; &#125; &#125; &#125; &#125; int sign = 1; for(int i = 0; i &lt; N; i++) &#123; for(int j = 0; j &lt; N; j++) &#123; if(flag[i][j] &gt; 7) &#123; //cout&lt;&lt;"No"&lt;&lt;endl; printf("No\n"); sign = 0; break; &#125; &#125; if(sign == 0) break; &#125; if(sign == 1) //cout&lt;&lt;"Yes"&lt;&lt;endl; printf("Yes\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 5441】Travel]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-5441%E3%80%91Travel%2F</url>
    <content type="text"><![CDATA[Jack likes to travel around the world, but he doesn’t like to wait. Now, he is traveling in the Undirected Kingdom. There are cities and bidirectional roads connecting the cities. Jack hates waiting too long on the bus, but he can rest at every city. Jack can only stand staying on the bus for a limited time and will go berserk after that. Assuming you know the time it takes to go from one city to another and that the time Jack can stand staying on a bus is minutes, how many pairs of city are there that Jack can travel from city to without going berserk? InputThe first line contains one integer , which represents the number of test case. For each test case, the first line consists of three integers and where . The Undirected Kingdom has cities and bidirectional roads, and there are queries. Each of the following lines consists of three integers and where and . It takes Jack minutes to travel from city to city and vice versa. Then lines follow. Each of them is a query consisting of an integer where is the time limit before Jack goes berserk. OutputYou should print lines for each test case. Each of them contains one integer as the number of pair of cities which Jack may travel from to within the time limit . Note that and are counted as different pairs and and must be different cities. Sample Input15 5 32 3 63341 5 157243 5 57054 3 123821 3 2172660001000013000Sample Output2612 解题思路离线并查集，每走过一个城市，若其并未在并查集中，便将其代表的点加入并查集，对于（u， v） 如果u和v没有连通，假设u所在连通分量的点个数是n1,v所在的连通分量的点个数是n2 对于第一个连通分量，合并后这个连通分量就不存在了，ans会减少n1*(n1-1)对点 对于第二个连通分量，合并后这个连通分量就不存在了，ans会减少n2*(n2-1)对点 合并后，多了一个合并的连通分量，ans会增加(n1+n2)*(n1+n2-1)对点 之后根据权值大小更新答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;struct N1&#123; int u, v, c; bool operator&lt; (const N1 b) const&#123; return c &lt; b.c; &#125;&#125;n1[100005];struct N2&#123; int x, id; bool operator&lt; (const N2 b) const&#123; return x &lt; b.x; &#125;&#125;n2[100005];int n, m, q, par[100005], rank_[100005];ll ans[100005];int find_(int x)&#123; if(x == par[x]) return x; else return par[x] = find_(par[x]);&#125;inline void init()&#123; for(int i = 1; i &lt;= n; i++) &#123; par[i] = i; rank_[i] = 1; &#125;&#125;int main()&#123; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); init(); for(int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;n1[i].u, &amp;n1[i].v, &amp;n1[i].c); &#125; for(int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;n2[i].x); n2[i].id = i; &#125; sort(n1 + 1, n1 + 1 + m); sort(n2 + 1, n2 + 1 + q); ll s = 0; int i = 1; for(int in = 1; in &lt;= q; in++) &#123; while(i &lt;= m &amp;&amp; n1[i].c &lt;= n2[in].x) &#123; int f1 = find_(n1[i].u); int f2 = find_(n1[i].v); if(f1 != f2) &#123; s = s - rank_[f1] * (rank_[f1] - 1) - rank_[f2] * (rank_[f2] - 1) + (rank_[f1] + rank_[f2]) * (rank_[f1] + rank_[f2] - 1); par[f1] = f2; rank_[f2] += rank_[f1]; &#125; i++; &#125; ans[n2[in].id] = s; &#125; for(int i = 1; i &lt;= q; i++) cout&lt;&lt;ans[i]&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
        <tag>HDU</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 5573】Binary Tree]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-5573%E3%80%91Binary-Tree%2F</url>
    <content type="text"><![CDATA[The Old Frog King lives on the root of an infinite tree. According to the law, each node should connect to exactly two nodes on the next level, forming a full binary tree. Since the king is professional in math, he sets a number to each node. Specifically, the root of the tree, where the King lives, is . Say . And for each node , labels as , the left child is and right child is . The king looks at his tree kingdom, and feels satisfied. Time flies, and the frog king gets sick. According to the old dark magic, there is a way for the king to live for another years, only if he could collect exactly soul gems. Initially the king has zero soul gems, and he is now at the root. He will walk down, choosing left or right child to continue. Each time at node , the number at the node is (remember ), he can choose to increase his number of soul gem by , or decrease it by . He will walk from the root, visit exactly nodes (including the root), and do the increasement or decreasement as told. If at last the number is , then he will succeed. Noting as the soul gem is some kind of magic, the number of soul gems the king has could be negative. Given , help the King find a way to collect exactly soul gems by visiting exactly nodes.InputFirst line contains an integer , which indicates the number of test cases. Every test case contains two integers and , which indicates soul gems the frog king want to collect and number of nodes he can visit. OutputFor every test case, you should output “ Case #x:” first, where indicates the case number and counts from . Then lines follows, each line is formated as ‘a b’, where is node label of the node the frog visited, and is either ‘+’ or ‘-‘ which means he increases / decreases his number by . It’s guaranteed that there are at least one solution and if there are more than one solutions, you can output any of them. Sample Input25 310 4Sample OutputCase #1:1 +3 -7 +Case #2:1 +3 +6 -12 + 解题思路1， 2， 4， 2^k可以构造出所有小于2^（k + 1）的数， 本来想构造二叉树来解题，树都建好了，大佬忽然告诉我这道题不需要建树，再看一下数据，太大，哪怕剪枝都要超时，百度了一下发现是二进制的构造问题 求出sum后，根据sum - n来确定最后一个数取2^k或2^k + 1,最后根据x的二进制判断正负号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;stdio.h&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;ll N, ans;int K, sum, x;int main()&#123; int T, k = 1; scanf("%d", &amp;T); while(T--) &#123; scanf("%I64d %d", &amp;N, &amp;K); cout&lt;&lt;"Case #"&lt;&lt;k++&lt;&lt;": "&lt;&lt;endl; if(N &amp; 1) &#123; sum = (1 &lt;&lt; K) - 1; //(2 ^ K) - 1 x = (sum - N) / 2; for(int i = 0; i &lt; K; i++) &#123; cout&lt;&lt;(1 &lt;&lt; i)&lt;&lt;" "; if(x &amp; 1) cout&lt;&lt;"-"&lt;&lt;endl; else cout&lt;&lt;"+"&lt;&lt;endl; x &gt;&gt;= 1; &#125; &#125; else &#123; sum = (1 &lt;&lt; K); x = (sum - N) / 2; for(int i = 0; i &lt; K - 1; i++) &#123; cout&lt;&lt;(1 &lt;&lt; i)&lt;&lt;" "; if(x &amp; 1) cout&lt;&lt;"-"&lt;&lt;endl; else cout&lt;&lt;"+"&lt;&lt;endl; x &gt;&gt;= 1; &#125; cout&lt;&lt;(1 &lt;&lt; K - 1) + 1&lt;&lt;" "; if(x &amp; 1) cout&lt;&lt;"-"&lt;&lt;endl; else cout&lt;&lt;"+"&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ 3723】Conscription]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90POJ-3723%E3%80%91Conscription%2F</url>
    <content type="text"><![CDATA[Windy has a country, and he wants to build an army to protect his country. He has picked up N girls and M boys and wants to collect them to be his soldiers. To collect a soldier without any privilege, he must pay 10000 RMB. There are some relationships between girls and boys and Windy can use these relationships to reduce his cost. If girl x and boy y have a relationship d and one of them has been collected, Windy can collect the other one with 10000-d RMB. Now given all the relationships between girls and boys, your assignment is to find the least amount of money Windy has to pay. Notice that only one relationship can be used when collecting one soldier. InputThe first line of input is the number of test case.The first line of each test case contains three integers, N, M and R.Then R lines followed, each contains three integers xi, yi and di.There is a blank line before each test case. 1 ≤ N, M ≤ 100000 ≤ R ≤ 50,0000 ≤ xi &lt; N0 ≤ yi &lt; M0 &lt; di &lt; 10000 OutputFor each test case output the answer in a single line.Sample Input2 5 5 84 3 68311 3 45830 0 65920 1 30633 3 49751 3 20494 2 21042 2 781 5 5 102 4 98203 2 62363 1 88642 4 83262 0 51562 0 14634 1 24390 4 43733 4 88892 4 3133Sample Output7107154223 解题思路把人看做顶点，关系看做边，转化为求解无向图中的最大权森林问题。最大权森林问题可以通过把所有边权取反之后用最小生成树的算法求解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;stdio.h&gt;#include&lt;vector&gt;using namespace std;struct Node&#123; int x, y, d;&#125;node[50002];int N, M, R, D;bool cmp(Node a, Node b)&#123; return a.d &lt; b.d;&#125;int par[50002], rank[50002];void init(int n)&#123; for(int i = 0; i &lt;= n; i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;int find(int x)&#123; if(par[x] == x) return x; else return par[x] = find(par[x]);&#125;void unite(int x, int y)&#123; x = find(x); y = find(y); if(x == y) return ; if(rank[x] &lt; rank[y]) par[x] = y; else &#123; par[y] = x; if(rank[x] == rank[y]) rank[x]++; &#125;&#125;bool same(int x, int y)&#123; return find(x) == find(y);&#125;int kruskal()&#123; sort(node, node + R, cmp); init(D); int ans = 0; for(int i = 0; i &lt; R; i++) &#123; Node n = node[i]; if(!same(n.x, n.y)) &#123; unite(n.x, n.y); ans += n.d; &#125; &#125; return ans;&#125;int main()&#123; int t; scanf("%d", &amp;t); int x, y, d; while(t--) &#123; scanf("%d%d%d", &amp;N, &amp;M, &amp;R); D = M + N; for(int i = 0; i &lt; R; i++) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;d); node[i].x = x; node[i].y = N + y; node[i].d = -d; &#125; cout&lt;&lt;10000 * (N + M) + kruskal()&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>POJ</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCU 4520】Euler]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90SCU-4520%E3%80%91Euler%2F</url>
    <content type="text"><![CDATA[给出一幅n个点，m条边的图，分别判断该图是无向图和有向图条件下，是否存在欧拉通路。 输入输入包含多组数据。第一行为一个整数T(1 ≤ T ≤ 100)，代表数据组数，对于每组数据： 第一行是两个整数n和m( 1 ≤ n ≤ 500, 0 ≤ m ≤ n(n − 1)/2 )，分别代表图上点的个数和边的个数。然后是m行，每行两个整数ui和vi ( 1 ≤ ui, vi ≤ n, ui ≠ vi )，代表图上的一条边所连接的两个点。输入保证没有重边。 输出首先判断：如果这幅图是无向图，是否存在欧拉通路；其次判断：如果这幅图是有向图，是否存在欧拉通路。对于每个判断，如果存在，输出”Yes”，否则输出”No”（不包括引号）。两个判断间用空格隔开。 样例输入3 2 11 2 4 31 21 31 4 4 41 21 31 42 3 样例输出Yes YesNo NoYes No Hint欧拉通路、欧拉回路、欧拉图无向图：1) 设 G 是连通无向图，则称经过 G 的每条边一次并且仅一次的路径为欧拉通路；2) 如果欧拉通路是回路 （起点和终点是同一个顶点）， 则称此回路为欧拉回路 （Euler circuit）；3) 具有欧拉回路的无向图 G 称为欧拉图（Euler graph）。有向图：1) 设 D 是有向图， D 的基图连通，则称经过 D 的每条边一次并且仅一次的有向路径为有向欧拉通路；2) 如果有向欧拉通路是有向回路，则称此有向回路为有向欧拉回路（directed Euler circuit）；3) 具有有向欧拉回路的有向图 D 称为有向欧拉图（directed Euler graph）。 Extend欧拉回路打印路径算法：Fleury(佛罗莱)算法 AuthorGooZy 解题思路根据度和是否是同一根节点来判断，具体度的判断参照“欧拉图浅析及模板” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 505;int m, n;int idu[MX], odu[MX], DU[MX];int par[MX];void init()&#123; for(int i = 1; i &lt;= n; i++) par[i] = i;&#125;int Find(int x)&#123; return par[x] == x ? x : par[x] = Find(par[x]);&#125;int main()&#123; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;n, &amp;m); memset(idu, 0, sizeof(idu)); memset(odu, 0, sizeof(odu)); memset(DU, 0, sizeof(DU)); init(); for(int i = 0; i &lt; m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); DU[u]++; DU[v]++; odu[u]++; idu[v]++; int x = Find(u), y = Find(v); if(x != y)&#123; par[x] = y; &#125; &#125; int cnt = 0; for(int i = 1; i&lt;= n; i++)&#123; if(par[i] == i) cnt++; &#125; if(cnt &gt; 1) &#123; cout&lt;&lt;"No No"&lt;&lt;endl; continue; &#125; int flag = 1, res = 0; for(int i = 1; i&lt;= n; i++) &#123; if(DU[i] % 2 == 1) &#123; res++; &#125; &#125; if(res != 0 &amp;&amp; res != 2) flag = 0; if(flag) cout&lt;&lt;"Yes "; else cout&lt;&lt;"No "; flag = 1; int mi = 0, mx = 0; for(int i = 1; i &lt;= n; i++) &#123; if(idu[i] != odu[i]) &#123; if(idu[i] == odu[i] - 1 &amp;&amp; mi == 0) &#123; mi = 1; &#125; else if(idu[i] == odu[i] + 1 &amp;&amp; mx == 0) &#123; mx = 1; &#125; else &#123; flag = 0; &#125; &#125; &#125; if(flag) cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
        <tag>图论</tag>
        <tag>SCU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 1878】欧拉回路]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1878%E3%80%91%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个图，问是否存在欧拉回路？ Input测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是节点数N ( 1 &lt; N &lt; 1000 )和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。当N为0时输入结束。Output每个测试用例的输出占一行，若欧拉回路存在则输出1，否则输出0。Sample Input3 31 21 32 33 21 22 30Sample Output10 解题思路本来使用模板写了这道题，但总是迷之wa，然后大佬指点说可以用并查集简单的求解，确实是一个很好的操作，（虽然我到现在都不知道之前写的为什么wa） 合并集合时不需要判断根的高度。最后判断时，若存在度为奇数或根节点不同，则不是欧拉回路 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;list&gt;using namespace std;const int MX = 1005;int n, m,Du[MX];int par[MX], ra[MX];void Init()&#123; for(int i = 1; i &lt;= n; i++) &#123; par[i] = i; ra[MX] = 0; &#125;&#125;int Find(int x)&#123; return par[x] == x ? x : par[x] = Find(par[x]);&#125;void unite(int x, int y)&#123; x = Find(x); y = Find(y); if(x == y) return ; par[x] = y;&#125;int main()&#123; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; memset(Du, 0, sizeof(Du)); Init(); scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); unite(u, v); Du[u]++; Du[v]++; &#125; int flag = 1; for(int i = 1; i &lt;= n; i++) &#123; if(Find(i) != Find(1)) &#123; flag = 0; break; &#125; if(Du[i] &amp; 1) &#123; flag = 0; break; &#125; &#125; cout&lt;&lt;flag&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
        <tag>HDU</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 2647】Reward]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-2647%E3%80%91Reward%2F</url>
    <content type="text"><![CDATA[Dandelion’s uncle is a boss of a factory. As the spring festival is coming , he wants to distribute rewards to his workers. Now he has a trouble about how to distribute the rewards.The workers will compare their rewards ,and some one may have demands of the distributing of rewards ,just like a’s reward should more than b’s.Dandelion’s unclue wants to fulfill all the demands, of course ,he wants to use the least money.Every work’s reward will be at least 888 , because it’s a lucky number. InputOne line with two integers n and m ,stands for the number of works and the number of demands .(n&lt;=10000,m&lt;=20000)then m lines ,each line contains two integers a and b ,stands for a’s reward should be more than b’s.OutputFor every case ,print the least money dandelion ‘s uncle needs to distribute .If it’s impossible to fulfill all the works’ demands ,print -1.Sample Input2 11 22 21 22 1Sample Output1777-1 解题思路邻接表实现拓扑排序，反向排序 这道题不用邻接表会爆内存，没必要一定可以进行排序，只要没有环就可以 wa了好多发就因为把不可以排序的情况也输出了-1 例如： n = 3, m = 2; 1 2 1 3 显然这没法排序，但只要1的工资同时比2和3都低就可以按题意输出工资 而且反向排序可以简单的完成判断输出所需的最大工资 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 10005;int n, m, tot, ind, sum, head[MX], IN[MX], mo[MX];struct Edge&#123; int v, nxt;&#125;e[2 * MX];void add(int u, int v)&#123; e[tot].v = v; e[tot].nxt = head[u]; head[u] = tot++; IN[v]++;&#125;void init()&#123; memset(head, -1, sizeof(head)); memset(IN, 0, sizeof(IN)); tot = 0; ind = 0; sum = 0;&#125;bool topo_sort()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) &#123; if(IN[i] == 0) q.push(i); &#125; while(!q.empty())&#123; int v = q.front(); sum += mo[v]; q.pop(); ind++; for(int i = head[v]; ~i; i = e[i].nxt)&#123; int u = e[i].v; IN[u]--; if(IN[u] == 0) &#123; q.push(u); mo[u] = mo[v] + 1; &#125; &#125; &#125; if(ind != n) &#123; return false; &#125; return true;&#125;int main()&#123; int u, v; while(scanf("%d%d", &amp;n, &amp;m) != EOF)&#123; init(); fill(mo, mo + n +1, 888); for(int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); add(v, u); &#125; if(topo_sort())&#123; cout&lt;&lt;sum&lt;&lt;endl; &#125; else cout&lt;&lt;-1&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>图论</tag>
        <tag>邻接表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ 1094】Sorting It All Out]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90POJ-1094%E3%80%91Sorting-It-All-Out%2F</url>
    <content type="text"><![CDATA[n ascending sorted sequence of distinct values is one in which some form of a less-than operator is used to order the elements from smallest to largest. For example, the sorted sequence A, B, C, D implies that A &lt; B, B &lt; C and C &lt; D. in this problem, we will give you a set of relations of the form A &lt; B and ask you to determine whether a sorted order has been specified or not. InputInput consists of multiple problem instances. Each instance starts with a line containing two positive integers n and m. the first value indicated the number of objects to sort, where 2 &lt;= n &lt;= 26. The objects to be sorted will be the first n characters of the uppercase alphabet. The second value m indicates the number of relations of the form A &lt; B which will be given in this problem instance. Next will be m lines, each containing one such relation consisting of three characters: an uppercase letter, the character “&lt;” and a second uppercase letter. No letter will be outside the range of the first n letters of the alphabet. Values of n = m = 0 indicate end of input.OutputFor each problem instance, output consists of one line. This line should be one of the following three: Sorted sequence determined after xxx relations: yyy…y.Sorted sequence cannot be determined.Inconsistency found after xxx relations. where xxx is the number of relations processed at the time either a sorted sequence is determined or an inconsistency is found, whichever comes first, and yyy…y is the sorted, ascending sequence.Sample Input4 6A&lt;BA&lt;CB&lt;CC&lt;DB&lt;DA&lt;B3 2A&lt;BB&lt;A26 1A&lt;Z0 0Sample OutputSorted sequence determined after 4 relations: ABCD.Inconsistency found after 2 relations.Sorted sequence cannot be determined. 解题思路有如下三种情况 如果可以确定唯一的排序顺序，输出顺序 有回环 顺序不唯一 这道题稍微有点坑人，要输出经过多少步骤可以得出结论，所以每次输入之后都要进行拓扑排序进行判断，还要对输入的关系进行标记，重复输入时不作处理 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;list&gt;using namespace std;const int MX = 30;int n, m, tot, s, ind, IN[MX], head[MX], rec[MX];int S[MX], flag, vis[MX];char ch[MX];struct Edge&#123; char v; int nxt;&#125;e[10010];void add(int u, int v)&#123; e[tot].v = v; e[tot].nxt = head[u]; head[u] = tot++; IN[v]++;&#125;void topo_sort()&#123; queue&lt;int&gt; q; memset(S, 0, sizeof(S)); for(int i = 0; i &lt; n; i++) rec[i] = IN[i]; for(int i = 0; i &lt; n; i++) if(vis[i] &amp;&amp; rec[i] == 0) q.push(i); ind = 0; int temp = 0; while(!q.empty()) &#123; if(q.size() &gt; 1) temp = 1; int v = q.front(); S[ind++] = v; q.pop(); for(int i = head[v]; ~i; i = e[i].nxt) &#123; int u = e[i].v; rec[u]--; if(rec[u] == 0) &#123; q.push(u); &#125; &#125; &#125; if(!temp &amp;&amp; ind == n) flag = 2; if(ind == s &amp;&amp; s &lt; n) flag = 0; if(ind &lt; s) flag = 1;&#125;int main()&#123; char c[5]; int x, y; while((~scanf("%d%d", &amp;n, &amp;m)) &amp;&amp; (n || m)) &#123; memset(IN, 0, sizeof(IN)); memset(head, -1, sizeof(head)); memset(vis, 0, sizeof(vis)); s = 0; tot = 0; flag = 0; for(int i = 1; i &lt;= m; i++) &#123; scanf("%s", c); if(flag) continue; x = c[0] - 'A'; y = c[2] - 'A'; if(!vis[x]) &#123; vis[x] = 1; s++; &#125; if(!vis[y]) &#123; vis[y] = 1; s++; &#125; add(x, y); topo_sort(); if(flag == 2) &#123; cout&lt;&lt;"Sorted sequence determined after "&lt;&lt;i&lt;&lt;" relations: "; for(int i = 0; i &lt; n; i++) cout&lt;&lt;char(S[i] + 'A'); cout&lt;&lt;"."&lt;&lt;endl; &#125; if(flag == 1) &#123; cout&lt;&lt;"Inconsistency found after "&lt;&lt;i&lt;&lt;" relations."&lt;&lt;endl; &#125; &#125; if(flag == 0) cout&lt;&lt;"Sorted sequence cannot be determined."&lt;&lt;endl; &#125; return 0;&#125; 这有一份拓扑模板，但是并不适用于本题目，不过还是会有一定的启发作用。邻接表的实现可以减少空间的浪费 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int MX = 1e5 +5;struct Edge&#123; int v,nxt;&#125;E[MX*2];int head[MX],tot,IN[MX];void init()&#123; memset(head,-1,sizeof(head)); tot=0; memset(IN,0,sizeof(IN));&#125;void add(int u,int v)&#123; E[tot].v=v; E[tot].nxt=head[u]; head[u]=tot++; IN[v]++;&#125;int vec[MX],sz;bool top_sort(int n)&#123; sz=0; queue&lt;int&gt;q; for(int i=1;i&lt;=n;i++) if(IN[i]&lt;=1) q.push(i); while(!q.empty())&#123; int u=q.front();q.pop(); vec[++sz]=u; for(int i=head[u];~i;i=E[i].nxt)&#123; int v=E[i].v; IN[v]--; if(IN[v]&lt;=1) q.push(v); &#125; &#125; if(sz!=n) return 0; return 1;&#125;int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=m;i++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; if(top_sort(n)) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>POJ</tag>
        <tag>图论</tag>
        <tag>邻接表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉图浅析及模板]]></title>
    <url>%2F2018%2F11%2F11%2F%E6%AC%A7%E6%8B%89%E5%9B%BE%E6%B5%85%E6%9E%90%E5%8F%8A%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[首先， 什么是欧拉回路。定义：通过图（无向图或有向图）中所有边且每边仅通过一次通路称为欧拉通路，相应的回路称为欧拉回路。具有欧拉回路的图称为欧拉图（Euler Graph），具有欧拉通路而无欧拉回路的图称为半欧拉图。 要明确，有向图的欧拉回路和无向图的欧拉回路是不同的，其次，欧拉回路与欧拉通路也是不同的。 无向图： 欧拉回路：所有点的度都为偶数。度：即该点连接的路径，无向图中，不分出度与入度。 可以随便从一点出发，经过所有的边，再次回到这一点 欧拉通路：有两个点的度为奇数。此时可以从其中一个度为奇数点经过其他的点最终到达 另一个度为奇数的点 有向图： 入度：从一条边指向这一点，则这一点的入度+1 出度：有一条边从该点出发指向其他点，则这一点的出度+1 欧拉回路：所有点的入度等于该点的出度 欧拉通路：起点的入度等于起点的出度-1，终点的入度等于终点的出度+1，其他点的入 度都等于该点的出度 无向图存在欧拉回路的充要条件： 当且仅当该图所有顶点度数都为偶数且该图是连通图 有向图存在欧拉回路的充要条件: 当且仅当所有顶点的入度等于出度且该图是连通图 无向图的欧拉回路模板： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std; const int MX=1e5+5;struct Edge&#123; //利用邻接表实现 int v,nxt;&#125;E[MX*2];int Head[MX],erear;void edge_init()&#123; erear=0; memset(Head,-1,sizeof(Head));&#125;void edge_add(int u,int v)&#123; E[erear].v=v; E[erear].nxt=Head[u]; Head[u]=erear++;&#125; bool vis[MX];int IN[MX],P[MX],sz;void Fleury(int u)&#123; for(int i=Head[u];~i;i=Head[u])&#123; int v=E[i].v; Head[u]=E[i].nxt; //下一个点指向上一个点，即删去这条边 if(vis[i|1]) continue; //判断是否已经使用过 vis[i|1]=1; Fleury(v); &#125; P[++sz]=u;&#125; int DU[MX];int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); edge_init(); memset(DU,0,sizeof(DU)); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=m;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); edge_add(u,v); edge_add(v,u); DU[u]++;DU[v]++; &#125; int cnt=0,rt;//a入度为奇数的个数 for(int i=1;i&lt;=n;i++)&#123; if(DU[i]%2==1)&#123; cnt++;rt=i; &#125; &#125; if(cnt!=2&amp;&amp;cnt!=0)&#123; printf("invalid\n"); return 0; &#125; if(cnt==0) rt=1; sz=0; Fleury(rt); for(int i=sz;i&gt;=1;i--)&#123; printf("%d ",P[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>笔记</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ 3356】AGTC]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90POJ-3356%E3%80%91AGTC%2F</url>
    <content type="text"><![CDATA[Let x and y be two strings over some finite alphabet A. We would like to transform xinto y allowing only operations given below: Deletion: a letter in x is missing in y at a corresponding position.Insertion: a letter in y is missing in x at a corresponding position.Change: letters at corresponding positions are distinctCertainly, we would like to minimize the number of all possible operations. IllustrationA G T A A G T * A G G C | | | | | | | A G T C T G A C G C Deletion: in the bottom lineInsertion: in the top lineChange: when the letters at the top and bottom are distinctThis tells us that to transform x = AGTCTGACGC into y = AGTAAGTAGGC we would be required to perform 5 operations (2 changes, 2 deletions and 1 insertion). If we want to minimize the number operations, we should do it like A G T A A G T A G G C | | | | | | | A G T C T G * A C G Cand 4 moves would be required (3 changes and 1 deletion). In this problem we would always consider strings x and y to be fixed, such that the number of letters in x is m and the number of letters in y is n where n ≥ m. Assign 1 as the cost of an operation performed. Otherwise, assign 0 if there is no operation performed. Write a program that would minimize the number of possible operations to transform any string x into a string y. InputThe input consists of the strings x and y prefixed by their respective lengths, which are within 1000. OutputAn integer representing the minimum number of possible operations to transform any string x into a string y. Sample Input10 AGTCTGACGC11 AGTAAGTAGGCSample Output4 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 这道题不知道是题目的bug还是数据太水 只要用长序列的长度减去最长公共子序列就可以过，但是如果是abcd和ebecd实际是3但是这种方法算下来是2 但既然题目可以a也无所谓这些，只不过刚开始一直以为这种方法是错的，有点方 ans = n - dp[m][n]; dp[m][n] : 最长公共子序列长度*/ #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 1005;int dp[MX][MX];char s1[MX], s2[MX];int n, m, tot;int solve()&#123; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(s1[i] == s2[j])&#123; dp[i + 1][j + 1] = dp[i][j] + 1; &#125; else&#123; dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]); &#125; &#125; &#125; return dp[m][n];&#125;int main()&#123; while(scanf("%d", &amp;m) != EOF) &#123; scanf("%s", s1); scanf("%d %s", &amp;n, s2); int num = solve(); cout&lt;&lt;n - num&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>POJ</tag>
        <tag>dp</tag>
        <tag>最长公共子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 2844】Coins（多重背包）]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-2844%E3%80%91Coins%EF%BC%88%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Whuacmers use coins.They have coins of value A1,A2,A3…An Silverland dollar. One day Hibix opened purse and found there were some coins. He decided to buy a very nice watch in a nearby shop. He wanted to pay the exact price(without change) and he known the price would not more than m.But he didn’t know the exact price of the watch. You are to write a program which reads n,m,A1,A2,A3…An and C1,C2,C3…Cn corresponding to the number of Tony’s coins of value A1,A2,A3…An then calculate how many prices(form 1 to m) Tony can pay use these coins. InputThe input contains several test cases. The first line of each test case contains two integers n(1 ≤ n ≤ 100),m(m ≤ 100000).The second line contains 2n integers, denoting A1,A2,A3…An,C1,C2,C3…Cn (1 ≤ Ai ≤ 100000,1 ≤ Ci ≤ 1000). The last test case is followed by two zeros.OutputFor each test case output the answer on a single line. Sample Input3 101 2 4 2 1 12 51 4 2 10 0Sample Output84 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 多重背包问题：直接背包显然超时，使用空间换时间 开一个cnt数组保存已使用的数目，之后像普通背包一样做就好*/ #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MXN = 105, MXM = 1e5 + 5;int n, m, a[MXN], c[MXN], dp[MXM], cnt[MXM];int main()&#123; while(scanf("%d%d", &amp;n, &amp;m) != EOF &amp;&amp; (n != 0 || m != 0)) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;c[i]); &#125; memset(dp, 0, sizeof(dp)); dp[0] = 1; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; memset(cnt, 0, sizeof(cnt)); for(int j = a[i]; j &lt;= m; j++) &#123; if(!dp[j] &amp;&amp; dp[j - a[i]] &amp;&amp; cnt[j - a[i]] &lt; c[i]) &#123; dp[j] = 1; ans++; cnt[j] = cnt[j - a[i]] + 1; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 1114】Piggy-Bank]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1114%E3%80%91Piggy-Bank%2F</url>
    <content type="text"><![CDATA[Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs! InputThe input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams.OutputPrint exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”.Sample Input310 11021 130 5010 11021 150 301 6210 320 4Sample OutputThe minimum amount of money in the piggy-bank is 60.The minimum amount of money in the piggy-bank is 100.This is impossible. 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 普通的一个背包，有一个需要注意的地方就是输出的两句话最后都有"."之前因为没加强势wa了好多发*/ #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std; int main()&#123; int T, E, F, N, m; int v[10050], w[10050], dp[10050]; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d", &amp;E, &amp;F); m = F - E; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; cin&gt;&gt;v[i]; cin&gt;&gt;w[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; dp[i] = 99999999; &#125; dp[0] = 0; for(int i = 0; i &lt; N; i++) &#123; for(int j = w[i]; j &lt;= m; j++) &#123; dp[j] = min(dp[j], dp[j - w[i]] + v[i]); &#125; &#125; if(dp[m] == 99999999) cout&lt;&lt;"This is impossible."&lt;&lt;endl; else cout&lt;&lt;"The minimum amount of money in the piggy-bank is "&lt;&lt;dp[m]&lt;&lt;"."&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 1421】搬寝室]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1421%E3%80%91%E6%90%AC%E5%AF%9D%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2k件过去就行了.但还是会很累,因为2k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧. Input每组输入数据有两行,第一行有两个数n,k(2&lt;=2*k&lt;=n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).Output对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.Sample Input2 11 3Sample Output4 1234567891011121314151617181920212223242526272829303132333435363738/* dp[i][j]: 前i件物品组成j对时的疲劳值*/ #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 2005;int dp[MX][MX], w[MX], n, k; int main()&#123; while(scanf("%d%d", &amp;n, &amp;k) != EOF) &#123; for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;w[i]); sort(w + 1, w + n + 1); for(int i = 0; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= k; j++) dp[i][j] = 0x7fffffff; &#125; for(int i = 2; i &lt;= n; i++) &#123; for(int j = 1; j * 2 &lt;= i; j++) &#123; dp[i][j] = min(dp[i - 2][j - 1] + (w[i - 1] - w[i]) * (w[i - 1] - w[i]), dp[i - 1][j]); &#125; &#125; cout&lt;&lt;dp[n][k]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 2577】How to Type]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-2577%E3%80%91How-to-Type%2F</url>
    <content type="text"><![CDATA[Pirates have finished developing the typing software. He called Cathy to test his typing software. She is good at thinking. After testing for several days, she finds that if she types a string by some ways, she will type the key at least. But she has a bad habit that if the caps lock is on, she must turn off it, after she finishes typing. Now she wants to know the smallest times of typing the key to finish typing a string. InputThe first line is an integer t (t&lt;=100), which is the number of test case in the input file. For each test case, there is only one string which consists of lowercase letter and upper case letter. The length of the string is at most 100.OutputFor each test case, you must output the smallest times of typing the key to finish typing this string.Sample Input3PiratesHDUacmHDUACMSample Output888 HintThe string “Pirates”, can type this way, Shift, p, i, r, a, t, e, s, the answer is 8.The string “HDUacm”, can type this way, Caps lock, h, d, u, Caps lock, a, c, m, the answer is 8The string “HDUACM”, can type this way Caps lock h, d, u, a, c, m, Caps lock, the answer is 8 12345678910111213141516171819202122232425262728293031323334353637383940414243/* dp[0][i]:大写标记关闭 dp[1][i]:大写标记开启*/ #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 105;char s[MX];int dp[2][MX];int main()&#123; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%s", s + 1); memset(dp, 0, sizeof(dp)); dp[0][0] = 0; dp[1][0] = 1; for(int i = 1; i &lt;= strlen(s + 1); i++) &#123; if(s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') &#123; dp[0][i] = min(dp[0][i - 1] + 1, dp[1][i - 1] + 2); dp[1][i] = min(dp[0][i - 1] + 2, dp[1][i - 1] + 2); &#125; else if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') &#123; dp[0][i] = min(dp[0][i - 1] + 2, dp[1][i - 1] + 2); dp[1][i] = min(dp[0][i - 1] + 2, dp[1][i - 1] + 1); &#125; &#125; cout&lt;&lt;min(dp[0][strlen(s + 1)], dp[1][strlen(s + 1)] + 1)&lt;&lt;endl; //最后要关闭标记，所以若是标记开启，还要额外加一 &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ 1651】Multiplication Puzzle]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90POJ-1651%E3%80%91Multiplication-Puzzle%2F</url>
    <content type="text"><![CDATA[The multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. The goal is to take cards in such order as to minimize the total number of scored points. For example, if cards in the row contain numbers 10 1 50 20 5, player might take a card with 1, then 20 and 50, scoring10150 + 50205 + 10505 = 500+5000+2500 = 8000 If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be15020 + 1205 + 1015 = 1000+100+50 = 1150. InputThe first line of the input contains the number of cards N (3 &lt;= N &lt;= 100). The second line contains N integers in the range from 1 to 100, separated by spaces.OutputOutput must contain a single integer - the minimal score.Sample Input610 1 50 50 20 5Sample Output3650 12345678910111213141516171819202122232425262728293031323334353637/* 区间DP: i：区间长度 j：起点 k：终点 V：将区间[i,j]分为[i,v]和[v+1,j]*/ #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 105;int dp[MX][MX], a[MX], m;int main()&#123; while(scanf("%d", &amp;m) != EOF) &#123; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= m; i++) scanf("%d", &amp;a[i]); for(int i = 2; i &lt; m; i++) &#123; for(int j = 2; j &lt;= m - i + 1; j++) &#123; int k = i + j - 1; dp[j][k] = 0x7fffffff; for(int v = j; v &lt;= k; v++) &#123; dp[j][k] = min(dp[j][k], dp[j][v] + dp[v + 1][k] + a[j - 1] * a[k] * a[v]); &#125; &#125; &#125; cout&lt;&lt;dp[2][m]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>POJ</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ 2955】Brackets]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90POJ-2955%E3%80%91Brackets%2F</url>
    <content type="text"><![CDATA[We give the following inductive definition of a “regular brackets” sequence: the empty sequence is a regular brackets sequence,if s is a regular brackets sequence, then (s) and [s] are regular brackets sequences, andif a and b are regular brackets sequences, then ab is a regular brackets sequence.no other sequence is a regular brackets sequenceFor instance, all of the following character sequences are regular brackets sequences: (), [], (()), ()[], ()[()] while the following character sequences are not: (, ], )(, ([)], ([(] Given a brackets sequence of characters a1a2 … an, your goal is to find the length of the longest regular brackets sequence that is a subsequence of s. That is, you wish to find the largest m such that for indices i1, i2, …, im where 1 ≤ i1 &lt; i2 &lt; … &lt; im ≤ n, ai1ai2 … aim is a regular brackets sequence. Given the initial sequence ([([]])], the longest regular brackets subsequence is [([])]. InputThe input test file will contain multiple test cases. Each input test case consists of a single line containing only the characters (, ), [, and ]; each input test will have length between 1 and 100, inclusive. The end-of-file is marked by a line containing the word “end” and should not be processed. OutputFor each input case, the program should print the length of the longest possible regular brackets subsequence on a single line. Sample Input((()))()()()([]]))[)(([][][)endSample Output66406 123456789101112131415161718192021222324252627282930313233/* dp [ i ] [ j ] 为串中第 i 个到第 j 个括号的最大匹配数目*/ #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 105;char s[MX];int dp[MX][MX];int main()&#123; while(scanf("%s", s) != EOF &amp;&amp; strcmp(s, "end"))&#123; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt; strlen(s); i++) &#123; for(int j = 0, k = i; k &lt; strlen(s); j++, k++) &#123; if((s[j] == '(' &amp;&amp; s[k] == ')') || (s[j] == '[' &amp;&amp; s[k] == ']')) dp[j][k] = dp[j + 1][k - 1] + 2; for(int m = j; m &lt; k; m++) dp[j][k] = max(dp[j][k], dp[j][m] + dp[m + 1][k]); &#125; &#125; cout&lt;&lt;dp[0][strlen(s) - 1]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>POJ</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 3591】The trouble of Xiaoqian]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-3591%E3%80%91The-trouble-of-Xiaoqian%2F</url>
    <content type="text"><![CDATA[Problem DescriptionIn the country of ALPC , Xiaoqian is a very famous mathematician. She is immersed in calculate, and she want to use the minimum number of coins in every shopping. (The numbers of the shopping include the coins she gave the store and the store backed to her.)And now , Xiaoqian wants to buy T (1 ≤ T ≤ 10,000) cents of supplies. The currency system has N (1 ≤ N ≤ 100) different coins, with values V1, V2, …, VN (1 ≤ Vi ≤ 120). Xiaoqian is carrying C1 coins of value V1, C2 coins of value V2, …., and CN coins of value VN (0 ≤ Ci ≤ 10,000). The shopkeeper has an unlimited supply of all the coins, and always makes change in the most efficient manner .But Xiaoqian is a low-pitched girl , she wouldn’t like giving out more than 20000 once. InputThere are several test cases in the input.Line 1: Two space-separated integers: N and T.Line 2: N space-separated integers, respectively V1, V2, …, VN coins (V1, …VN)Line 3: N space-separated integers, respectively C1, C2, …, CNThe end of the input is a double 0. OutputOutput one line for each test case like this ”Case X: Y” : X presents the Xth test case and Y presents the minimum number of coins . If it is impossible to pay and receive exact change, output -1. Sample Input3 70 5 25 50 5 2 1 0 0 Sample OutputCase 1: 3 解题思路对于xiaoqian 是一个多重背包，对于店家是完全背包，如果v[i] * c[i] &gt;= 20000，xiaoqian是完全背包，否则看做01背包，真正的上限是20000而不是T wa了四发因为初始化的问题，开始把dp1和dp2的数组初始化为0x3f，一直wa，直到改为了0x3f3f3f3f，之前一直是随便找一个就去初始化的，现在才知道0x3f3f3f3f才是无穷大，果然还是太渣了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 2e4 + 5;int n, t, sum, v[MX], c[MX], dp1[MX], dp2[MX];void complete_pack(int v)&#123; for(int i = v; i &lt;= 20000; i++) &#123; dp2[i] = min(dp2[i], dp2[i - v] + 1); &#125;&#125;void zeroone_pack(int k, int v)&#123; v = k * v; for(int i = 20000; i &gt;= v; i--) &#123; dp2[i] = min(dp2[i], dp2[i - v] + k); &#125;&#125;void pack(int v, int c)&#123; if(v * c &gt;= 20000) &#123; complete_pack(v); return ; &#125; int k = 1; while(k &lt; c) &#123; zeroone_pack(k, v); c -= k; k *= 2; &#125; zeroone_pack(c, v);&#125;int main()&#123; int Case = 1; while(scanf("%d%d", &amp;n, &amp;t) != EOF &amp;&amp; n != 0 &amp;&amp; t != 0)&#123; memset(dp1, 0x3f3f3f3f, sizeof(dp1)); memset(dp2, 0x3f3f3f3f, sizeof(dp2)); dp1[0] = 0; dp2[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;v[i]); &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;c[i]); &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = v[i]; j &lt;= 20000; j++)&#123; dp1[j] = min(dp1[j], dp1[j - v[i]] + 1); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; pack(v[i], c[i]); &#125; int ans = 0x3f3f3f3f; for(int i = t; i &lt;= 20000; i++) &#123; ans = min(ans, dp1[i - t] + dp2[i]); &#125; printf("Case %d: ", Case++); if(ans == 0x3f3f3f3f) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 1166】敌兵布阵]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1166%E3%80%91%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5%2F</url>
    <content type="text"><![CDATA[C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10EndSample OutputCase 1:63359 解题思路一道裸线段树，单点更新，只更新叶子节点,然后把信息用PushUP(int r)这个函数更新上来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;#define lson l, m, rt&lt;&lt;1#define rson m + 1, r, rt&lt;&lt;1|1const int MX = 5e5 + 5;int sum[MX &lt;&lt; 2], add[MX &lt;&lt; 2];int n; void PushUp(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void build(int l,int r,int rt)&#123; if(l == r) &#123; scanf("%d", &amp;sum[rt]); return ; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); PushUp(rt);&#125;void update(int p, int c, int l, int r, int rt)&#123; if(l == r) &#123; sum[rt] += c; return; &#125; int m = (l + r) &gt;&gt; 1; if(p &lt;= m) update(p, c, lson); else update(p, c, rson); PushUp(rt);&#125;int query(int L, int R, int l, int r, int rt)&#123; if(L &lt;= l &amp;&amp; R &gt;= r) return sum[rt]; int m = (l + r) &gt;&gt; 1; int ret = 0; if(L &lt;= m) ret += query(L, R, lson); if(R &gt; m) ret += query(L, R, rson); return ret;&#125;int main()&#123; int t, cas = 1; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;n); build(1, n, 1); printf("Case %d:\n", cas++); char ch[10]; while(scanf("%s", ch) != EOF) &#123; int a, b; if(ch[0] == 'E') break; scanf("%d%d", &amp;a, &amp;b); if(ch[0] == 'A') &#123; update(a, b, 1, n, 1); &#125; else if(ch[0] == 'Q') &#123; printf("%d\n", query(a, b, 1, n, 1)); &#125; else if(ch[0] == 'S') &#123; update(a, -b, 1, n, 1); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 1754】I Hate It]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1754%E3%80%91I-Hate-It%2F</url>
    <content type="text"><![CDATA[很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。Input本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。Output对于每一次询问操作，在一行里面输出最高成绩。 Sample Input5 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5Sample Output5659 HintHuge input,the C function scanf() will work better than cin 解题思路单点更新，线段树功能:update:单点替换 query:区间最值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#define lson l, m, rt&lt;&lt;1#define rson m + 1, r, rt&lt;&lt;1|1using namespace std;const int MXN = 2e6 + 5;const int MXM = 5005;int n, m, mx[MXN &lt;&lt; 2];void PushUp(int rt)&#123; mx[rt] = max(mx[rt &lt;&lt; 1], mx[rt &lt;&lt; 1 | 1]);&#125;void build(int l, int r, int rt)&#123; if(l == r) &#123; scanf("%d", &amp;mx[rt]); return ; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); PushUp(rt);&#125;void update(int p, int sc, int l, int r, int rt)&#123; if(l == r) &#123; mx[rt] = sc; return ; &#125; int m = (l + r) &gt;&gt; 1; if(p &lt;= m) update(p, sc, lson); else update(p, sc, rson); PushUp(rt);&#125;int query(int L, int R, int l, int r, int rt)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return mx[rt]; int m = (l + r) &gt;&gt; 1; int ret = 0; if(L &lt;= m) ret = max(ret, query(L, R, lson)); if(R &gt; m) ret = max(ret, query(L, R, rson)); return ret;&#125;int main()&#123; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; build(1, n, 1); for(int i = 0; i &lt; m; i++) &#123; char ch; int a, b; cin&gt;&gt;ch; scanf("%d%d", &amp;a, &amp;b); if(ch == 'Q') printf("%d\n", query(a, b, 1, n, 1)); else update(a, b, 1, n, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ 3468】A Simple Problem with Integers]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90POJ-3468%E3%80%91A-Simple-Problem-with-Integers%2F</url>
    <content type="text"><![CDATA[You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b” means querying the sum of Aa, Aa+1, … , Ab. OutputYou need to answer all Q commands in order. One answer in a line. Sample Input10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4Sample Output455915HintThe sums may exceed the range of 32-bit integers. 解题思路区间更新，需要用到延迟标记(或者说懒惰标记),简单来说就是每次更新的时候不要更新到底,用延迟标记使得更新延迟到下次需要更新or 询问到的时候 线段树功能:update:成段增减 query:区间求和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#define lson l, m, rt&lt;&lt;1#define rson m + 1, r, rt&lt;&lt;1|1using namespace std;typedef long long ll;const int MX = 1e6 + 5;int n, q;ll sum[MX &lt;&lt; 2], add[MX &lt;&lt; 2];void PushUp(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void PushDown(int m, int rt)&#123; if(add[rt]) &#123; sum[rt &lt;&lt; 1] += add[rt] * (m - (m &gt;&gt; 1)); sum[rt &lt;&lt; 1 | 1] += add[rt] * (m &gt;&gt; 1); add[rt &lt;&lt; 1] += add[rt]; add[rt &lt;&lt; 1 | 1] += add[rt]; add[rt] = 0; &#125;&#125;void build(int l, int r, int rt)&#123; add[rt] = 0; if(l == r) &#123; scanf("%I64d", &amp;sum[rt]); return ; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); PushUp(rt);&#125;void update(int L, int R, int c, int l, int r, int rt)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; sum[rt] += (ll)c * (r - l + 1); add[rt] += c; return ; &#125; PushDown(r - l + 1, rt); int m = (l + r) &gt;&gt; 1; if(L &lt;= m) update(L, R, c, lson); if(m &lt; R) update(L, R, c, rson); PushUp(rt);&#125;ll query(int L, int R, int l, int r, int rt)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[rt]; &#125; PushDown(r - l + 1, rt); int m = (l + r) &gt;&gt; 1; ll ret = 0; if(L &lt;= m) ret += query(L, R, lson); if(m &lt; R) ret += query(L, R, rson); return ret;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;q); build(1, n, 1); for(int i = 0; i &lt; q; i++) &#123; int a, b, c; char ch[2]; scanf("%s", &amp;ch); if(ch[0] == 'Q') &#123; scanf("%d%d", &amp;a, &amp;b); printf("%I64d\n", query(a, b, 1, n, 1)); &#125; else &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); update(a, b, c, 1, n, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>POJ</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 1698】Just a Hook]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1698%E3%80%91Just-a-Hook%2F</url>
    <content type="text"><![CDATA[In the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length. Now Pudge wants to do some operations on the hook. Let us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.The total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows: For each cupreous stick, the value is 1.For each silver stick, the value is 2.For each golden stick, the value is 3. Pudge wants to know the total value of the hook after performing the operations.You may consider the original hook is made up of cupreous sticks. InputThe input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.For each case, the first line contains an integer N, 1&lt;=N&lt;=100,000, which is the number of the sticks of Pudge’s meat hook and the second line contains an integer Q, 0&lt;=Q&lt;=100,000, which is the number of the operations.Next Q lines, each line contains three integers X, Y, 1&lt;=X&lt;=Y&lt;=N, Z, 1&lt;=Z&lt;=3, which defines an operation: change the sticks numbered from X to Y into the metal kind Z, where Z=1 represents the cupreous kind, Z=2 represents the silver kind and Z=3 represents the golden kind.OutputFor each case, print a number in a line representing the total value of the hook after the operations. Use the format in the example.Sample Input11021 5 25 9 3Sample OutputCase 1: The total value of the hook is 24. 解题思路线段树的成段更新 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#define lson l, m, rt&lt;&lt;1#define rson m + 1, r, rt&lt;&lt;1|1using namespace std;typedef long long ll;const int MX = 1e6 + 5;int q, n, sum[MX &lt;&lt; 2], add[MX &lt;&lt; 2];void PushUp(int rt)&#123; sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void PushDown(int rt, int m)&#123; if(add[rt]) &#123; add[rt &lt;&lt; 1] = add[rt]; add[rt &lt;&lt; 1 | 1] = add[rt]; sum[rt &lt;&lt; 1] = add[rt] * (m - (m &gt;&gt; 1)); sum[rt &lt;&lt; 1 | 1] = add[rt] * (m &gt;&gt; 1); add[rt] = 0; &#125;&#125;void build(int l, int r, int rt)&#123; add[rt] = 0; if(l == r) &#123; sum[rt] = 1; return ; &#125; int m = (l + r) &gt;&gt; 1; build(lson); build(rson); PushUp(rt);&#125;void update(int L, int R, int c, int l, int r, int rt)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; sum[rt] = (r - l + 1) * c; add[rt] = c; return ; &#125; PushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if(L &lt;= m) update(L, R, c, lson); if(R &gt; m) update(L, R, c, rson); PushUp(rt);&#125;int query(int L, int R, int l, int r, int rt)&#123; if(l == r) return sum[rt]; PushDown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; int ret = 0; if(L &lt;= m) ret += query(L, R, lson); if(m &lt; R) ret += query(L, R, rson);PushUp(rt); return ret;&#125;int main()&#123; int t; scanf("%d", &amp;t); for(int i = 1; i &lt;= t; i++) &#123; scanf("%d", &amp;n); scanf("%d", &amp;q); build(1, n, 1);//printf("Case %d: The total value of the hook is %d.\n", i, query(1, n, 1, n, 1)); for(int j = 0; j &lt; q; j++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); update(a, b, c, 1, n, 1);//printf("Case %d: The total value of the hook is %d.\n", i, query(1, n, 1, n, 1)); &#125; printf("Case %d: The total value of the hook is %d.\n", i, query(1, n, 1, n, 1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB mongo.exe启动及闪退解决]]></title>
    <url>%2F2018%2F11%2F11%2FMongoDB-mongo-exe%E5%90%AF%E5%8A%A8%E5%8F%8A%E9%97%AA%E9%80%80%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[启动：进入MongoDB安装目录下的bin目录，启动mongod.exe 出现如上图所示的提示行，打开：http://localhost:27017 若出现： 1It looks like you are trying to access MongoDB over HTTP on the native driver port. 则连接成功。 此时再打开刚刚的窗口，会新加几行，如下图 此时，不要关闭该窗口，新打开一个cmd，进入自己的MongoDB目录下的bin目录， 输入mongo，按下回车 若出现图示情况，则代表启动成功 闪退：在MongoDB所在盘下的根目录创建一个data文件夹，并在data文件夹里创建一个db文件夹 （例如，我的MongoDB在C盘的一个文件里，就在C盘根目录下创建data） 然后打开cmd，进入到MongoDB的bin目录下，输入mongod –dbpath c:/data 会出现图一所示情况，即修复成功，按上述步骤继续运行即可。 关闭：可以直接关闭mongod.exe窗口，也可以在该窗口下按 Ctrl+C 来关闭]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>闪退</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 1495】 非常可乐 (bfs + 模拟)]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-1495%E3%80%91-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90-bfs-%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 Input三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 Output如果能平分的话请输出最少要倒的次数，否则输出”NO”。 Sample Input7 4 34 1 30 0 0Sample OutputNO3 据大佬说这道题除了模拟还有一种解法，依据一个数学公式，感兴趣可以自己看一下, 代码长度远比模拟短 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188/* bfs + 模拟 开始时：S杯满， M， N杯为空， 最终S杯与max(M, N)杯分别装有S杯的一半 模拟有六种情况，S -&gt; M, S -&gt; N, M -&gt; S, M -&gt; N, N -&gt; S, N -&gt; M， 按此顺序倒可乐 如果之前未判断此种情况，加入队列切标记已遍历*/ #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 105;int s, m, n, vis[MX][MX];struct Node&#123; int x, y, s, step;&#125;;int bfs()&#123; queue&lt;Node&gt; q; Node now; now.x = 0; now.y = 0; now.s = s; now.step = 0; q.push(now); vis[m][n] = 1; while(!q.empty()) &#123; now = q.front(); Node node; q.pop(); if(now.x == s / 2 &amp;&amp; now.s == s / 2) &#123; return now.step; &#125; if(now.s != 0 &amp;&amp; now.x != m) &#123; int x = m - now.x; if(now.s &gt;= x) &#123; node.s = now.s - x; node.x = m; &#125; else &#123; node.s = 0; node.x = now.x + now.s; &#125; node.y = now.y; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; if(now.s != 0 &amp;&amp; now.y != n) &#123; int x = n - now.y; if(now.s &gt;= x) &#123; node.s = now.s - x; node.y = n; &#125; else &#123; node.s = 0; node.y = now.y + now.s; &#125; node.x = now.x; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; if(now.x != 0 &amp;&amp; now.s != s) &#123; int x = s - now.s; if(now.x &gt;= x) &#123; node.x = now.x - x; node.s = s; &#125; else &#123; node.x = 0; node.s = now.s + now.x; &#125; node.y = now.y; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; if(now.x != 0 &amp;&amp; now.y != n) &#123; int x = n - now.y; if(now.x &gt;= x) &#123; node.x = now.x - x; node.y = n; &#125; else &#123; node.x = 0; node.y = now.y + now.x; &#125; node.s = now.s; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; if(now.y != 0 &amp;&amp; now.s != s) &#123; int x = s - now.s; if(now.y &gt;= x) &#123; node.y = now.y - x; node.s = s; &#125; else &#123; node.y = 0; node.s = now.s + now.y; &#125; node.x = now.x; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; if(now.y != 0 &amp;&amp; now.x != m) &#123; int x = m - now.x; if(now.y &gt;= x) &#123; node.y = now.y - x; node.x = m; &#125; else &#123; node.y = 0; node.x = now.x + now.y; &#125; node.s = now.s; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; &#125; return -1;&#125;int main()&#123; while(scanf("%d%d%d", &amp;s, &amp;m, &amp;n) != EOF &amp;&amp; (s + m + n)) &#123; memset(vis, 0, sizeof(vis)); if(s &amp; 1) &#123; printf("NO\n"); continue; &#125; if(m &lt; n) swap(m, n); int x = bfs(); if(x != -1) printf("%d\n", x); else printf("NO\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>bfs</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ 3414】 Pots (bfs + 模拟 + 路径记录)]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90POJ-3414%E3%80%91-Pots-bfs-%E6%A8%A1%E6%8B%9F-%E8%B7%AF%E5%BE%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[You are given two pots, having the volume of A and B liters respectively. The following operations can be performed: FILL(i) fill the pot i (1 ≤ i ≤ 2) from the tap;DROP(i) empty the pot i to the drain;POUR(i,j) pour from pot i to pot j; after this operation either the pot jis full (and there may be some water left in the pot i), or the pot i is empty (and all its contents have been moved to the pot j).Write a program to find the shortest possible sequence of these operations that will yield exactly C liters of water in one of the pots. InputOn the first and only line are the numbers A, B, and C. These are all integers in the range from 1 to 100 and C≤max(A,B). OutputThe first line of the output must contain the length of the sequence of operations K. The following K lines must each describe one operation. If there are several sequences of minimal length, output any one of them. If the desired result can’t be achieved, the first and only line of the file must contain the word ‘impossible’. Sample Input3 5 4Sample Output6FILL(2)POUR(2,1)DROP(1)POUR(2,1)FILL(2)POUR(2,1) 题目大意：给出容积为A， B的两个容器，初始时容器内水的体积都为0，有三种操作： FILL(i)：将 i 倒满水。 DROP(i)：将 i 的水倒出。 POUR(i,j)： 将 i 的水倒入 j 中，直至 i 为空，或 j 已满。 问当A，B中有一个容器装水量为C时进行的操作数，并打印需要的操作 解题思路：模拟杯子中水交互的六种状态，在Node中设置变量分别记录进行的操作类型，是否为头节点，再设一个Node数组记录路径 具体见代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195/* bfs + 模拟 + 路径记录*/ #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;const int MX = 105;int A, B, C, flag[MX][MX]; //flag: 判断是否进行过该状态string s;struct Node&#123; int a, b; int s, sign, par; //s: 操作数 sign: 判断进行的操作 par: 父节点存在与否&#125;;Node path[MX][MX]; //记录路径void print(Node n)&#123; vector&lt;Node&gt; v; while(true) &#123; v.push_back(n); //将路径压入vector中 if(n.par == 0) //不存在父节点 break; n = path[n.a][n.b]; &#125; for(int i = v.size() - 1; i &gt;= 0; i--) &#123; if(v[i].sign == 1) &#123; printf("POUR(1,2)\n"); &#125; else if(v[i].sign == 2) &#123; printf("FILL(1)\n"); &#125; else if(v[i].sign == 3) &#123; printf("DROP(1)\n"); &#125; else if(v[i].sign == 4) &#123; printf("POUR(2,1)\n"); &#125; else if(v[i].sign == 5) &#123; printf("FILL(2)\n"); &#125; else &#123; printf("DROP(2)\n"); &#125; &#125;&#125;void bfs()&#123; memset(flag, 0, sizeof(flag)); queue&lt;Node&gt; q; Node now; now.a = 0; now.b = 0; now.par = -1; //不存在父节点 now.s = 0; now.sign = 0; flag[0][0] = 1; //节点已使用过 q.push(now); while(!q.empty()) &#123; now = q.front(); if(now.a == C || now.b == C) //任一杯子中的水等于C &#123; printf("%d\n", now.s); print(now); return ; &#125; Node node; q.pop(); if(now.b != B &amp;&amp; now.a) //POUR(now.a, now.b) &#123; int x = B - now.b; if(now.a &gt;= x) &#123; node.b = B; node.a = now.a - x; &#125; else &#123; node.a = 0; node.b = now.b + now.a; &#125; node.s = now.s + 1; //操作数增加 node.sign = 1; //标记操作类型 if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; //上一节点是now flag[node.a][node.b] = 1; //标记已使用 node.par = now.par + 1; //父节点数增加(若为第一个节点，此时par已为0) q.push(node); &#125; &#125; if(now.a != A) //FILL(now.a) &#123; node.a = A; node.b = now.b; node.s = now.s + 1; node.sign = 2; if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; flag[node.a][node.b] = 1; node.par = now.par + 1; q.push(node); &#125; &#125; if(now.a) //DROP(now.a) &#123; node.a = 0; node.b = now.b; node.s = now.s + 1; node.sign = 3; if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; flag[node.a][node.b] = 1; node.par = now.par + 1; q.push(node); &#125; &#125; if(now.b &amp;&amp; now.a != A) //POUR(now.b, now.a) &#123; int x = A - now.a; if(now.b &gt;= x) &#123; node.b = now.b - x; node.a = A; &#125; else &#123; node.b = 0; node.a = now.a + now.b; &#125; node.s = now.s + 1; node.sign = 4; if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; flag[node.a][node.b] = 1; node.par = now.par + 1; q.push(node); &#125; &#125; if(now.b != B) //FILL(now.b) &#123; node.b = B; node.a = now.a; node.s = now.s + 1; node.sign = 5; if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; flag[node.a][node.b] = 1; node.par = now.par + 1; q.push(node); &#125; &#125; if(now.b) //DROP(now.b) &#123; node.b = 0; node.a = now.a; node.s = now.s + 1; node.sign = 6; if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; flag[node.a][node.b] = 1; node.par = now.par + 1; q.push(node); &#125; &#125; &#125; printf("impossible\n");&#125;int main()&#123; while(scanf("%d%d%d", &amp;A, &amp;B, &amp;C) != EOF) &#123; bfs(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>bfs</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ 1088】滑雪]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90POJ-1088%E3%80%91%E6%BB%91%E9%9B%AA%2F</url>
    <content type="text"><![CDATA[Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。 Input输入的第一行表示区域的行数R和列数C(1 &lt;= R,C &lt;= 100)。下面是R行，每行有C个整数，代表高度h，0&lt;=h&lt;=10000。Output输出最长区域的长度。Sample Input5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9Sample Output25 解题思路：dp， 每次遍历四种状态， 选择比当前低的地方走 dp[i][j] : 从i， j 位置出发的最长路径 dp[i][j] = max(dp[i][j], dp[newI][newJ] + 1); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MXC = 105;const int MXH = 1e4 + 5;int s[MXC][MXC];int dp[MXC][MXC];int r, c;int fx[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;int DP(int x, int y)&#123; if(dp[x][y] != 0) return dp[x][y]; int nx, ny; int mx = 1; for(int i = 0; i &lt; 4; i++) &#123; nx = x + fx[i][0]; ny = y + fx[i][1]; if(s[x][y] &gt; s[nx][ny] &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; r &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; c) &#123; mx = max(mx, DP(nx, ny) + 1); &#125; &#125; return dp[x][y] = mx;&#125;int main()&#123; while(scanf("%d%d", &amp;r, &amp;c) != EOF) &#123; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; r; i++) &#123; for(int j = 0; j &lt; c; j++) &#123; scanf("%d", &amp;s[i][j]); &#125; &#125; for(int i = 0; i &lt; r; i++) &#123; for(int j = 0; j &lt; c; j++) &#123; if(dp[i][j] == 0) DP(i, j); &#125; &#125; int ans = 0; for(int i = 0; i &lt; r; i++) &#123; for(int j = 0; j &lt; c; j++) &#123; ans = max(ans, dp[i][j]); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>POJ</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node下载的模块无法使用（Cannot find module）解决方法]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%85%B3%E4%BA%8Enode%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%A8%A1%E5%9D%97%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%EF%BC%88Cannot-find-module%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这个问题困扰了我很久，也按百度上各式各样的方法试了没有用 今天和导师远程，知道了问题在哪，我用webstorm编译器进行演示 若使用其他编译器，可按下述原理进行修改 原理(在当前工程文件夹下要有一个package.json文件，并在此工程下安装npm模块，安装后会出现一个node_modules文件夹，里面包含着下载的模块) 过程： 测试代码： 此时运行，结果如下图， 显示：Cannot find module 在Terminal面板对colors模块进行安装会出现如下错误： 此时，继续在该面板，输入 npm init 按下回车进行初始化，效果如图： 此时一直点击回车，直到出现” Is this ok? (yes) ” 输入yes 回车 此时，继续安装colors模块，提示安装成功： 重新运行程序，此时成功输出：]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU 2553】 N皇后问题]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-2553%E3%80%91-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 Input共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 Output共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 Sample Input1850Sample Output19210 N皇后问题比较经典了，在紫书上也有讲，但是交上去总是TLE，后来发现是记录上出了问题，在计算答案之前先循环计算1-10的答案并记录在一个数组中，输入n之后直接调用数组答案输出即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int tot, n, c[11];void search_(int cur, int k)&#123; if(cur == k) tot++; else&#123; for(int i = 0; i &lt; k; i++)&#123; int ok = 1; c[cur] = i; for(int j = 0; j &lt; cur; j++) &#123; if(c[cur] == c[j] || cur - c[cur] == j - c[j] || cur + c[cur] == j + c[j]) &#123; ok = 0; break; &#125; &#125; if(ok) search_(cur + 1, k); &#125; &#125;&#125;int main()&#123; int oldAns[11]; memset(oldAns, 0, sizeof(oldAns)); for(int i = 0; i &lt;= 10; i++) &#123; tot = 0; search_(0, i); oldAns[i] = tot; &#125; while(scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; cout&lt;&lt;oldAns[n]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断素数的算法]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0%E7%9A%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.根据定义求，时间复杂度为：O(n) 判断除了1和它本身外是否还有其他因数 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 1e6 + 5;int n;/** 根据定义求*/string is_Prime(int x)&#123; if(x == 1) return "no"; bool flag = true; for(int i = 2; i &lt; x; i++) &#123; if(x % i == 0) &#123; flag = false; break; &#125; &#125; return flag ? "yes" : "no";&#125;int main()&#123; while(scanf("%d", &amp;n) != EOF) &#123; printf("Is %d is a prime?\t", n); cout&lt;&lt;is_Prime(n)&lt;&lt;endl; &#125; return 0;&#125; 2.若该数为偶数，则必定不是素数至少可以被2整除且2为素数，时间复杂度O(n / 2) 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 1e6 + 5;int n;/** 去掉偶数*/string is_Prime(int x)&#123; if(x == 1) return "no"; for(int i = 3; i &lt; x; i += 2) &#123; if(x % i == 0) &#123; return "no"; &#125; &#125; return "yes";&#125;int main()&#123; while(scanf("%d", &amp;n) != EOF) &#123; printf("Is %d is a prime?\t", n); cout&lt;&lt;is_Prime(n)&lt;&lt;endl; &#125; return 0;&#125; 3.若要求n是否为素数，可以求在2-sqrt(n)中是否存在n的约数，若是不存在，在sqrt(n)-n - 1中也必定没有它的约数，时间复杂度O(sqrt(n)/2) 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 1e6 + 5;int n;/** sqrt(n)*/string is_Prime(int x)&#123; if(x == 1) return "no"; int m = sqrt(x); for(int i = 2; i &lt;= m; i++) &#123; if(x % i == 0) &#123; return "no"; &#125; &#125; return "yes";&#125;int main()&#123; while(scanf("%d", &amp;n) != EOF) &#123; printf("Is %d is a prime?\t", n); cout&lt;&lt;is_Prime(n)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>素数</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU-2136】 Largest prime factor]]></title>
    <url>%2F2018%2F11%2F11%2F%E3%80%90HDU-2136%E3%80%91-Largest-prime-factor%2F</url>
    <content type="text"><![CDATA[Everybody knows any number can be combined by the prime number.Now, your task is telling me what position of the largest prime factor.The position of prime 2 is 1, prime 3 is 2, and prime 5 is 3, etc.Specially, LPF(1) = 0. InputEach line will contain one integer n(0 &lt; n &lt; 1000000).OutputOutput the LPF(n).Sample Input12345Sample Output01213 12345678910111213141516171819202122232425262728293031323334353637/** 素数筛法，每遍历一个外层点时 将它的所有倍数全部赋值为num(当前质因子的序号) 从小到大逐个遍历即为最大质因子的序号*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int Max = 1e6 + 5;int n;int a[Max];int main()&#123; memset(a, 0, sizeof(a)); int num = 1; //质因子序号 for(int i = 2; i &lt;= Max; i++) &#123; if(!a[i]) &#123; for(int j = i; j &lt;= Max; j += i) //i的所有倍数都被赋值为同一个序号 &#123; a[j] = num; &#125; num++; &#125; &#125; while(scanf("%d", &amp;n) != EOF) &#123; printf("%d\n", a[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HDU</tag>
        <tag>素数筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201512-2 消除类游戏]]></title>
    <url>%2F2018%2F11%2F10%2FCCF-201512-2-%E6%B6%88%E9%99%A4%E7%B1%BB%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[问题描述 消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。 现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。 请注意：一个棋子可能在某一行和某一列同时被消除。 输入格式 输入的第一行包含两个整数n, m，用空格分隔，分别表示棋盘的行数和列数。 接下来n行，每行m个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。输出格式 输出n行，每行m个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出0，否则输出棋子的颜色编号。样例输入4 52 2 3 1 23 4 5 1 42 3 2 1 32 2 2 4 4样例输出2 2 3 0 23 4 5 0 42 3 2 0 30 0 0 4 4样例说明 棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。样例输入4 52 2 3 1 23 1 1 1 12 3 2 1 32 2 3 3 3样例输出2 2 3 0 23 0 0 0 02 3 2 0 32 2 0 0 0样例说明 棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。评测用例规模与约定 所有的评测用例满足：1 ≤ n, m ≤ 30。 解题思路分别按行列消除，开一个数组记录该位置是否要被消除，并不改变输入数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int n, m;int a[35][35];int us[35][35];int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(us, 0, sizeof(us)); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; int num = 1; for(int i = 0; i &lt; n; i++) //按列消除 &#123; for(int j = 0; j &lt; m; j++) &#123; while(a[i][j] == a[i][j + 1]) &#123; j++; if(j == m) break; num++; if(num &gt;= 3) &#123; for(int k = j - num + 1; k &lt;= j; k++) //记录是否要被消除 &#123; us[i][k] = 1; &#125; &#125; &#125; num = 1; &#125; &#125; for(int i = 0; i &lt; m; i++) //按行消除 &#123; for(int j = 0; j &lt; n; j++) &#123; while(a[j][i] == a[j + 1][i]) &#123; j++; if(j == n) break; num++; if(num &gt;= 3) &#123; for(int k = j - num + 1; k &lt;= j; k++) &#123; us[k][i] = 1; &#125; &#125; &#125; num = 1; &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(!us[i][j]) cout&lt;&lt;a[i][j]; else cout&lt;&lt;0; if(j == m - 1) cout&lt;&lt;endl; else cout&lt;&lt;" "; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201512-1 数位之和]]></title>
    <url>%2F2018%2F11%2F10%2FCCF-201512-1-%E6%95%B0%E4%BD%8D%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[问题描述 给定一个十进制整数n，输出n的各位数字之和。 输入格式 输入一个整数n。输出格式 输出一个整数，表示答案。样例输入20151220样例输出13样例说明 20151220的各位数字之和为2+0+1+5+1+2+2+0=13。评测用例规模与约定 所有评测用例满足：0 ≤ n ≤ 1000000000。 这道题的数据用int也可以过 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;ll n;int main()&#123; cin&gt;&gt;n; int sum = 0; while(n) &#123; sum += n % 10; n /= 10; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>CCF 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201604-4 游戏]]></title>
    <url>%2F2018%2F11%2F10%2FCCF-201604-4-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[问题描述 小明在玩一个电脑游戏，游戏在一个n×m的方格图上进行，小明控制的角色开始的时候站在第一行第一列，目标是前往第n行第m列。 方格图上有一些方格是始终安全的，有一些在一段时间是危险的，如果小明控制的角色到达一个方格的时候方格是危险的，则小明输掉了游戏，如果小明的角色到达了第n行第m列，则小明过关。第一行第一列和第n行第m列永远都是安全的。 每个单位时间，小明的角色必须向上下左右四个方向相邻的方格中的一个移动一格。 经过很多次尝试，小明掌握了方格图的安全和危险的规律：每一个方格出现危险的时间一定是连续的。并且，小明还掌握了每个方格在哪段时间是危险的。 现在，小明想知道，自己最快经过几个时间单位可以达到第n行第m列过关。 输入格式 输入的第一行包含三个整数n, m, t，用一个空格分隔，表示方格图的行数n、列数m，以及方格图中有危险的方格数量。 接下来t行，每行4个整数r, c, a, b，表示第r行第c列的方格在第a个时刻到第b个时刻之间是危险的，包括a和b。游戏开始时的时刻为0。输入数据保证r和c不同时为1，而且当r为n时c不为m。一个方格只有一段时间是危险的（或者说不会出现两行拥有相同的r和c）。输出格式 输出一个整数，表示小明最快经过几个时间单位可以过关。输入数据保证小明一定可以过关。样例输入3 3 32 1 1 11 3 2 102 2 2 10样例输出6样例说明 第2行第1列时刻1是危险的，因此第一步必须走到第1行第2列。 第二步可以走到第1行第1列，第三步走到第2行第1列，后面经过第3行第1列、第3行第2列到达第3行第3列。评测用例规模与约定 前30%的评测用例满足：0 &lt; n, m ≤ 10，0 ≤ t &lt; 99。 所有评测用例满足：0 &lt; n, m ≤ 100，0 ≤ t &lt; 9999，1 ≤ r ≤ n，1 ≤ c ≤ m，0 ≤ a ≤ b ≤ 100。 解题思路bfs计算最短时间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;struct Node&#123; int x, y, step;&#125;now;int n, m, t;int dir[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;int a[105][105][2] = &#123;0&#125;, us[105][105][305] = &#123;0&#125;;void bfs()&#123; queue&lt;Node&gt; q; now.x = 1; now.y = 1; now.step = 0; q.push(now); while(!q.empty()) &#123; now = q.front(); q.pop(); if(now.x == n &amp;&amp; now.y == m) &#123; printf("%d\n", now.step); return ; &#125; for(int i = 0; i &lt; 4; i++) &#123; int x = now.x + dir[i][0]; int y = now.y + dir[i][1]; int time = now.step + 1; if(x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m || time &gt;= a[x][y][0] &amp;&amp; time &lt;= a[x][y][1] || us[x][y][time]) continue; Node nxt; nxt.x = x; nxt.y = y; nxt.step = time; q.push(nxt); us[x][y][time] = 1; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;t); int r, c, a1, b1; while(t--) &#123; scanf("%d%d%d%d", &amp;r, &amp;c, &amp;a1, &amp;b1); a[r][c][0] = a1; a[r][c][1] = b1; &#125; bfs(); return 0;&#125;]]></content>
      <categories>
        <category>CCF 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCF</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201609-2 火车购票]]></title>
    <url>%2F2018%2F11%2F10%2FCCF-201609-2-%E7%81%AB%E8%BD%A6%E8%B4%AD%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[问题描述 请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。 假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。 购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。 假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。 输入格式 输入的第一行包含一个整数n，表示购票指令的数量。 第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。输出格式 输出n行，每行对应一条指令的处理结果。 对于购票指令p，输出p张车票的编号，按从小到大排序。样例输入42 5 4 2样例输出1 26 7 8 9 1011 12 13 143 4样例说明 1) 购2张票，得到座位1、2。 2) 购5张票，得到座位6至10。 3) 购4张票，得到座位11至14。 4) 购2张票，得到座位3、4。评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。 解题思路利用数组进行购票模拟ps：当每一行所剩余的位置都不够p时，从前往后遍历空位置进行购买 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int n, p, us[105], num[25];int main()&#123; while(scanf("%d", &amp;n) != EOF) &#123; memset(us, 0, sizeof(us)); for(int i = 0; i &lt;= 20; i ++) //每一行所剩余的票数 &#123; num[i] = 5; &#125; int flag = 0; while(n--) &#123; scanf("%d", &amp;p); for(int i = 1; i &lt;= 20; i++) &#123; if(num[i] &gt;= p) //每一行所余的票数足够 &#123; flag = 1; num[i] -= p; int cnt = 0; for(int j = 1; j &lt;= 5; j++) //计算得出当前可订的座位 &#123; if(!us[(i - 1) * 5 + j]) &#123; us[(i - 1) * 5 + j] = 1; printf("%d", (i - 1) * 5 + j); cnt++; if(cnt != p) printf(" "); else &#123; printf("\n"); break; &#125; &#125; &#125; break; &#125; &#125; if(flag) &#123; flag = 0; continue; &#125; else //若每一行都没有足够的位置，则从第一行开始订剩余的不连贯的位置 &#123; int cnt = 0; for(int i = 1; i &lt;= 100; i++) &#123; if(!us[i]) &#123; us[i] = 1; printf("%d", i); cnt++; if(cnt == p) &#123; printf("\n"); break; &#125; else printf(" "); &#125; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCF</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201604-2 俄罗斯方块]]></title>
    <url>%2F2018%2F11%2F10%2FCCF-201604-2-%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%2F</url>
    <content type="text"><![CDATA[问题描述 俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。 游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。 在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。 具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。 输入格式 输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。 输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。 第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例）输出格式 输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。样例输入0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 0 0 0 1 1 1 10 0 0 0 1 0 0 0 0 00 0 0 00 1 1 10 0 0 10 0 0 03样例输出0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 1 1 1 1 1 1 10 0 0 0 1 1 0 0 0 0 下述代码仅得 90 分 解题思路用数组模拟下落的过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int a[16][11], b[5][5];int tmp1[5] = &#123;15, 15, 15, 15, 15&#125;, tmp2[5] = &#123;0, 0, 0, 0, 0&#125;;int d;int main()&#123; for(int i = 1; i &lt;= 15; i++) &#123; for(int j = 1; j &lt;= 10; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; for(int i = 1; i &lt;= 4; i++) &#123; for(int j = 1; j &lt;= 4; j++) &#123; scanf("%d", &amp;b[i][j]); &#125; &#125; cin&gt;&gt;d; for(int i = d; i &lt; d + 4; i++) //计算a中第i列有1的最小行 &#123; for(int j = 1; j &lt;= 15; j ++) &#123; if(a[j][i] == 1) &#123; tmp1[i - d + 1] = j - 1; break; &#125; &#125; &#125; for(int i = 1; i &lt;= 4; i++) //计算b中第i列有1的最大行 &#123; for(int j = 1; j &lt;= 4; j++) &#123; if(b[j][i] == 1) &#123; tmp2[i] = j; &#125; &#125; &#125; int cnt = 15; for(int i = 1; i &lt;= 4; i++) //求出差值得出b中元素该放的位置 &#123; cnt = min(cnt, tmp1[i] - tmp2[i]); &#125; for(int i = 1; i &lt;= 4; i++) //模拟变化 &#123; for(int j = 1; j &lt;= 4; j++) &#123; a[i + cnt][j + d - 1] += b[i][j]; &#125; &#125; for(int i = 1; i &lt;= 15; i++) &#123; for(int j = 1; j &lt;= 10; j++) &#123; printf("%d", a[i][j]); if(j != 10) printf(" "); else printf("\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCF</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201609-1 最大波动]]></title>
    <url>%2F2018%2F11%2F10%2FCCF-201609-1-%E6%9C%80%E5%A4%A7%E6%B3%A2%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[问题描述 小明正在利用股票的波动程度来研究股票。小明拿到了一只股票每天收盘时的价格，他想知道，这只股票连续几天的最大波动值是多少，即在这几天中某天收盘价格与前一天收盘价格之差的绝对值最大是多少。 输入格式 输入的第一行包含了一个整数n，表示小明拿到的收盘价格的连续天数。 第二行包含n个正整数，依次表示每天的收盘价格。输出格式 输出一个整数，表示这只股票这n天中的最大波动值。样例输入62 5 5 7 3 5样例输出4样例说明 第四天和第五天之间的波动最大，波动值为|3-7|=4。评测用例规模与约定 对于所有评测用例，2 ≤ n ≤ 1000。股票每一天的价格为1到10000之间的整数。 解题思路用一个flag记录在此之前是上升还是下降，若存在波动，在ans++之后要把flag及时更新 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int MX = 1005;int n, a[MX], b[MX];int main()&#123; while(scanf("%d", &amp;n) != EOF) &#123; int ans = 0; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); &#125; for(int i = 1; i &lt; n; i++) &#123; b[i] = abs(a[i] - a[i - 1]); ans = max(ans, b[i]); &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201612-2 工资计算]]></title>
    <url>%2F2018%2F11%2F10%2FCCF-201612-2-%E5%B7%A5%E8%B5%84%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[问题描述 小明的公司每个月给小明发工资，而小明拿到的工资为交完个人所得税之后的工资。假设他一个月的税前工资（扣除五险一金后、未扣税前的工资）为S元，则他应交的个人所得税按如下公式计算： 1） 个人所得税起征点为3500元，若S不超过3500，则不交税，3500元以上的部分才计算个人所得税，令A=S-3500元； 2） A中不超过1500元的部分，税率3%； 3） A中超过1500元未超过4500元的部分，税率10%； 4） A中超过4500元未超过9000元的部分，税率20%； 5） A中超过9000元未超过35000元的部分，税率25%； 6） A中超过35000元未超过55000元的部分，税率30%； 7） A中超过55000元未超过80000元的部分，税率35%； 8） A中超过80000元的部分，税率45%； 例如，如果小明的税前工资为10000元，则A=10000-3500=6500元，其中不超过1500元部分应缴税1500×3%=45元，超过1500元不超过4500元部分应缴税(4500-1500)×10%=300元，超过4500元部分应缴税(6500-4500)×20%=400元。总共缴税745元，税后所得为9255元。 已知小明这个月税后所得为T元，请问他的税前工资S是多少元。 输入格式 输入的第一行包含一个整数T，表示小明的税后所得。所有评测数据保证小明的税前工资为一个整百的数。输出格式 输出一个整数S，表示小明的税前工资。样例输入9255样例输出10000评测用例规模与约定 对于所有评测用例，1 ≤ T ≤ 100000。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;int t;int main()&#123; while(scanf("%d", &amp;t) != EOF) &#123; if(t &lt;= 3500) &#123; printf("%d\n", t); &#125; else if(t &lt;= 4955 &amp;&amp; t &gt; 3500) &#123; t -= 3500; t = t * 100 / 97; t += 3500; printf("%d\n", t); &#125; else if(t &lt;= 7655 &amp;&amp; t &gt; 4955) &#123; t -= 5000; t += 45; t = t * 100 / 90; t += 5000; printf("%d\n", t); &#125; else if(t &lt;= 11255 &amp;&amp; t &gt; 7655) &#123; t -= 8000; t += 345; t = t * 100 / 80; t += 8000; printf("%d\n", t); &#125; else if(t &lt;= 30755 &amp;&amp; t &gt; 11255) &#123; t -= 12500; t += 1245; t = t * 100 / 75; t += 12500; printf("%d\n", t); &#125; else if(t &lt;= 44755 &amp;&amp; t &gt; 30755) &#123; t -= 38500; t += 7745; t = t * 100 / 70; t += 38500; printf("%d\n", t); &#125; else if(t &lt;= 61005 &amp;&amp; t &gt; 44755) &#123; t -= 58500; t += 13745; t = t * 100 / 65; t += 58500; printf("%d\n", t); &#125; else &#123; t -= 83500; t += 22495; t = t * 100 / 55; t += 83500; printf("%d\n", t); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201612-1 中间数]]></title>
    <url>%2F2018%2F11%2F10%2FCCF-201612-1-%E4%B8%AD%E9%97%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述 在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。 给定一个整数序列，请找出这个整数序列的中间数的值。 输入格式 输入的第一行包含了一个整数n，表示整数序列中数的个数。 第二行包含n个正整数，依次表示a1, a2, …, an。输出格式 如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。样例输入62 6 5 6 3 5样例输出5样例说明 比5小的数有2个，比5大的数也有2个。样例输入43 4 6 7样例输出-1样例说明 在序列中的4个数都不满足中间数的定义。样例输入53 4 6 6 7样例输出-1样例说明 在序列中的5个数都不满足中间数的定义。评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ ai ≤ 1000。 解题思路排序找最中间的位置，算出比它大和小的数的个数，比较判定 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;int n, a[1005];int main()&#123; while(scanf("%d", &amp;n) != EOF) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; sort(a + 1, a + n + 1); int num; if(n &amp; 1) num = a[n / 2 + 1]; else num = a[n / 2]; int sum1 = 0, sum2 = 0; for(int i = 1; i &lt;= n; i++) &#123; if(a[i] &lt; num) sum1++; if(a[i] &gt; num) sum2++; &#125; if(sum1 == sum2) printf("%d\n", num); else printf("-1\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201703-4 地铁修建(最小生成树 + 并查集)]]></title>
    <url>%2F2018%2F11%2F10%2FCCF-201703-4-%E5%9C%B0%E9%93%81%E4%BF%AE%E5%BB%BA-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[问题描述 A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。 地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。 现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。 作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。 输入格式 输入的第一行包含两个整数n, m，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。 第2行到第m+1行，每行包含三个整数a, b, c，表示枢纽a和枢纽b之间可以修建一条隧道，需要的时间为c天。输出格式 输出一个整数，修建整条地铁线路最少需要的天数。样例输入6 61 2 42 3 43 6 71 4 24 5 55 6 6样例输出6样例说明 可以修建的线路有两种。 第一种经过的枢纽依次为1, 2, 3, 6，所需要的时间分别是4, 4, 7，则整条地铁线需要7天修完； 第二种经过的枢纽依次为1, 4, 5, 6，所需要的时间分别是2, 5, 6，则整条地铁线需要6天修完。 第二种方案所用的天数更少。评测用例规模与约定 对于20%的评测用例，1 ≤ n ≤ 10，1 ≤ m ≤ 20； 对于40%的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000； 对于60%的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000，1 ≤ c ≤ 1000； 对于80%的评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000； 对于100%的评测用例，1 ≤ n ≤ 100000，1 ≤ m ≤ 200000，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000000。 所有评测用例保证在所有候选隧道都修通时1号枢纽可以通过隧道到达其他所有枢纽。 解题思路利用并查集判断是否连通， 利用最小生成树判断最短天数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;const int MXN = 1e5 + 5, MXM = 2e5 + 5;struct Node&#123; int a, b, t; bool operator&lt; (const Node node)const&#123; return t &lt; node.t; &#125;&#125;e[MXM];int n, m, par[MXM];void init()&#123; for(int i = 0; i &lt;= n; i++) &#123; par[i] = i; &#125;&#125;int fid(int x)&#123; return par[x] == x? x : par[x] = fid(par[x]);&#125;int main()&#123; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; for(int i = 0; i &lt; m; i++) scanf("%d%d%d", &amp;e[i].a, &amp;e[i].b, &amp;e[i].t); init(); sort(e, e + m); for(int i = 0; i &lt; m; i++) &#123; int x = fid(e[i].a); int y = fid(e[i].b); if(x != y) &#123; par[x] = y; &#125; if(fid(1) == fid(n)) &#123; printf("%d\n", e[i].t); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCF</tag>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 201703-2 学生排队(模拟)]]></title>
    <url>%2F2018%2F11%2F10%2FCCF-201703-2-%E5%AD%A6%E7%94%9F%E6%8E%92%E9%98%9F-%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[问题描述 体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。 例如，下面给出了一组移动的例子，例子中学生的人数为8人。 0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8； 1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8； 2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7； 3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。 小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？ 请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。 输入格式 输入的第一行包含一个整数n，表示学生的数量，学生的学号由1到n编号。 第二行包含一个整数m，表示调整的次数。 接下来m行，每行两个整数p, q，如果q为正，表示学号为p的同学向后移动q，如果q为负，表示学号为p的同学向前移动-q。输出格式 输出一行，包含n个整数，相邻两个整数之间由一个空格分隔，表示最终从前向后所有学生的学号。样例输入833 28 -33 -2样例输出1 2 4 3 5 8 6 7评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，所有移动均合法。 解题思路数组模拟，利用两个数组，一个表示指定位置的学生学号，一个表示该学号的学生所在的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int MX = 1005;struct Mve&#123; int id, mve;&#125;e[MX];int n, a[MX], b[MX];int m;int main()&#123; while(scanf("%d", &amp;n) != EOF) &#123; for(int i = 1; i &lt;= n; i++) &#123; a[i] = i; b[i] = i; &#125; scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;e[i].id, &amp;e[i].mve); &#125; for(int i = 1; i &lt;= m; i++) &#123; if(e[i].mve &lt; 0) &#123; int ind = b[e[i].id] + e[i].mve; int tmp = a[ind]; int st = b[e[i].id], ed = b[tmp] + 1; for(int j = st; j &gt;= ed; j--) &#123; a[j] = a[j -1]; b[a[j]]++; &#125; a[ind] = e[i].id; b[e[i].id] = b[e[i].id] + e[i].mve; &#125; if(e[i].mve &gt;= 0) &#123; int ind = b[e[i].id] + e[i].mve; int tmp = a[ind]; int st = b[e[i].id], ed = b[tmp] - 1; for(int j = st; j &lt;= ed; j++) &#123; a[j] = a[j + 1]; b[a[j]]--; &#125; a[ind] = e[i].id; b[e[i].id] = b[e[i].id] + e[i].mve; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; printf("%d", a[i]); if(i != n) printf(" "); else printf("\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF 题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCF</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用命令行工具sqlite3打开数据库出现乱码的解决方案]]></title>
    <url>%2F2018%2F11%2F10%2F%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7sqlite3%E6%89%93%E5%BC%80%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[数据库中存储的数据本是中文，用 sqlite3 打开之后变成乱码 方法： （1）查看 dos 的编码方式，一般为 GBK（简体中文） Android 一般的编码方式都是 UTF-8，所以要将 dos 的编码方式也改为 UTF-8 （2）借用 chcp 命令改变编码方式 chcp 65001 （将编码方式改为UTF-8） chcp 936 （将编码方式改回GBK） （3）改为 UTF-8 后重新在命令行用 sqlite3 打开数据库，格式正确]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>sqlite3</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows关机命令与tomcat的shutdown命令冲突解决方法]]></title>
    <url>%2F2018%2F11%2F10%2Fwindows%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4%E4%B8%8Etomcat%E7%9A%84shutdown%E5%91%BD%E4%BB%A4%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[配置tomcat使其能在任意目录下启动之后，输入startup回车，如图 再输入shutdown会出现如下图问题 shutdown 默认为 Windows 的关机命令，若想执行tomcat的shutdown命令，只需执行全称shutdown.bat 成功关闭]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>shutdown 冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 连接文件]]></title>
    <url>%2F2018%2F11%2F10%2FLinux-%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Linux 的连接文件有两种 symbolic link（符号连接） 类似 Windows 的快捷方式功能的文件，可以快速连接到目标文件 hard link（硬连接） 通过文件系统的 inode 连接来产生新文件名，而不是产生新文件 一、hard link在某个目录下新建一条文件名连接到某 inode 号码的关联记录 eg： 12[root@www ~]# ln /etc/crontab crontab[root@www ~]# ll -i /etc/crontab /root/crontab 连接数变为了2 两个文件的权限，属性完全一样 如果此时删除任何一个文件名，inode 和 block 都还存在，可以通过另一个文件名读取到正确的文件数据 无论使用哪个文件名进行编辑，均能进行数据的修改 hard link 只是在某个目录下的 block 多写入了一个关连数据，不增加 inode 也不耗用 block 数量 但是 hard link 是有限制的： 不能跨文件系统 不能连接到目录 二、symbolic link创建一个独立的文件，该文件会让数据的读取指向它连接的那个文件的文件名，连接文件中会写上目标文件的文件名 当源文件被删除后，连接文件也会无法打开 修改连接文件后，源文件也跟着变 eg： 12[root@www ~]# ln -s /etc/crontab crontab2[root@www ~]# ll -i /etc/crontab /root/crontab2 两个文件指向不同的 inode 号码 symbolic link 所创建的文件为一个独立的新文件，会占用 inode 和 block hard link 安全但是限制多 symbolic link 使用范围广 三、ln 命令123[root@www ~]# ln [-sf] 源文件 目标文件# -s：不加参数表示 hard link，加上 -s 表示 symbolic link# -f：如果目标文件存在，直接删除后创建 四、关于目录的连接数量新建目录时，新目录的连接数为 2，上层目录的连接数会增加 1 新建一个 /tmp/test 目录时，会有三个东西： /tmp/test /tmp/test/. /tmp/test/.. 前两个是一样的，都代表 /tmp/test 目录，而第三个代表了 /tmp 目录 所以有两个连接指向了新目录 /tmp/test，一个指向了上层目录 /tmp]]></content>
      <categories>
        <category>Linux 学习之路</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 命令与文件的查询]]></title>
    <url>%2F2018%2F11%2F10%2FLinux-%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[查询脚本文件名which（寻找“执行文件”） 12[root@www ~]# which [-a] command# -a：将所有由 PATH 目录中可以找到的命令均列出 该命令是根据 PTAH 这个环境变量所规范的路径去查询“执行文件”的文件名 查询文件名whereis（寻找特定文件） 12345[root@www ~]# whereis [-bmsu] 文件或目录名# -b：只找二进制格式的文件# -m：只找在说明文件 manual 路径下的文件# -s：只找 source 源文件# -u：查找不在上述三个选项当中的其他特殊文件 如果不加任何参数，就将所有的数据列出来 locate: 123[root@www ~]# locate [-ir] keyword# -i：忽略大小写的差异# -r：后面可接正则表达式的显示方式 locate 可以根据文件的部分名称来查找结果 locate：依据 /var/lib/mlocate 内的数据库记载，找出用户输入的关键字文件名 由于数据库基本上是默认每天更新一次，所以有时查找时需要手动更新： updatedb：读取 /etc/updatedb.conf 配置文件的设置去查找系统硬盘内的文件名，并更新 /var/lib/mlocate 内的数据库文件 find: 1234567891011121314151617181920212223242526272829303132333435[root@www ~]# [PATH] [option] [action] # 1. 时间参数共有 -atime，-ctime，-mtime# mtime n：n 天之前的一天之内更改过的文件# mtime +n：n 天之前（不含第 n 天）更改过的文件# mtime -n：n 天之前（包含第 n 天）更改过的文件# newer file：file 为一个已经存在的文件夹，列出比 file 还要新的文件名# ps：若 n 为 0，表示目前的时间 # 2. 与用户或用户组名有关的参数# -uid n：n 为用户的账号 ID# -gid n：n 为用户组名的 ID# -user name：name 为用户账号名称# -group name：name 为用户组名# -nouser：寻找文件的所有者不存在 /etc/passwd（用户的账号 ID） 的人# -nogroup：寻找文件的用户组不存在于 /etc/group（用户组名的 ID） 中的文件 # 3. 与文件权限及名称有关的参数# -name filename：查找文件名为 filename 的文件# -size [+-]SIZE：查找比 SIZE 还要大（+）或小（-）的文件。c：byte；k：1024 bytes# -type TYPE：查找文件的类型为 TYPE 的。f：一般正规文件；b，c：设备文件；d：目录；l：连接文件；s：socket；p：FIFO# -perm mode：查找文件权限刚好等于 mode 的文件# -perm -mode：查找文件权限必须要全部包括 mode 的权限的文件# -perm +mode：查找文件权限包含任一 mode 的权限的文件# 4. 其他可进行的操作# -exec command：-exec 后面可再接其他的命令来处理查找到的结果# -print：将结果打印到屏幕上，也是默认选项 # find 相关的额外命令：find / -perm +7000 -exec ls -l &#123;&#125; \;# find 的结果会被放置到 &#123;&#125; 中# find 额外命令的开始(-exec)到结束(\;)，中间的部分即是 find 命令内的额外命令 "ls -l &#123;&#125;"# ";" 在 bash 环境下有特殊意义，所以利用反斜杠来转义# find 可以利用通配符来找寻文件名 find 命令后面可以接多个目录来进行查找，find 本来就会查找子目录 find 不但可以指定查找的目录（连同子目录），还可以利用额外的参数来找到最正确的文件名]]></content>
      <categories>
        <category>Linux 学习之路</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下文件内容的查阅命令]]></title>
    <url>%2F2018%2F11%2F10%2FLinux-%E4%B8%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E6%9F%A5%E9%98%85%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[简单介绍cat：由第一行开始显示文件内容 tac：从最后一行开始显示文件内容 nl：显示的时候，顺便输出行号 more：一页一页地显示文件内容 less：与 more 类似，但可以往前查询翻页 head：只看头几行 tail：只看结尾几行 od：以二进制的方式读取文件内容 命令详解 cat 1234567[root@www ~]# cat [-AbEnTv] 文件名# -A：可以列出一些特殊字符，相当于 -vET 参数# -b：列出行号，空白行不标号# -E：显示结尾的断行字符 '$'# -n：打印行号，空白行也打印# -T：将 [Tab] 键以 '^I' 显示出来# -v：列出一些看不出来的特殊字符 tac 1[root@www ~]# tac 文件名 nl 1234567[root@www ~]# nl [-bnw] 文件名# -b a：相当于 cat -n# -b t：相当于 cat -b# -n ln：行号在屏幕的最左方显示# -n rn：行号在自己字段的最右方显示，且不加0# -n rz：行号在自己字段的最右方显示，且加0# -w &#123;数字&#125;：行号字段占用的位数 more 1[root@www ~]# more 文件名 按键功能： 空格键：向下翻一页 Enter：向下滚动一行 /string：向下查询 string :f：立刻显示出文件名以及目前显示的行数 b 或 [ctrl]-b：往回翻页，只对文件有用，对管道无用 q：离开 more 页面 less 1[root@www ~]# less 文件名 按键功能： 空格键：向下翻一页 [PageDown]：向下翻一页 [PageUp]：向上翻一页 /string：向下查询 string ?string：向上查询 string n：重复前一个查询 N：反向重复前一个查询 q：离开 less 页面 6.head 123[root@www ~]# head [-n number] 文件名# -n：显示 number 行数据，默认显示前10行# 若 number 为负数，表示显示除 后面 number 行外的所有数据 7.tail 1234[root@www ~]# tail [-n number] 文件名# -n：显示 number 行数据，默认显示最后的10行# f：持续检测该文件，直到按下 [ctrl]-c 才结束# 若 number 前有 '+' 符号，表示除了前面的 number 行之外的所有数据都将被显示 od 作用于非纯文本文件 12345678[root@www ~]# od [-t TYPE] 文件# -t：后面接各种类型的输出：# a：使用默认的字符输出# c：使用 ASCII 字符输出# d[size]：使用十进制输出，每个整数占用 size bytes# f[size]：使用浮点数输出，每个数占用 size bytes# o[size]：使用八进制输出，每个整数占用 size bytes# x[size]：使用十六进制输出，每个整数占用 size bytes 读出来的数值默认是使用非文本文件，即是十六进制的数值来显示 9.touch 修改文件时间或创建新的文件 Linux 文件有三个主要变动的时间： ① mtime（modification time） 当该文件的“内容数据”即文件的内容更改时，更新该时间 ② ctime（status time） 当该文件的“状态”即权限与属性改变时，更新该时间 ③ atime（access time） 当“该文件的内容被取用”时，更新该时间 在默认情况下，ls 命令显示出来的是该文件的 mtime，即该文件内容上次被更改的时间 123456[root@www ~]# touch [-acdmt] 文件名# -a：仅修改 atime# -c：仅修改文件的时间，若该文件不存在则不创建新文件# -d：后面接欲修改的日期而不用目前的日期，也可以用 --date="日期或时间"# -m：仅修改 mtime# -t：后面接欲修改的时间而不用目前的时间，格式：[YYMMDDhhmm] ps：两个命令之间加上 ‘;’ 表示连续命令的执行 touch 命令一般不修改 ctime touch 这个命令最常被使用的情况是 ① 创建一个空的文件 ② 将某个文件的日期修改为目前日期（mtime 与 atime）]]></content>
      <categories>
        <category>Linux 学习之路</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下的文件与目录管理]]></title>
    <url>%2F2018%2F11%2F10%2FLinux-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[查看文件与目录：ls 1234567891011121314151617181920[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称# -a：全部文件，连同隐藏文件一起列出来# -A：列出全部文件，包含隐藏文件，但不包括 '.' 和 '..'这两个目录# -d：仅列出目录本身# -f：直接列出结果而不排序（ls 默认以文件名排序）# -F：根据文件、目录等信息添加后缀，例如： *：可执行文件；/：目录；=：socket 文件；|：FIFO 文件# -h：将文件容量以人类较易读的方式列出来# -i：列出 inode 号码# -l：列出包含文件属性与权限等数据的长数据串# -n：用 UID 与 GID 替换用户与用户组的名称# -r：将排序结果反向输出# -R：连同子目录的内容一起列出来# -S：以文件容量大小排序# -t：依时间排序# --color=never：不依据文件特性给予颜色显示# --color=always：显示颜色# --color=auto：系统自行判断是否给予颜色# --full=time：以完整时间模式输出 ps：默认显示的只有非隐藏文件的文件名，以文件名进行排序及文件名代表的颜色显示 目录文件文件名都是以深蓝色显示 复制、删除与移动：cp，rm，mvcp：复制文件或目录、创建连接文件（快捷方式）、对比两文件的新旧而予以更新、复制整个目录 rm：删除文件或目录 mv：移动目录或文件、重命名操作 cp（复制文件与目录） 123456789101112[root@www ~]# cp [-adfilprsu] 源文件 目标文件[root@www ~]# cp [options] source1 source2 source3 .... directory# -a：相当于 -pdr 的意思# -d：若源文件为连接文件的属性，则复制连接文件属性而非文件本身# -f：若目标文件已经存在且无法开启，则删除后再尝试一次# -i：若目标文件已经存在时，在覆盖时会先询问操作的进行# -l：进行硬连接的连接文件创建，而非复制文件本身# -p：连同文件的属性一起复制过去# -r：递归持续复制，用于目录的复制行为# -s：复制成为符号链接文件，即快捷方式文件# -u：若目标文件比源文件旧才更新目标文件# 若源文件有两个以上，则最后一个目标文件一定要是“目录” ps：复制时，在不加任何参数的情况下，文件的某些属性/权限会改变，可以加上 -a 参数可以保证复制前后的两个文件或目录的整个数据特性完全一模一样 如果是目录则不能直接复制，要加上 -r 参数 在默认的条件中，cp 的源文件与目的文件的权限是不同的，目的文件的所有者通常会是命令操作者本身 与所有者、用户组相关的权限与属性，若是由非系统管理员操作，即使加上 -a 参数，也无法达成完整复制权限的 rm（移除文件或目录） 1234[root@www ~]# rm [-fir] 文件或目录# -f：忽略不存在的文件# -i：在删除前会询问用户是否操作# -r：递归删除，删除目录 若使用 root 身份，则默认加入 -i 参数 若不想要被询问，可以在命令前加上反斜杠 ‘\’ 若有以 ‘-‘ 开头的文件或目录，操作时要在文件名前加上本目录 ‘./‘ 即可；或者在命令与文件名之间加上 ‘ – ‘ 即可 mv（移动文件与目录，或更名） 1234[root@www ~]# mv [-fiu] source destination# -f：若目标文件已经存在，不会询问而直接覆盖# -i：若目标文件已经存在时，会询问是否覆盖# -u：若目标文件已经存在，且 source 比较新，才会更新 destination ps：如果有多个源文件或目录，则最后一个目标文件一定是“目录” 若目标文件不存在，则表示给源文件重命名 取得路径的文件名与目录名称文件名和目录名用斜线 (/) 来分辨 basename 与 dirname 两个命令分别用来查看该路径的文件名与路径名]]></content>
      <categories>
        <category>Linux 学习之路</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下目录与路径]]></title>
    <url>%2F2018%2F11%2F10%2FLinux-%E4%B8%8B%E7%9B%AE%E5%BD%95%E4%B8%8E%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[相对路径与绝对路径绝对路径：路径的写法一定由根目录 / 写起 相对路径：路径的写法不是由 / 写起 比较而言，相对路径较为方便，但是绝对路径的正确度更好 目录的相关操作下表为一些较为特殊的目录 符号 代表意义 . 此层目录 .. 上一层目录 - 前一个工作目录 - 目前用户身份”所在的主文件夹 ~账号名 该用户的主文件夹 ps：根目录的上一层(..)与根目录自己(.)是同一个目录下表为一些常见的处理目录的命令 命令 代表意义 cd 切换目录 pwd 显示当前目录 mkdir 新建一个新的目录 rmdir 删除一个空的目录 命令详解： cd（切换目录） 1234567[root@www ~]# cd [相对路径或绝对路径][root@www ~]# cd ~user# 进入 user 这个用户的主文件夹[root@www ~]# cd ~# 进入自己的主文件夹[root@www ~]# cd# 不加路径代表回到自己的主文件夹 pwd（显示目前所在的目录） 12[root@www ~]# pwd [-P]# -P：显示当前的路径，而非连接路径 /var/mail为连接路径 /var/spool/mail 为当前的路径 上图高亮表示 /var/mail 连接到 /var/spool/mail mkdir（新建新目录） 123[root@www ~]# mkdir [-mp] 目录名称# -m：配置文件案的权限# -p：将所需要的目录（包含上层目录）递归创建 默认情况下，所需要的目录要一层一层地创建，如果用 ‘-p’参数即可以直接创建，并且如果该目录本来就已经存在时，系统也不会显示错误信息 rmdir（删除空的目录） 12[root@www ~]# rmdir [-p] 目录名称# -p：连同上层空目录也一起删除 如果要将所有目录下的东西都删掉，必须使用“rm -r 目录”]]></content>
      <categories>
        <category>Linux 学习之路</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 的文件权限的概念]]></title>
    <url>%2F2018%2F11%2F10%2FLinux-%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Linux 文件属性利用 ls -al 命令查看文件 命令 ls：显示文件的文件名与相关属性 -al 参数：列出所有的文件（含隐藏文件）详细的权限与属性 -rw-r–r–. 1 root root 129 Dec 29 2013 .tcshrc 权限 连接数 文件所有者 文件所属用户组 文件大小 文件最后被修改的时间 文件名 第一列代表这个文件的类型与权限 · 第一个字符代表这个文件是“目录、文件或链接文件等” 权限：rwx。[r] 代表可读，[w] 代表可写，[x] 表示可执行(execute)，三个权限的位置不会改变 共三组权限 第一组：文件所有者的权限 第二组：同用户组的权限 第三组：其他非本用户组的权限 ps：目录与文件的权限意义并不相同 –&gt; 第二列表示有多少文件名连接到此节点 –&gt; 第三列表示这个文件（或目录）的所有者账号 –&gt; 第四列表示这个文件的所属用户组 –&gt; 第五列为这个文件的容量大小，默认单位为 B –&gt; 第六列为这个文件的创建日期或最近的修改日期 –&gt; 第七列为该文件名 改变文件属性与权限 chgrp: 改变文件所属用户组 · chown: 改变文件所有者 · chmod: 改变文件的权限 –&gt; 改变所属用户组：chgrp 前提：要被改变的组名必须在 /etc/group 文件内存在 12[root@www ~]# chgrp [-R] dirname/filename ...# -R : 进行递归的持续更改，即连同子目录下的所有文件、目录都更新成为这个用户组 改变文件所有者：chown（也可以修改用户组的名称） 前提：用户必须是已经存在与系统中的账号，也就是在 /etc/password 这个文件中有记录的用户名称 123[root@www ~]# chown [-R] 账号名称 文件或目录[root@www ~]# chown [-R] 账号名称:组名 文件或目录# -R : 进行递归的持续更改，即连同子目录下的所有文件、目录都更新成为这个用户组 chown 也可以使用 “chown user.group file”，即在所有者与用户组之间加上小数点 “.” 单纯修改所属用户组：”chown .group file” 改变权限：chmod 权限的设置方法有两种： 数字类型改变文件权限 符号类型改变文件权限 · 数字类型： r：4 w：2 x：1 12[root@www ~]# chmod [-R] xyz 文件或目录# xyz：rwx 属性数值的相加 · 符号类型： user：u group：g others：o all：a +’：加入 ‘-’：除去 ‘=’：设置 目录与文件的权限意义文件是存放实际数据的所在，目录主要的内容是记录文件名列表 文件的权限： r：可读取此文件的实际内容 w：可以编辑，新增或者是修改该文件的内容（不包含删除） x：该文件具有可以被系统执行的权限 目录的权限： r：具有读取目录结构列表的权限，查询该目录下的文件名 w：具有更改该目录结构列表的权限，即： 1. 新建文件与目录 2. 删除已经存在的文件与目录 3. 将已存在的文件或目录进行重命名 4. 转移该目录内的文件、目录位置 x：代表用户能否进入该目录成为工作目录 工作目录：当前所在的目录 能不能进入（cd）某一个目录，只与该目录的 x 权限有关 要开放目录给任何人浏览时，应该至少也要给予 r 及 x 的权限]]></content>
      <categories>
        <category>Linux 学习之路</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Linux 系统下的关机命令]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%85%B3%E4%BA%8E-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[由于 Linux 系统的特殊性，可能有很多人同时在你的主机上面工作，所以当你直接按下电源开关来关机时，其他人的数据传输也会中断，造成文件损毁，所以关于这个问题，Linux 里有一些相关的命令 将数据同步写入磁盘：sync 在 Linux 系统的默认情况下，某些已经加载内存中的数据不会直接被写回硬盘，而是先暂存在内存当中。 因此在关机之前要利用 sync 命令先将数据写入磁盘，为了防止非正常关机，可以在关机或重启之前指定多次该命令。 ps：目前的 shutdown / reboot / halt 等命令均已经在关机前进行了 sync 这个工具的调用 惯用的关机命令：shutdown shutdown 可以完成以下工作： · 自由选择关机模式：关机、重启或进入单用户操作模式 · 设置关机时间： · 自定义关机消息 · 仅发出警告信息（不关机） · 选择是否要用 fsck 检查文件系统： （fsck命令被用于检查并且试图修复文件系统中的错误。当文件系统发生错误四化，可用fsck指令尝试加以修复。） shutdown 语法规则： /sbin/shutdown [-t 秒] [-arkhncff] 时间 [警告信息] eg：1/sbin/shutdown -h 10 'I will shutdown after 10 mins' 这台机器会在十分钟之后关机，并且将字符串显示在目前登录者的屏幕前方 其他命令： 重启、关机：reboot、halt，poweroff 补充： Linux 系统中的系统运作的模式（run level）共有七种，以下先列出四种执行等级： run level 0: 关机 run level 3: 纯命令行模式 run level 5: 含有图形界面模式 run level 6: 重启 切换执行等级：init 命令 所以如下的命令也可以用于关机： 1init 0]]></content>
      <categories>
        <category>Linux 学习之路</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Linux 的 man page 说明与使用]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%85%B3%E4%BA%8E-Linux-%E7%9A%84-man-page-%E8%AF%B4%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[man 即是 manual 的简写 在命令行执行 “man [命令或数据]” 既可以出现关于该命令或数据的详细操作说明 例如，输入 “man cal” 之后会出现如下界面: 下表为在 man page 界面中的常用快捷键 按键 功能 空格 向下翻一页 [Page Down] 向下翻一页 [Page Up] 向上翻一页 [Home] 去到第一页 [End] 去到最后一页 /string 向下查询string字符串 ?string 向上查询string字符串 n, N 利用 / 或 ? 来查询字符串时，可以用 n 来继续下一个查询，用 N 来进行反向查询 q 结束 man page 环境 man page 页面第一行的 CAL(1) 中， 在查询数据的后面的数字 (1) 是有其说明意义的，下表为常见数字的意义 数字代号 代表内容 1 用户在 shell 环境中可以操作的命令或可执行文件 2 系统内核可调用的函数与工具等 3 一些常用的函数与函数库，大部分为 C 的函数库 4 设备文件的说明，通常在 /dev 下的文件 5 配置文件或者是某些文件的格式 6 游戏 7 惯例与协议等，例如 Linux 文件系统、网络协议、ASCII code 等说明 8 系统管理员可用的管理命令 9 跟 Kernel 有关的文件 man page 中的内容也分几个部分 代号 内容说明 NAME 简短的命令，数据名称说明 SYNOPSIS 简短的命令执行语法简介 DESCRIPTION 较为完整的说明 OPTIONS 针对 SYNOPSIS 部分中，有列举的所有可用的选项说明 COMMANDS 当这个程序在执行的时候，可以在此程序中执行的命令 FILES 这个程序或数据所使用或参考或连接到的某些文件 SEE ALSO 这个命令或数据有相关的其他说明 EXAMPLE 一些可以参考的范例 BUGS 是否有相关的错误 建议查询 man page 时的步骤： 先查看 NAME 的项目 仔细看一下 DESCRIPTION， 学习一些细节 查询关于 OPTIONS 的部分，了解每个选项的意义 查看 SEE ALSO 来看一下还有那些东西可以使用 查看 FILES 部分的文件来参考 查询特定命令/文件的 man page 说明文件： man -f [命令或数据]： 获取 [命令或数据] 的信息 man -k [命令或数据]： 在系统的说明文件中，只要有 [命令或数据] 这个关键字就将该说明列出来 下图执行: “man -k cal” · 补充：whatis [命令或数据] 等价于 man -f [命令或数据] apropos [命令或数据] 等价于 man -k [命令或数据] 若想要使用这两个命令，需要以 root 身份创建 whatis 数据库: [root@www ~] # makewhatis 总结自 《鸟哥的 Linux 私房菜》 基础学习篇第三版]]></content>
      <categories>
        <category>Linux 学习之路</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>man page</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vmware Workstation 虚拟机出现 The VMware Authorization Service is not running 问题的解决方案]]></title>
    <url>%2F2018%2F11%2F10%2FVmware-Workstation-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%87%BA%E7%8E%B0-The-VMware-Authorization-Service-is-not-running-%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[点击开启虚拟机后，出现了如图所示的错误提示 解决方案： 打开任务管理器，点击服务 在名称里找到 VMAuthdService 右键点击选择启动 再次开启虚拟机即可成功]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>VM 虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云Ubuntu64位云服务器搭建JavaEE环境（JDK+Tomcat+Mysql）]]></title>
    <url>%2F2018%2F11%2F10%2F%E9%98%BF%E9%87%8C%E4%BA%91Ubuntu64%E4%BD%8D%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAJavaEE%E7%8E%AF%E5%A2%83%EF%BC%88JDK-Tomcat-Mysql%EF%BC%89%2F</url>
    <content type="text"><![CDATA[要想在服务器上部署自己的项目，首先要在服务器上安装JDK， Mysql， Tomcat，下面将先讲解如何安装这三项。由于我的电脑是win10系统，所以需要下载额外的辅助软件来实现与服务器的文件交互等。 准备工作：下载PuTTy，FileZilla，jdk（请无视截图的版本，不要下载10.0版本！！！来自踩坑选手的忠告），Tomcat，mysql 打开FileZilla，将云服务器的公有IP（若是腾讯云服务器，只需要将唯一IP填入即可）填入主机栏，其他信息填好之后点击快速连接 在左侧的本地站点中找到刚刚下载的jdk及Tomcat压缩包，选中后右键点击上传 上传成功后，打开PuTTy以连接到服务器，将云服务器的公有IP填入HostName栏，Port填写22（出于安全考虑，Linux默认只开放22端口，若需要连接其他端口，可以在控制台中进行设置） 点击open后跳转到如下图所示界面，输入用户名及密码后登录成功（Linux系统不会显示密码，输好密码后直接回车即可） 查看当前目录下的文件，即我们刚刚用FileFilla上传成功的压缩包 在root目录下新建一个javaee文件夹输入命令： 1tar zxvf jdk-10.0.2_linux-x64_bin.tar.gz -C javaee 从而将jdk压缩包解压至javaee目录下 注：想要给文件重命名一定要在进行配置之前改！！！ 本弱鸡在配置之后对文件进行了重命名，并且忘了改配置文件，卡了一个小时，生无可恋心态已崩 输入命令： 1vi /etc/profile 进入配置文件开始配置java环境变量 进入下图界面后，按下键盘上的’i’进行编辑，并在文件的最后追加如下配置，输入完成后按下Esc键，再输入“:wq!”保存文件并退出（具体参照Linux中VI编辑器的使用） 1234export JAVA_HOME=/root/javaee/jdk-10.0.2export JRE_HOME=/root/javaee/jdk-10.0.2/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH 输入两条命令，若出现下图所示提示则配置成功 12source /etc/profilejava -version 接下来进行Tomcat的安装配置将其解压至javaee文件夹下 进入Tomcat文件夹下，用 VI 编辑器打开 catalina.sh 1vi catalina.sh 在该文件的开头添加如下配置 12export JAVA_HOME=/root/javaee/jdk-10.0.2export JRE_HOME=/root/javaee/jdk-10.0.2/jre 退出后在Tomcat的bin目录下如下输入命令，显示Tomcat已成功启动 1./startup.sh 此时，从浏览器可以成功访问Tomcat页面（访问之前请确认是否打开防火墙或已按照文章最后附一的内容将8080端口添加进安全组） 接下来开始安装mysql由于mysql版本及原Linux系统存在残留mysql的问题，搞了一下午心态已崩，重新装了镜像，用了大佬们常用的更简便的方法在终端窗口中输入以下三条命令 123sudo apt-get install mysql-serversudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev 安装完成后，测试是否安装成功，输入登录指令及密码，密码即安装 mysql-server 时设置的密码，若出现下图所示情况，则安装成功，此时，可以查看与操作数据库中的数据表 至此，jdk， tomcat， mysql 全部安装成功 附一：开放其他可用端口：云服务器管理控制台-&gt;管理-&gt;本实例安全组-&gt;配置规则-&gt;添加安全组规则之后添加所需要访问的端口即可 下面是一些常用端口]]></content>
      <categories>
        <category>常用配置</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>云服务器</tag>
        <tag>JavaEE环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10环境配置Tomcat（9.0版本）]]></title>
    <url>%2F2018%2F11%2F10%2FWin10%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AETomcat%EF%BC%889-0%E7%89%88%E6%9C%AC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[由于博主今天中午脑子一抽重装了系统，电脑上所有的东西都被我干掉了，一朝回到解放前，被各种配置折磨了一下午，所以记录一下重装系统之后艰难的配置路线，以防以后再次冲动 首先去官网下载tomcat的压缩包并解压 然后去电脑的属性配置环境变量 这里需要配置两处：CATALINA_HOME 与 Path CATALINA_HOME的变量值是tomcat的根目录，如下图 其后，点击编辑Path新增一条：%CATALINA_HOME%\bin，随后一路确定 随后打开cmd，输入startup 此时会弹出另一个窗口 当出现如下图红框中日志时，打开浏览器，输入：http://localhost:8080/ 出现如下页面，则tomcat配置成功]]></content>
      <categories>
        <category>常用配置</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vi编辑器的方向键无法使用的解决方法]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%85%B3%E4%BA%8Evi%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%96%B9%E5%90%91%E9%94%AE%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对于刚开始用Linux编程的小白来说，vi是最基础的编辑器，可以用vi写出一些简单程序 而在vi中按下方向键或退格键会出现奇奇怪怪的字母 这种情况是由于vi不支持方向键和退格键，这些功能是由vim支持的，所以只需要重新下载vim即可 打开终端，依次输入以下命令: sudo apt-get remove vim-common sudo apt-get install vim 再次打开vi编辑器之后就可以正常使用方向键及退格键]]></content>
      <categories>
        <category>Linux 学习之路</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot + WebSocket 学习笔记]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[WebSocket 协议是基于 TCP 的一种新的网络协议。它实现了浏览器与服务器全双工通信–允许服务器主动发送信息给客户端，实现客户端之间的交互。WebSocket 是从 Html5 中演化而出，但是相对于 HTTP的 不支持持久性连接，WebSocket 是一个持久化的协议。 实现 WebSocket 协议后，服务端只要与客户端进行过一次连接之后，就不需要再次连接，并且可以一直向客户端发送信息，即服务端主动向客户端发送消息。由于 WebSocket 协议在握手阶段采用了 HTTP 协议，能通过各种 HTTP 代理服务器。目前并不是所有的浏览器都实现了 WebSocket，对于没有实现该协议的浏览器，还需要通过 STOMP 协议来完成兼容。要想在 Spring Boot 项目中应用 WebSocket，首先要在 pom.xml 中加入依赖 12345678910111213 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; &lt;!-- Spring security 主要为了点对点时的安全登录，可以不使用 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 下面开发一个简单的 WebSocket 服务· 创建 java 配置文件 1234567891011121314import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter; @Configurationpublic class WebSocketConfig &#123; //创建服务器端点 @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125; &#125; · 定义 WebSocket 服务端站点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106 import org.springframework.stereotype.Service; import javax.websocket.*;import javax.websocket.server.ServerEndpoint;import java.io.IOException;import java.util.concurrent.CopyOnWriteArrayList; //创建 WebSocket 服务站点， 参数: 请求地址@ServerEndpoint("/ws")@Servicepublic class WebSocketServiceImpl &#123; //用来记录当前在线连接数，应该设置为线程安全 private static int onlineCount = 0; //保证线程安全的 WebSocketServiceImpl 对象的 Set private static CopyOnWriteArrayList&lt;WebSocketServiceImpl&gt; webSocketServices = new CopyOnWriteArrayList&lt;&gt;(); //与客户端的连接会话 private Session session; public Session getSession() &#123; return session; &#125; /** * 连接建立成功调用的方法 * @param session */ @OnOpen public void onOpen(Session session)&#123; this.session = session; webSocketServices.add(this); addOnlineCount(); System.out.println("有新连接加入， 当前在线人数: " + getOnlineCount()); try &#123; sendMessage("有新连接加入了"); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; /** * 连接关闭调用的方法 */ @OnClose public void onClose()&#123; webSocketServices.remove(this); subOnlineCount(); System.out.println("有一个连接关闭， 当前在线人数: " + getOnlineCount()); &#125; /** * 收到客户端消息后调用的方法 * @param message 客户端发送来的消息 * @param session */ @OnMessage public void onMessage(String message, Session session)&#123; System.out.println("收到客户端消息: " + message); //群发消息 for(WebSocketServiceImpl service : webSocketServices)&#123; try &#123; //获取当前用户名称 String userName = service.getSession().getUserPrincipal().getName(); System.out.println(userName); service.sendMessage(message); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** *发生错误时调用 */ @OnError public void onError(Session session, Throwable error)&#123; System.out.println("发生错误"); error.printStackTrace(); &#125; /** * 发送消息 * @param message 客户端消息 * @throws IOException */ private void sendMessage(String message) throws IOException&#123; this.session.getBasicRemote().sendText(message); &#125; //返回在线数 private static synchronized int getOnlineCount()&#123; return onlineCount; &#125; //增加连接人数 private static synchronized void addOnlineCount()&#123; WebSocketServiceImpl.onlineCount++; &#125; //减少连接人数 private static synchronized void subOnlineCount()&#123; WebSocketServiceImpl.onlineCount--; &#125; &#125; · WebSocket 页面（websocket.jsp） 12345678910111213141516171819202122&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;My WebSocket&lt;/title&gt; &lt;script type="text/javascript" src="/jquery-1.8.3.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/websocket.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 测试 WebSocket 站点 &lt;br&gt; &lt;input id = "message" type="text"&gt; &lt;button onclick="sendMessage()"&gt;发送消息&lt;/button&gt; &lt;button onclick="closeWebSocket()"&gt;关闭 WebSocket 连接&lt;/button&gt; &lt;div id="context"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; · WebSocket 客户端脚本(websocket.js) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var websocket = null;//判断当前浏览器是否支持 WebSocketif('WebSocket' in window)&#123; //创建 WebSocket 对象，连接服务器端点 websocket = new WebSocket("ws://localhost:8080/ws");&#125;else&#123; alert('Not support webSocket')&#125; //连接发生错误的回调方法websocket.onerror = function () &#123; appendMessage("error");&#125;; //连接成功建立的回调方法websocket.onopen = function (event) &#123; appendMessage("open");&#125;; //接收到消息的回调方法websocket.onmessage = function (event) &#123; appendMessage(event.data);&#125;; //连接关闭的回调方法websocket.onclose = function () &#123; appendMessage("close");&#125;; //监听窗口关闭事件，当窗口关闭时，主动关闭 websocket 连接//防止连接还没断开就关闭窗口， server 端会抛异常window.onbeforeunload = function () &#123; websocket.close();&#125;; //将消息显示在网页上function appendMessage(message) &#123; var context = $("#context").html() + "&lt;br/&gt;" + message; $("#context").html(context);&#125;; //关闭连接function closeWebSocket() &#123; websocket.close();&#125; //发送消息function sendMessage() &#123; var message = $("#message").val(); websocket.send(message);&#125; · WebSocket 控制器 123456789101112131415 import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; @RequestMapping(value = "/websocket")@RestControllerpublic class WebSocketController &#123; @GetMapping(value = "/index") public String websocket()&#123; return "websocket"; &#125; &#125; 启动控制器，跳转去客户端，打开两个页面发送消息]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 的 jsp文件中无法引入静态资源文件（js,css等文件）]]></title>
    <url>%2F2018%2F11%2F10%2Fjsp%E6%96%87%E4%BB%B6%E4%B8%AD%E6%97%A0%E6%B3%95%E5%BC%95%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%88js-css%E7%AD%89%E6%96%87%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[错误（net::ERR_ABORTED 404）报错信息： 报错时我的jsp文件中引入路径： 12&lt;script type="text/javascript" src="../../sources/static/jquery-1.8.3.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../../sources/static/websocket.js"&gt;&lt;/script&gt; 正确路径：删除掉static及其之前的全部路径 12&lt;script type="text/javascript" src="/jquery-1.8.3.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/websocket.js"&gt;&lt;/script&gt; 原因：在未对 application.properties 文件进行配置时，Spring Boot 默认从resources目录的static目录查找资源文件，所以 src 目录中无需加入 static 及其之前的路径 若想对资源路径进行配置，可以在 application.properties 配置文件中加入下面的配置 1spring.mvc.static-path-pattern=/**]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 创建 Maven + Spring Boot 项目并打包（jar 包）上传至 Linux 服务器上运行]]></title>
    <url>%2F2018%2F11%2F08%2FIDEA-%E5%88%9B%E5%BB%BA-Maven-Spring-Boot-%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%89%93%E5%8C%85%EF%BC%88jar-%E5%8C%85%EF%BC%89%E4%B8%8A%E4%BC%A0%E8%87%B3-Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[首先打开 IDEA 并点击 New Project，进入如下页面 点击 Maven，选中”Create from archetype” 选择 quickstart 然后 next GroupId 为 package 名，ArtifactId 为项目名称，点击 next 不用改动，直接 next（有教程说要添加一个什么东西来防止下载速度过慢，笔者用了另一种办法，后面描述，所以这里不需要改动） 这个页面也不用改动，直接 finish 进入项目后，先去修改 pom.xml 文件，首先添加图中圈出的三处（version 请视自己具体所用版本而定） 接着在 dependencies 标签内添加以下配置 12345678910111213141516171819202122232425262728293031323334&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 然后将 build 标签改为下图所示 此时右下角可能会出现下图所示的小窗口，并且一直停滞，这就是上面所提到的问题，此时，下载 archetype-catalog.xml 文件，并将其放在 C 盘 .m2 文件的根目录下 关闭项目后再次打开发现下载速度明显提升并且很快结束下载 然后在 main 目录下创建文件夹 resources 并且设置为 Resources Root 在 Resources 目录下创建 application.properties 文件并填写有关数据库的配置（这里配置端口是因为笔者的服务器中8080端口已被占用，所以使用了另外的端口） 123456spring.datasource.url=jdbc:mysql://localhost:3306/basketball?serverTimezone=GMT&amp;allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=root`# 设置 tomcat 端口为 8880server.port=8880 此时，正式开始代码部分 在 com.hello 包下创建 controller 包， 并在其下创建 HelloController 类 在其中编写代码 1234567891011121314package com.hello.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;@RestControllerpublic class HelloController &#123; @GetMapping(value = "/hello") public Map&lt;String, Object&gt; hello()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("hello", "Hello world!"); return map; &#125;&#125; 打开 App.java 为 App 添加注解 @SpringBootApplication，并在 Main 函数中运行 SpringApplication.run(App.class, args); 1234567891011package com.hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class App&#123; public static void main( String[] args ) &#123; SpringApplication.run(App.class, args); &#125;&#125; 此时，代码部分已经结束，开始进行下一步，按图中箭头所示进行操作 Name 可以自己取，Main class 选取添加了 @SpringBootApplication 注解的 App 类，直接 ok 运行后用 Postman（Get 方法也可以在浏览器地址栏直接访问） 访问 url，成功返回 接下来，将项目打包为 jar 包并上传至服务器 在 View 中的 Tool Windows 找到Maven Projects 并打开 先双击 clean （如果是第一次则不需要） 然后双击 install 此时，打包成功 在 target 目录下可以看到生成的 .jar 文件 然后利用 FileZilla 将 jar 包上传至服务器文件 利用 PuTTY 登录云服务器，进入到所上传 jar 包的目录下 运行 jar 包有两种方式 1234# 直接运行，当该窗口关闭时程序终止java -jar xxxx.jar# 持久运行，即便窗口关闭程序也不会终止nohup java -jar xxxx.jar &amp; 这里运用第二种方法 此时 hello.jar 已在运行，并且将日志存放在 nohup.out 文件中 12# 查看日志， Ctrl + C 退出查看tail -100f nohup.out 此时再次通过 Postman 访问路径，可以成功得到返回结果 若想关闭 jar 包的运行，首先要查看当前 jar 包的进程号，然后利用 kill 命令杀死进程 1234# 查看 xxxx.jar 运行的进程号ps -ef|grep xxxx.jar# 关闭进程号为 xx 的进程 kill xx]]></content>
      <categories>
        <category>JavaEE 学习之路</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Maven</tag>
        <tag>Linux 云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 项目在本地可以成功访问但是在服务器上无法访问 Controller 方法解决办法]]></title>
    <url>%2F2018%2F11%2F08%2FSpring-Boot-%E9%A1%B9%E7%9B%AE%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%8F%AF%E4%BB%A5%E6%88%90%E5%8A%9F%E8%AE%BF%E9%97%AE%E4%BD%86%E6%98%AF%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE-Controller-%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这是一篇记录自己失了智的博客 晚上写了一个小 Demo 来测试在云服务器上同时运行两个 jar 包的情况 两个项目的端口分别为 8080 和 8880 以 8880 为端口的 Demo 在本地成功运行并且访问到了 Controller 中的方法 在服务器运行后从日志中也可以确定成功完成了映射 但是就是没有办法通过服务器的 url 进行访问 百度了 N 久都没有找到和我相同的问题，直到被大佬指点之后才意识到，我的服务器的安全组中没有添加 8880 这个端口，换言之，请求被防火墙拦截了。去将 8880 添加到安全组后，再次访问，成功返回 “Hello world!”]]></content>
      <categories>
        <category>踩坑之路</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>无法访问 Controller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

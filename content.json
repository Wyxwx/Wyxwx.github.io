{"meta":{"title":"Wency","subtitle":null,"description":"心若无恙, 奈我何其","author":"Wyx_wx","url":"https://wyxwx.github.io"},"pages":[{"title":"","date":"2018-11-08T17:03:31.805Z","updated":"2018-11-08T17:03:31.688Z","comments":true,"path":"404.html","permalink":"https://wyxwx.github.io/404.html","excerpt":"","text":""},{"title":"404","date":"2018-11-06T14:28:28.000Z","updated":"2018-11-07T14:31:59.690Z","comments":true,"path":"404/index.html","permalink":"https://wyxwx.github.io/404/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-11-06T15:18:06.000Z","updated":"2018-11-08T17:23:41.923Z","comments":true,"path":"about/index.html","permalink":"https://wyxwx.github.io/about/index.html","excerpt":"","text":"这里大三在校生一枚 目前专攻于 Java 后台 对于算法略有涉猎 文章从本人 CSDN 陆续搬运中 了解详情请致邮 791989352@qq.com"},{"title":"分类","date":"2018-11-07T13:44:14.000Z","updated":"2018-11-07T15:02:15.540Z","comments":true,"path":"categories/index.html","permalink":"https://wyxwx.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2018-11-06T14:27:59.000Z","updated":"2018-11-07T14:31:37.535Z","comments":true,"path":"search/index.html","permalink":"https://wyxwx.github.io/search/index.html","excerpt":"","text":""},{"title":"search","date":"2018-11-06T14:27:59.000Z","updated":"2018-11-06T15:06:41.490Z","comments":true,"path":"tag/index.html","permalink":"https://wyxwx.github.io/tag/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-08T16:54:32.000Z","updated":"2018-11-08T16:54:58.926Z","comments":true,"path":"tags/index.html","permalink":"https://wyxwx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【HDU 1495】 非常可乐 (bfs + 模拟)","slug":"【HDU-1495】-非常可乐-bfs-模拟","date":"2018-11-10T18:04:24.000Z","updated":"2018-11-10T18:06:30.594Z","comments":true,"path":"2018/11/11/【HDU-1495】-非常可乐-bfs-模拟/","link":"","permalink":"https://wyxwx.github.io/2018/11/11/【HDU-1495】-非常可乐-bfs-模拟/","excerpt":"大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。","text":"大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 Input三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 Output如果能平分的话请输出最少要倒的次数，否则输出”NO”。 Sample Input7 4 34 1 30 0 0Sample OutputNO3 据大佬说这道题除了模拟还有一种解法，依据一个数学公式，感兴趣可以自己看一下, 代码长度远比模拟短 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188/* bfs + 模拟 开始时：S杯满， M， N杯为空， 最终S杯与max(M, N)杯分别装有S杯的一半 模拟有六种情况，S -&gt; M, S -&gt; N, M -&gt; S, M -&gt; N, N -&gt; S, N -&gt; M， 按此顺序倒可乐 如果之前未判断此种情况，加入队列切标记已遍历*/ #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 105;int s, m, n, vis[MX][MX];struct Node&#123; int x, y, s, step;&#125;;int bfs()&#123; queue&lt;Node&gt; q; Node now; now.x = 0; now.y = 0; now.s = s; now.step = 0; q.push(now); vis[m][n] = 1; while(!q.empty()) &#123; now = q.front(); Node node; q.pop(); if(now.x == s / 2 &amp;&amp; now.s == s / 2) &#123; return now.step; &#125; if(now.s != 0 &amp;&amp; now.x != m) &#123; int x = m - now.x; if(now.s &gt;= x) &#123; node.s = now.s - x; node.x = m; &#125; else &#123; node.s = 0; node.x = now.x + now.s; &#125; node.y = now.y; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; if(now.s != 0 &amp;&amp; now.y != n) &#123; int x = n - now.y; if(now.s &gt;= x) &#123; node.s = now.s - x; node.y = n; &#125; else &#123; node.s = 0; node.y = now.y + now.s; &#125; node.x = now.x; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; if(now.x != 0 &amp;&amp; now.s != s) &#123; int x = s - now.s; if(now.x &gt;= x) &#123; node.x = now.x - x; node.s = s; &#125; else &#123; node.x = 0; node.s = now.s + now.x; &#125; node.y = now.y; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; if(now.x != 0 &amp;&amp; now.y != n) &#123; int x = n - now.y; if(now.x &gt;= x) &#123; node.x = now.x - x; node.y = n; &#125; else &#123; node.x = 0; node.y = now.y + now.x; &#125; node.s = now.s; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; if(now.y != 0 &amp;&amp; now.s != s) &#123; int x = s - now.s; if(now.y &gt;= x) &#123; node.y = now.y - x; node.s = s; &#125; else &#123; node.y = 0; node.s = now.s + now.y; &#125; node.x = now.x; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; if(now.y != 0 &amp;&amp; now.x != m) &#123; int x = m - now.x; if(now.y &gt;= x) &#123; node.y = now.y - x; node.x = m; &#125; else &#123; node.y = 0; node.x = now.x + now.y; &#125; node.s = now.s; node.step = now.step + 1; if(vis[node.x][node.y] == 0) &#123; vis[node.x][node.y] = 1; q.push(node); &#125; &#125; &#125; return -1;&#125;int main()&#123; while(scanf(\"%d%d%d\", &amp;s, &amp;m, &amp;n) != EOF &amp;&amp; (s + m + n)) &#123; memset(vis, 0, sizeof(vis)); if(s &amp; 1) &#123; printf(\"NO\\n\"); continue; &#125; if(m &lt; n) swap(m, n); int x = bfs(); if(x != -1) printf(\"%d\\n\", x); else printf(\"NO\\n\"); &#125; return 0;&#125;","categories":[{"name":"ACM 题解","slug":"ACM-题解","permalink":"https://wyxwx.github.io/categories/ACM-题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"},{"name":"模拟","slug":"模拟","permalink":"https://wyxwx.github.io/tags/模拟/"},{"name":"bfs","slug":"bfs","permalink":"https://wyxwx.github.io/tags/bfs/"},{"name":"HDU","slug":"HDU","permalink":"https://wyxwx.github.io/tags/HDU/"}]},{"title":"【POJ 3414】 Pots (bfs + 模拟 + 路径记录)","slug":"【POJ-3414】-Pots-bfs-模拟-路径记录","date":"2018-11-10T17:53:09.000Z","updated":"2018-11-10T18:03:53.784Z","comments":true,"path":"2018/11/11/【POJ-3414】-Pots-bfs-模拟-路径记录/","link":"","permalink":"https://wyxwx.github.io/2018/11/11/【POJ-3414】-Pots-bfs-模拟-路径记录/","excerpt":"You are given two pots, having the volume of A and B liters respectively. The following operations can be performed: FILL(i) fill the pot i (1 ≤ i ≤ 2) from the tap;DROP(i) empty the pot i to the drain;POUR(i,j) pour from pot i to pot j; after this operation either the pot jis full (and there may be some water left in the pot i), or the pot i is empty (and all its contents have been moved to the pot j).Write a program to find the shortest possible sequence of these operations that will yield exactly C liters of water in one of the pots.","text":"You are given two pots, having the volume of A and B liters respectively. The following operations can be performed: FILL(i) fill the pot i (1 ≤ i ≤ 2) from the tap;DROP(i) empty the pot i to the drain;POUR(i,j) pour from pot i to pot j; after this operation either the pot jis full (and there may be some water left in the pot i), or the pot i is empty (and all its contents have been moved to the pot j).Write a program to find the shortest possible sequence of these operations that will yield exactly C liters of water in one of the pots. InputOn the first and only line are the numbers A, B, and C. These are all integers in the range from 1 to 100 and C≤max(A,B). OutputThe first line of the output must contain the length of the sequence of operations K. The following K lines must each describe one operation. If there are several sequences of minimal length, output any one of them. If the desired result can’t be achieved, the first and only line of the file must contain the word ‘impossible’. Sample Input3 5 4Sample Output6FILL(2)POUR(2,1)DROP(1)POUR(2,1)FILL(2)POUR(2,1) 题目大意：给出容积为A， B的两个容器，初始时容器内水的体积都为0，有三种操作： FILL(i)：将 i 倒满水。 DROP(i)：将 i 的水倒出。 POUR(i,j)： 将 i 的水倒入 j 中，直至 i 为空，或 j 已满。 问当A，B中有一个容器装水量为C时进行的操作数，并打印需要的操作 解题思路：模拟杯子中水交互的六种状态，在Node中设置变量分别记录进行的操作类型，是否为头节点，再设一个Node数组记录路径 具体见代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195/* bfs + 模拟 + 路径记录*/ #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;const int MX = 105;int A, B, C, flag[MX][MX]; //flag: 判断是否进行过该状态string s;struct Node&#123; int a, b; int s, sign, par; //s: 操作数 sign: 判断进行的操作 par: 父节点存在与否&#125;;Node path[MX][MX]; //记录路径void print(Node n)&#123; vector&lt;Node&gt; v; while(true) &#123; v.push_back(n); //将路径压入vector中 if(n.par == 0) //不存在父节点 break; n = path[n.a][n.b]; &#125; for(int i = v.size() - 1; i &gt;= 0; i--) &#123; if(v[i].sign == 1) &#123; printf(\"POUR(1,2)\\n\"); &#125; else if(v[i].sign == 2) &#123; printf(\"FILL(1)\\n\"); &#125; else if(v[i].sign == 3) &#123; printf(\"DROP(1)\\n\"); &#125; else if(v[i].sign == 4) &#123; printf(\"POUR(2,1)\\n\"); &#125; else if(v[i].sign == 5) &#123; printf(\"FILL(2)\\n\"); &#125; else &#123; printf(\"DROP(2)\\n\"); &#125; &#125;&#125;void bfs()&#123; memset(flag, 0, sizeof(flag)); queue&lt;Node&gt; q; Node now; now.a = 0; now.b = 0; now.par = -1; //不存在父节点 now.s = 0; now.sign = 0; flag[0][0] = 1; //节点已使用过 q.push(now); while(!q.empty()) &#123; now = q.front(); if(now.a == C || now.b == C) //任一杯子中的水等于C &#123; printf(\"%d\\n\", now.s); print(now); return ; &#125; Node node; q.pop(); if(now.b != B &amp;&amp; now.a) //POUR(now.a, now.b) &#123; int x = B - now.b; if(now.a &gt;= x) &#123; node.b = B; node.a = now.a - x; &#125; else &#123; node.a = 0; node.b = now.b + now.a; &#125; node.s = now.s + 1; //操作数增加 node.sign = 1; //标记操作类型 if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; //上一节点是now flag[node.a][node.b] = 1; //标记已使用 node.par = now.par + 1; //父节点数增加(若为第一个节点，此时par已为0) q.push(node); &#125; &#125; if(now.a != A) //FILL(now.a) &#123; node.a = A; node.b = now.b; node.s = now.s + 1; node.sign = 2; if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; flag[node.a][node.b] = 1; node.par = now.par + 1; q.push(node); &#125; &#125; if(now.a) //DROP(now.a) &#123; node.a = 0; node.b = now.b; node.s = now.s + 1; node.sign = 3; if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; flag[node.a][node.b] = 1; node.par = now.par + 1; q.push(node); &#125; &#125; if(now.b &amp;&amp; now.a != A) //POUR(now.b, now.a) &#123; int x = A - now.a; if(now.b &gt;= x) &#123; node.b = now.b - x; node.a = A; &#125; else &#123; node.b = 0; node.a = now.a + now.b; &#125; node.s = now.s + 1; node.sign = 4; if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; flag[node.a][node.b] = 1; node.par = now.par + 1; q.push(node); &#125; &#125; if(now.b != B) //FILL(now.b) &#123; node.b = B; node.a = now.a; node.s = now.s + 1; node.sign = 5; if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; flag[node.a][node.b] = 1; node.par = now.par + 1; q.push(node); &#125; &#125; if(now.b) //DROP(now.b) &#123; node.b = 0; node.a = now.a; node.s = now.s + 1; node.sign = 6; if(!flag[node.a][node.b]) &#123; path[node.a][node.b] = now; flag[node.a][node.b] = 1; node.par = now.par + 1; q.push(node); &#125; &#125; &#125; printf(\"impossible\\n\");&#125;int main()&#123; while(scanf(\"%d%d%d\", &amp;A, &amp;B, &amp;C) != EOF) &#123; bfs(); &#125; return 0;&#125;","categories":[{"name":"ACM 题解","slug":"ACM-题解","permalink":"https://wyxwx.github.io/categories/ACM-题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"},{"name":"模拟","slug":"模拟","permalink":"https://wyxwx.github.io/tags/模拟/"},{"name":"bfs","slug":"bfs","permalink":"https://wyxwx.github.io/tags/bfs/"},{"name":"POJ","slug":"POJ","permalink":"https://wyxwx.github.io/tags/POJ/"}]},{"title":"【POJ 1088】滑雪","slug":"【POJ-1088】滑雪","date":"2018-11-10T17:43:52.000Z","updated":"2018-11-10T17:52:47.982Z","comments":true,"path":"2018/11/11/【POJ-1088】滑雪/","link":"","permalink":"https://wyxwx.github.io/2018/11/11/【POJ-1088】滑雪/","excerpt":"Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。","text":"Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。 Input输入的第一行表示区域的行数R和列数C(1 &lt;= R,C &lt;= 100)。下面是R行，每行有C个整数，代表高度h，0&lt;=h&lt;=10000。Output输出最长区域的长度。Sample Input5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9Sample Output25 解题思路：dp， 每次遍历四种状态， 选择比当前低的地方走 dp[i][j] : 从i， j 位置出发的最长路径 dp[i][j] = max(dp[i][j], dp[newI][newJ] + 1); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MXC = 105;const int MXH = 1e4 + 5;int s[MXC][MXC];int dp[MXC][MXC];int r, c;int fx[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;int DP(int x, int y)&#123; if(dp[x][y] != 0) return dp[x][y]; int nx, ny; int mx = 1; for(int i = 0; i &lt; 4; i++) &#123; nx = x + fx[i][0]; ny = y + fx[i][1]; if(s[x][y] &gt; s[nx][ny] &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; r &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; c) &#123; mx = max(mx, DP(nx, ny) + 1); &#125; &#125; return dp[x][y] = mx;&#125;int main()&#123; while(scanf(\"%d%d\", &amp;r, &amp;c) != EOF) &#123; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; r; i++) &#123; for(int j = 0; j &lt; c; j++) &#123; scanf(\"%d\", &amp;s[i][j]); &#125; &#125; for(int i = 0; i &lt; r; i++) &#123; for(int j = 0; j &lt; c; j++) &#123; if(dp[i][j] == 0) DP(i, j); &#125; &#125; int ans = 0; for(int i = 0; i &lt; r; i++) &#123; for(int j = 0; j &lt; c; j++) &#123; ans = max(ans, dp[i][j]); &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[{"name":"ACM 题解","slug":"ACM-题解","permalink":"https://wyxwx.github.io/categories/ACM-题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"},{"name":"POJ","slug":"POJ","permalink":"https://wyxwx.github.io/tags/POJ/"},{"name":"dp","slug":"dp","permalink":"https://wyxwx.github.io/tags/dp/"}]},{"title":"关于node下载的模块无法使用（Cannot find module）解决方法","slug":"关于node下载的模块无法使用（Cannot-find-module）解决方法","date":"2018-11-10T17:35:18.000Z","updated":"2018-11-10T17:42:13.412Z","comments":true,"path":"2018/11/11/关于node下载的模块无法使用（Cannot-find-module）解决方法/","link":"","permalink":"https://wyxwx.github.io/2018/11/11/关于node下载的模块无法使用（Cannot-find-module）解决方法/","excerpt":"这个问题困扰了我很久，也按百度上各式各样的方法试了没有用 今天和导师远程，知道了问题在哪，我用webstorm编译器进行演示 若使用其他编译器，可按下述原理进行修改 原理(在当前工程文件夹下要有一个package.json文件，并在此工程下安装npm模块，安装后会出现一个node_modules文件夹，里面包含着下载的模块)","text":"这个问题困扰了我很久，也按百度上各式各样的方法试了没有用 今天和导师远程，知道了问题在哪，我用webstorm编译器进行演示 若使用其他编译器，可按下述原理进行修改 原理(在当前工程文件夹下要有一个package.json文件，并在此工程下安装npm模块，安装后会出现一个node_modules文件夹，里面包含着下载的模块) 过程： 测试代码： 此时运行，结果如下图， 显示：Cannot find module 在Terminal面板对colors模块进行安装会出现如下错误： 此时，继续在该面板，输入 npm init 按下回车进行初始化，效果如图： 此时一直点击回车，直到出现” Is this ok? (yes) ” 输入yes 回车 此时，继续安装colors模块，提示安装成功： 重新运行程序，此时成功输出：","categories":[{"name":"踩坑之路","slug":"踩坑之路","permalink":"https://wyxwx.github.io/categories/踩坑之路/"}],"tags":[{"name":"node","slug":"node","permalink":"https://wyxwx.github.io/tags/node/"}]},{"title":"【HDU 2553】 N皇后问题","slug":"【HDU-2553】-N皇后问题","date":"2018-11-10T17:31:37.000Z","updated":"2018-11-10T17:32:46.917Z","comments":true,"path":"2018/11/11/【HDU-2553】-N皇后问题/","link":"","permalink":"https://wyxwx.github.io/2018/11/11/【HDU-2553】-N皇后问题/","excerpt":"在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。","text":"在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 Input共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 Output共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 Sample Input1850Sample Output19210 N皇后问题比较经典了，在紫书上也有讲，但是交上去总是TLE，后来发现是记录上出了问题，在计算答案之前先循环计算1-10的答案并记录在一个数组中，输入n之后直接调用数组答案输出即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int tot, n, c[11];void search_(int cur, int k)&#123; if(cur == k) tot++; else&#123; for(int i = 0; i &lt; k; i++)&#123; int ok = 1; c[cur] = i; for(int j = 0; j &lt; cur; j++) &#123; if(c[cur] == c[j] || cur - c[cur] == j - c[j] || cur + c[cur] == j + c[j]) &#123; ok = 0; break; &#125; &#125; if(ok) search_(cur + 1, k); &#125; &#125;&#125;int main()&#123; int oldAns[11]; memset(oldAns, 0, sizeof(oldAns)); for(int i = 0; i &lt;= 10; i++) &#123; tot = 0; search_(0, i); oldAns[i] = tot; &#125; while(scanf(\"%d\", &amp;n) != EOF &amp;&amp; n) &#123; cout&lt;&lt;oldAns[n]&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM 题解","slug":"ACM-题解","permalink":"https://wyxwx.github.io/categories/ACM-题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"},{"name":"HDU","slug":"HDU","permalink":"https://wyxwx.github.io/tags/HDU/"}]},{"title":"判断素数的算法","slug":"判断素数的算法","date":"2018-11-10T17:18:50.000Z","updated":"2018-11-10T17:25:27.806Z","comments":true,"path":"2018/11/11/判断素数的算法/","link":"","permalink":"https://wyxwx.github.io/2018/11/11/判断素数的算法/","excerpt":"1.根据定义求，时间复杂度为：O(n) 判断除了1和它本身外是否还有其他因数","text":"1.根据定义求，时间复杂度为：O(n) 判断除了1和它本身外是否还有其他因数 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 1e6 + 5;int n;/** 根据定义求*/string is_Prime(int x)&#123; if(x == 1) return \"no\"; bool flag = true; for(int i = 2; i &lt; x; i++) &#123; if(x % i == 0) &#123; flag = false; break; &#125; &#125; return flag ? \"yes\" : \"no\";&#125;int main()&#123; while(scanf(\"%d\", &amp;n) != EOF) &#123; printf(\"Is %d is a prime?\\t\", n); cout&lt;&lt;is_Prime(n)&lt;&lt;endl; &#125; return 0;&#125; 2.若该数为偶数，则必定不是素数至少可以被2整除且2为素数，时间复杂度O(n / 2) 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 1e6 + 5;int n;/** 去掉偶数*/string is_Prime(int x)&#123; if(x == 1) return \"no\"; for(int i = 3; i &lt; x; i += 2) &#123; if(x % i == 0) &#123; return \"no\"; &#125; &#125; return \"yes\";&#125;int main()&#123; while(scanf(\"%d\", &amp;n) != EOF) &#123; printf(\"Is %d is a prime?\\t\", n); cout&lt;&lt;is_Prime(n)&lt;&lt;endl; &#125; return 0;&#125; 3.若要求n是否为素数，可以求在2-sqrt(n)中是否存在n的约数，若是不存在，在sqrt(n)-n - 1中也必定没有它的约数，时间复杂度O(sqrt(n)/2) 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MX = 1e6 + 5;int n;/** sqrt(n)*/string is_Prime(int x)&#123; if(x == 1) return \"no\"; int m = sqrt(x); for(int i = 2; i &lt;= m; i++) &#123; if(x % i == 0) &#123; return \"no\"; &#125; &#125; return \"yes\";&#125;int main()&#123; while(scanf(\"%d\", &amp;n) != EOF) &#123; printf(\"Is %d is a prime?\\t\", n); cout&lt;&lt;is_Prime(n)&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM 题解","slug":"ACM-题解","permalink":"https://wyxwx.github.io/categories/ACM-题解/"}],"tags":[{"name":"素数","slug":"素数","permalink":"https://wyxwx.github.io/tags/素数/"},{"name":"算法","slug":"算法","permalink":"https://wyxwx.github.io/tags/算法/"}]},{"title":"【HDU2136】 Largest prime factor","slug":"【HDU2136】-Largest-prime-factor","date":"2018-11-10T16:25:59.000Z","updated":"2018-11-10T17:18:32.949Z","comments":true,"path":"2018/11/11/【HDU2136】-Largest-prime-factor/","link":"","permalink":"https://wyxwx.github.io/2018/11/11/【HDU2136】-Largest-prime-factor/","excerpt":"Everybody knows any number can be combined by the prime number.Now, your task is telling me what position of the largest prime factor.The position of prime 2 is 1, prime 3 is 2, and prime 5 is 3, etc.Specially, LPF(1) = 0.","text":"Everybody knows any number can be combined by the prime number.Now, your task is telling me what position of the largest prime factor.The position of prime 2 is 1, prime 3 is 2, and prime 5 is 3, etc.Specially, LPF(1) = 0. InputEach line will contain one integer n(0 &lt; n &lt; 1000000).OutputOutput the LPF(n).Sample Input12345Sample Output01213 12345678910111213141516171819202122232425262728293031323334353637/** 素数筛法，每遍历一个外层点时 将它的所有倍数全部赋值为num(当前质因子的序号) 从小到大逐个遍历即为最大质因子的序号*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int Max = 1e6 + 5;int n;int a[Max];int main()&#123; memset(a, 0, sizeof(a)); int num = 1; //质因子序号 for(int i = 2; i &lt;= Max; i++) &#123; if(!a[i]) &#123; for(int j = i; j &lt;= Max; j += i) //i的所有倍数都被赋值为同一个序号 &#123; a[j] = num; &#125; num++; &#125; &#125; while(scanf(\"%d\", &amp;n) != EOF) &#123; printf(\"%d\\n\", a[n]); &#125; return 0;&#125;","categories":[{"name":"ACM 题解","slug":"ACM-题解","permalink":"https://wyxwx.github.io/categories/ACM-题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"},{"name":"HDU","slug":"HDU","permalink":"https://wyxwx.github.io/tags/HDU/"},{"name":"素数筛","slug":"素数筛","permalink":"https://wyxwx.github.io/tags/素数筛/"}]},{"title":"CCF 201512-2 消除类游戏","slug":"CCF-201512-2-消除类游戏","date":"2018-11-10T07:51:49.000Z","updated":"2018-11-10T07:52:41.774Z","comments":true,"path":"2018/11/10/CCF-201512-2-消除类游戏/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/CCF-201512-2-消除类游戏/","excerpt":"问题描述 消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。 现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。 请注意：一个棋子可能在某一行和某一列同时被消除。","text":"问题描述 消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。 现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。 请注意：一个棋子可能在某一行和某一列同时被消除。 输入格式 输入的第一行包含两个整数n, m，用空格分隔，分别表示棋盘的行数和列数。 接下来n行，每行m个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。输出格式 输出n行，每行m个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出0，否则输出棋子的颜色编号。样例输入4 52 2 3 1 23 4 5 1 42 3 2 1 32 2 2 4 4样例输出2 2 3 0 23 4 5 0 42 3 2 0 30 0 0 4 4样例说明 棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。样例输入4 52 2 3 1 23 1 1 1 12 3 2 1 32 2 3 3 3样例输出2 2 3 0 23 0 0 0 02 3 2 0 32 2 0 0 0样例说明 棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。评测用例规模与约定 所有的评测用例满足：1 ≤ n, m ≤ 30。 解题思路分别按行列消除，开一个数组记录该位置是否要被消除，并不改变输入数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int n, m;int a[35][35];int us[35][35];int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(us, 0, sizeof(us)); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; int num = 1; for(int i = 0; i &lt; n; i++) //按列消除 &#123; for(int j = 0; j &lt; m; j++) &#123; while(a[i][j] == a[i][j + 1]) &#123; j++; if(j == m) break; num++; if(num &gt;= 3) &#123; for(int k = j - num + 1; k &lt;= j; k++) //记录是否要被消除 &#123; us[i][k] = 1; &#125; &#125; &#125; num = 1; &#125; &#125; for(int i = 0; i &lt; m; i++) //按行消除 &#123; for(int j = 0; j &lt; n; j++) &#123; while(a[j][i] == a[j + 1][i]) &#123; j++; if(j == n) break; num++; if(num &gt;= 3) &#123; for(int k = j - num + 1; k &lt;= j; k++) &#123; us[k][i] = 1; &#125; &#125; &#125; num = 1; &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(!us[i][j]) cout&lt;&lt;a[i][j]; else cout&lt;&lt;0; if(j == m - 1) cout&lt;&lt;endl; else cout&lt;&lt;\" \"; &#125; &#125; return 0;&#125;","categories":[{"name":"CCF 题解","slug":"CCF-题解","permalink":"https://wyxwx.github.io/categories/CCF-题解/"}],"tags":[{"name":"CCF","slug":"CCF","permalink":"https://wyxwx.github.io/tags/CCF/"},{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"}]},{"title":"CCF 201512-1 数位之和","slug":"CCF-201512-1-数位之和","date":"2018-11-10T07:49:53.000Z","updated":"2018-11-10T07:51:12.164Z","comments":true,"path":"2018/11/10/CCF-201512-1-数位之和/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/CCF-201512-1-数位之和/","excerpt":"问题描述 给定一个十进制整数n，输出n的各位数字之和。","text":"问题描述 给定一个十进制整数n，输出n的各位数字之和。 输入格式 输入一个整数n。输出格式 输出一个整数，表示答案。样例输入20151220样例输出13样例说明 20151220的各位数字之和为2+0+1+5+1+2+2+0=13。评测用例规模与约定 所有评测用例满足：0 ≤ n ≤ 1000000000。 这道题的数据用int也可以过 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;ll n;int main()&#123; cin&gt;&gt;n; int sum = 0; while(n) &#123; sum += n % 10; n /= 10; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;","categories":[{"name":"CCF 题解","slug":"CCF-题解","permalink":"https://wyxwx.github.io/categories/CCF-题解/"}],"tags":[{"name":"CCF","slug":"CCF","permalink":"https://wyxwx.github.io/tags/CCF/"},{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"}]},{"title":"CCF 201604-4 游戏","slug":"CCF-201604-4-游戏","date":"2018-11-10T07:48:05.000Z","updated":"2018-11-10T07:49:28.191Z","comments":true,"path":"2018/11/10/CCF-201604-4-游戏/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/CCF-201604-4-游戏/","excerpt":"问题描述 小明在玩一个电脑游戏，游戏在一个n×m的方格图上进行，小明控制的角色开始的时候站在第一行第一列，目标是前往第n行第m列。 方格图上有一些方格是始终安全的，有一些在一段时间是危险的，如果小明控制的角色到达一个方格的时候方格是危险的，则小明输掉了游戏，如果小明的角色到达了第n行第m列，则小明过关。第一行第一列和第n行第m列永远都是安全的。 每个单位时间，小明的角色必须向上下左右四个方向相邻的方格中的一个移动一格。 经过很多次尝试，小明掌握了方格图的安全和危险的规律：每一个方格出现危险的时间一定是连续的。并且，小明还掌握了每个方格在哪段时间是危险的。 现在，小明想知道，自己最快经过几个时间单位可以达到第n行第m列过关。","text":"问题描述 小明在玩一个电脑游戏，游戏在一个n×m的方格图上进行，小明控制的角色开始的时候站在第一行第一列，目标是前往第n行第m列。 方格图上有一些方格是始终安全的，有一些在一段时间是危险的，如果小明控制的角色到达一个方格的时候方格是危险的，则小明输掉了游戏，如果小明的角色到达了第n行第m列，则小明过关。第一行第一列和第n行第m列永远都是安全的。 每个单位时间，小明的角色必须向上下左右四个方向相邻的方格中的一个移动一格。 经过很多次尝试，小明掌握了方格图的安全和危险的规律：每一个方格出现危险的时间一定是连续的。并且，小明还掌握了每个方格在哪段时间是危险的。 现在，小明想知道，自己最快经过几个时间单位可以达到第n行第m列过关。 输入格式 输入的第一行包含三个整数n, m, t，用一个空格分隔，表示方格图的行数n、列数m，以及方格图中有危险的方格数量。 接下来t行，每行4个整数r, c, a, b，表示第r行第c列的方格在第a个时刻到第b个时刻之间是危险的，包括a和b。游戏开始时的时刻为0。输入数据保证r和c不同时为1，而且当r为n时c不为m。一个方格只有一段时间是危险的（或者说不会出现两行拥有相同的r和c）。输出格式 输出一个整数，表示小明最快经过几个时间单位可以过关。输入数据保证小明一定可以过关。样例输入3 3 32 1 1 11 3 2 102 2 2 10样例输出6样例说明 第2行第1列时刻1是危险的，因此第一步必须走到第1行第2列。 第二步可以走到第1行第1列，第三步走到第2行第1列，后面经过第3行第1列、第3行第2列到达第3行第3列。评测用例规模与约定 前30%的评测用例满足：0 &lt; n, m ≤ 10，0 ≤ t &lt; 99。 所有评测用例满足：0 &lt; n, m ≤ 100，0 ≤ t &lt; 9999，1 ≤ r ≤ n，1 ≤ c ≤ m，0 ≤ a ≤ b ≤ 100。 解题思路bfs计算最短时间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;struct Node&#123; int x, y, step;&#125;now;int n, m, t;int dir[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;int a[105][105][2] = &#123;0&#125;, us[105][105][305] = &#123;0&#125;;void bfs()&#123; queue&lt;Node&gt; q; now.x = 1; now.y = 1; now.step = 0; q.push(now); while(!q.empty()) &#123; now = q.front(); q.pop(); if(now.x == n &amp;&amp; now.y == m) &#123; printf(\"%d\\n\", now.step); return ; &#125; for(int i = 0; i &lt; 4; i++) &#123; int x = now.x + dir[i][0]; int y = now.y + dir[i][1]; int time = now.step + 1; if(x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m || time &gt;= a[x][y][0] &amp;&amp; time &lt;= a[x][y][1] || us[x][y][time]) continue; Node nxt; nxt.x = x; nxt.y = y; nxt.step = time; q.push(nxt); us[x][y][time] = 1; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;t); int r, c, a1, b1; while(t--) &#123; scanf(\"%d%d%d%d\", &amp;r, &amp;c, &amp;a1, &amp;b1); a[r][c][0] = a1; a[r][c][1] = b1; &#125; bfs(); return 0;&#125;","categories":[{"name":"CCF 题解","slug":"CCF-题解","permalink":"https://wyxwx.github.io/categories/CCF-题解/"}],"tags":[{"name":"CCF","slug":"CCF","permalink":"https://wyxwx.github.io/tags/CCF/"},{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"},{"name":"bfs","slug":"bfs","permalink":"https://wyxwx.github.io/tags/bfs/"}]},{"title":"CCF 201609-2 火车购票","slug":"CCF-201609-2-火车购票","date":"2018-11-10T07:46:27.000Z","updated":"2018-11-10T07:48:50.017Z","comments":true,"path":"2018/11/10/CCF-201609-2-火车购票/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/CCF-201609-2-火车购票/","excerpt":"问题描述 请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。 假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。 购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。 假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。","text":"问题描述 请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。 假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。 购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。 假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。 输入格式 输入的第一行包含一个整数n，表示购票指令的数量。 第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。输出格式 输出n行，每行对应一条指令的处理结果。 对于购票指令p，输出p张车票的编号，按从小到大排序。样例输入42 5 4 2样例输出1 26 7 8 9 1011 12 13 143 4样例说明 1) 购2张票，得到座位1、2。 2) 购5张票，得到座位6至10。 3) 购4张票，得到座位11至14。 4) 购2张票，得到座位3、4。评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。 解题思路利用数组进行购票模拟ps：当每一行所剩余的位置都不够p时，从前往后遍历空位置进行购买 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int n, p, us[105], num[25];int main()&#123; while(scanf(\"%d\", &amp;n) != EOF) &#123; memset(us, 0, sizeof(us)); for(int i = 0; i &lt;= 20; i ++) //每一行所剩余的票数 &#123; num[i] = 5; &#125; int flag = 0; while(n--) &#123; scanf(\"%d\", &amp;p); for(int i = 1; i &lt;= 20; i++) &#123; if(num[i] &gt;= p) //每一行所余的票数足够 &#123; flag = 1; num[i] -= p; int cnt = 0; for(int j = 1; j &lt;= 5; j++) //计算得出当前可订的座位 &#123; if(!us[(i - 1) * 5 + j]) &#123; us[(i - 1) * 5 + j] = 1; printf(\"%d\", (i - 1) * 5 + j); cnt++; if(cnt != p) printf(\" \"); else &#123; printf(\"\\n\"); break; &#125; &#125; &#125; break; &#125; &#125; if(flag) &#123; flag = 0; continue; &#125; else //若每一行都没有足够的位置，则从第一行开始订剩余的不连贯的位置 &#123; int cnt = 0; for(int i = 1; i &lt;= 100; i++) &#123; if(!us[i]) &#123; us[i] = 1; printf(\"%d\", i); cnt++; if(cnt == p) &#123; printf(\"\\n\"); break; &#125; else printf(\" \"); &#125; &#125; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"CCF 题解","slug":"CCF-题解","permalink":"https://wyxwx.github.io/categories/CCF-题解/"}],"tags":[{"name":"CCF","slug":"CCF","permalink":"https://wyxwx.github.io/tags/CCF/"},{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"},{"name":"模拟","slug":"模拟","permalink":"https://wyxwx.github.io/tags/模拟/"}]},{"title":"CCF 201604-2 俄罗斯方块","slug":"CCF-201604-2-俄罗斯方块","date":"2018-11-10T07:42:15.000Z","updated":"2018-11-10T07:43:32.720Z","comments":true,"path":"2018/11/10/CCF-201604-2-俄罗斯方块/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/CCF-201604-2-俄罗斯方块/","excerpt":"问题描述 俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。 游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。 在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。 具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。","text":"问题描述 俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。 游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。 在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。 具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。 输入格式 输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。 输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。 第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例）输出格式 输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。样例输入0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 0 0 0 1 1 1 10 0 0 0 1 0 0 0 0 00 0 0 00 1 1 10 0 0 10 0 0 03样例输出0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 1 1 1 1 1 1 10 0 0 0 1 1 0 0 0 0 下述代码仅得 90 分 解题思路用数组模拟下落的过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int a[16][11], b[5][5];int tmp1[5] = &#123;15, 15, 15, 15, 15&#125;, tmp2[5] = &#123;0, 0, 0, 0, 0&#125;;int d;int main()&#123; for(int i = 1; i &lt;= 15; i++) &#123; for(int j = 1; j &lt;= 10; j++) &#123; scanf(\"%d\", &amp;a[i][j]); &#125; &#125; for(int i = 1; i &lt;= 4; i++) &#123; for(int j = 1; j &lt;= 4; j++) &#123; scanf(\"%d\", &amp;b[i][j]); &#125; &#125; cin&gt;&gt;d; for(int i = d; i &lt; d + 4; i++) //计算a中第i列有1的最小行 &#123; for(int j = 1; j &lt;= 15; j ++) &#123; if(a[j][i] == 1) &#123; tmp1[i - d + 1] = j - 1; break; &#125; &#125; &#125; for(int i = 1; i &lt;= 4; i++) //计算b中第i列有1的最大行 &#123; for(int j = 1; j &lt;= 4; j++) &#123; if(b[j][i] == 1) &#123; tmp2[i] = j; &#125; &#125; &#125; int cnt = 15; for(int i = 1; i &lt;= 4; i++) //求出差值得出b中元素该放的位置 &#123; cnt = min(cnt, tmp1[i] - tmp2[i]); &#125; for(int i = 1; i &lt;= 4; i++) //模拟变化 &#123; for(int j = 1; j &lt;= 4; j++) &#123; a[i + cnt][j + d - 1] += b[i][j]; &#125; &#125; for(int i = 1; i &lt;= 15; i++) &#123; for(int j = 1; j &lt;= 10; j++) &#123; printf(\"%d\", a[i][j]); if(j != 10) printf(\" \"); else printf(\"\\n\"); &#125; &#125; return 0;&#125;","categories":[{"name":"CCF 题解","slug":"CCF-题解","permalink":"https://wyxwx.github.io/categories/CCF-题解/"}],"tags":[{"name":"CCF","slug":"CCF","permalink":"https://wyxwx.github.io/tags/CCF/"},{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"},{"name":"模拟","slug":"模拟","permalink":"https://wyxwx.github.io/tags/模拟/"}]},{"title":"CCF 201609-1 最大波动","slug":"CCF-201609-1-最大波动","date":"2018-11-10T07:40:06.000Z","updated":"2018-11-10T07:41:23.670Z","comments":true,"path":"2018/11/10/CCF-201609-1-最大波动/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/CCF-201609-1-最大波动/","excerpt":"问题描述 小明正在利用股票的波动程度来研究股票。小明拿到了一只股票每天收盘时的价格，他想知道，这只股票连续几天的最大波动值是多少，即在这几天中某天收盘价格与前一天收盘价格之差的绝对值最大是多少。","text":"问题描述 小明正在利用股票的波动程度来研究股票。小明拿到了一只股票每天收盘时的价格，他想知道，这只股票连续几天的最大波动值是多少，即在这几天中某天收盘价格与前一天收盘价格之差的绝对值最大是多少。 输入格式 输入的第一行包含了一个整数n，表示小明拿到的收盘价格的连续天数。 第二行包含n个正整数，依次表示每天的收盘价格。输出格式 输出一个整数，表示这只股票这n天中的最大波动值。样例输入62 5 5 7 3 5样例输出4样例说明 第四天和第五天之间的波动最大，波动值为|3-7|=4。评测用例规模与约定 对于所有评测用例，2 ≤ n ≤ 1000。股票每一天的价格为1到10000之间的整数。 解题思路用一个flag记录在此之前是上升还是下降，若存在波动，在ans++之后要把flag及时更新 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int MX = 1005;int n, a[MX], b[MX];int main()&#123; while(scanf(\"%d\", &amp;n) != EOF) &#123; int ans = 0; for(int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; for(int i = 1; i &lt; n; i++) &#123; b[i] = abs(a[i] - a[i - 1]); ans = max(ans, b[i]); &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[{"name":"CCF 题解","slug":"CCF-题解","permalink":"https://wyxwx.github.io/categories/CCF-题解/"}],"tags":[{"name":"CCF","slug":"CCF","permalink":"https://wyxwx.github.io/tags/CCF/"},{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"}]},{"title":"CCF 201612-2 工资计算","slug":"CCF-201612-2-工资计算","date":"2018-11-10T07:38:28.000Z","updated":"2018-11-10T07:39:09.322Z","comments":true,"path":"2018/11/10/CCF-201612-2-工资计算/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/CCF-201612-2-工资计算/","excerpt":"问题描述 小明的公司每个月给小明发工资，而小明拿到的工资为交完个人所得税之后的工资。假设他一个月的税前工资（扣除五险一金后、未扣税前的工资）为S元，则他应交的个人所得税按如下公式计算： 1） 个人所得税起征点为3500元，若S不超过3500，则不交税，3500元以上的部分才计算个人所得税，令A=S-3500元； 2） A中不超过1500元的部分，税率3%； 3） A中超过1500元未超过4500元的部分，税率10%； 4） A中超过4500元未超过9000元的部分，税率20%； 5） A中超过9000元未超过35000元的部分，税率25%； 6） A中超过35000元未超过55000元的部分，税率30%； 7） A中超过55000元未超过80000元的部分，税率35%； 8） A中超过80000元的部分，税率45%； 例如，如果小明的税前工资为10000元，则A=10000-3500=6500元，其中不超过1500元部分应缴税1500×3%=45元，超过1500元不超过4500元部分应缴税(4500-1500)×10%=300元，超过4500元部分应缴税(6500-4500)×20%=400元。总共缴税745元，税后所得为9255元。 已知小明这个月税后所得为T元，请问他的税前工资S是多少元。","text":"问题描述 小明的公司每个月给小明发工资，而小明拿到的工资为交完个人所得税之后的工资。假设他一个月的税前工资（扣除五险一金后、未扣税前的工资）为S元，则他应交的个人所得税按如下公式计算： 1） 个人所得税起征点为3500元，若S不超过3500，则不交税，3500元以上的部分才计算个人所得税，令A=S-3500元； 2） A中不超过1500元的部分，税率3%； 3） A中超过1500元未超过4500元的部分，税率10%； 4） A中超过4500元未超过9000元的部分，税率20%； 5） A中超过9000元未超过35000元的部分，税率25%； 6） A中超过35000元未超过55000元的部分，税率30%； 7） A中超过55000元未超过80000元的部分，税率35%； 8） A中超过80000元的部分，税率45%； 例如，如果小明的税前工资为10000元，则A=10000-3500=6500元，其中不超过1500元部分应缴税1500×3%=45元，超过1500元不超过4500元部分应缴税(4500-1500)×10%=300元，超过4500元部分应缴税(6500-4500)×20%=400元。总共缴税745元，税后所得为9255元。 已知小明这个月税后所得为T元，请问他的税前工资S是多少元。 输入格式 输入的第一行包含一个整数T，表示小明的税后所得。所有评测数据保证小明的税前工资为一个整百的数。输出格式 输出一个整数S，表示小明的税前工资。样例输入9255样例输出10000评测用例规模与约定 对于所有评测用例，1 ≤ T ≤ 100000。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;int t;int main()&#123; while(scanf(\"%d\", &amp;t) != EOF) &#123; if(t &lt;= 3500) &#123; printf(\"%d\\n\", t); &#125; else if(t &lt;= 4955 &amp;&amp; t &gt; 3500) &#123; t -= 3500; t = t * 100 / 97; t += 3500; printf(\"%d\\n\", t); &#125; else if(t &lt;= 7655 &amp;&amp; t &gt; 4955) &#123; t -= 5000; t += 45; t = t * 100 / 90; t += 5000; printf(\"%d\\n\", t); &#125; else if(t &lt;= 11255 &amp;&amp; t &gt; 7655) &#123; t -= 8000; t += 345; t = t * 100 / 80; t += 8000; printf(\"%d\\n\", t); &#125; else if(t &lt;= 30755 &amp;&amp; t &gt; 11255) &#123; t -= 12500; t += 1245; t = t * 100 / 75; t += 12500; printf(\"%d\\n\", t); &#125; else if(t &lt;= 44755 &amp;&amp; t &gt; 30755) &#123; t -= 38500; t += 7745; t = t * 100 / 70; t += 38500; printf(\"%d\\n\", t); &#125; else if(t &lt;= 61005 &amp;&amp; t &gt; 44755) &#123; t -= 58500; t += 13745; t = t * 100 / 65; t += 58500; printf(\"%d\\n\", t); &#125; else &#123; t -= 83500; t += 22495; t = t * 100 / 55; t += 83500; printf(\"%d\\n\", t); &#125; &#125; return 0;&#125;","categories":[{"name":"CCF 题解","slug":"CCF-题解","permalink":"https://wyxwx.github.io/categories/CCF-题解/"}],"tags":[{"name":"CCF","slug":"CCF","permalink":"https://wyxwx.github.io/tags/CCF/"},{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"}]},{"title":"CCF 201612-1 中间数","slug":"CCF-201612-1-中间数","date":"2018-11-10T07:31:39.000Z","updated":"2018-11-10T07:40:44.223Z","comments":true,"path":"2018/11/10/CCF-201612-1-中间数/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/CCF-201612-1-中间数/","excerpt":"问题描述 在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。 给定一个整数序列，请找出这个整数序列的中间数的值。","text":"问题描述 在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。 给定一个整数序列，请找出这个整数序列的中间数的值。 输入格式 输入的第一行包含了一个整数n，表示整数序列中数的个数。 第二行包含n个正整数，依次表示a1, a2, …, an。输出格式 如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。样例输入62 6 5 6 3 5样例输出5样例说明 比5小的数有2个，比5大的数也有2个。样例输入43 4 6 7样例输出-1样例说明 在序列中的4个数都不满足中间数的定义。样例输入53 4 6 6 7样例输出-1样例说明 在序列中的5个数都不满足中间数的定义。评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ ai ≤ 1000。 解题思路排序找最中间的位置，算出比它大和小的数的个数，比较判定 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;int n, a[1005];int main()&#123; while(scanf(\"%d\", &amp;n) != EOF) &#123; for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; sort(a + 1, a + n + 1); int num; if(n &amp; 1) num = a[n / 2 + 1]; else num = a[n / 2]; int sum1 = 0, sum2 = 0; for(int i = 1; i &lt;= n; i++) &#123; if(a[i] &lt; num) sum1++; if(a[i] &gt; num) sum2++; &#125; if(sum1 == sum2) printf(\"%d\\n\", num); else printf(\"-1\\n\"); &#125; return 0;&#125;","categories":[{"name":"CCF 题解","slug":"CCF-题解","permalink":"https://wyxwx.github.io/categories/CCF-题解/"}],"tags":[{"name":"CCF","slug":"CCF","permalink":"https://wyxwx.github.io/tags/CCF/"},{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"}]},{"title":"CCF 201703-4 地铁修建(最小生成树 + 并查集)","slug":"CCF-201703-4-地铁修建-最小生成树-并查集","date":"2018-11-10T07:28:57.000Z","updated":"2018-11-10T07:40:44.248Z","comments":true,"path":"2018/11/10/CCF-201703-4-地铁修建-最小生成树-并查集/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/CCF-201703-4-地铁修建-最小生成树-并查集/","excerpt":"问题描述 A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。 地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。 现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。 作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。","text":"问题描述 A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。 地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。 现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。 作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。 输入格式 输入的第一行包含两个整数n, m，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。 第2行到第m+1行，每行包含三个整数a, b, c，表示枢纽a和枢纽b之间可以修建一条隧道，需要的时间为c天。输出格式 输出一个整数，修建整条地铁线路最少需要的天数。样例输入6 61 2 42 3 43 6 71 4 24 5 55 6 6样例输出6样例说明 可以修建的线路有两种。 第一种经过的枢纽依次为1, 2, 3, 6，所需要的时间分别是4, 4, 7，则整条地铁线需要7天修完； 第二种经过的枢纽依次为1, 4, 5, 6，所需要的时间分别是2, 5, 6，则整条地铁线需要6天修完。 第二种方案所用的天数更少。评测用例规模与约定 对于20%的评测用例，1 ≤ n ≤ 10，1 ≤ m ≤ 20； 对于40%的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000； 对于60%的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000，1 ≤ c ≤ 1000； 对于80%的评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000； 对于100%的评测用例，1 ≤ n ≤ 100000，1 ≤ m ≤ 200000，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000000。 所有评测用例保证在所有候选隧道都修通时1号枢纽可以通过隧道到达其他所有枢纽。 解题思路利用并查集判断是否连通， 利用最小生成树判断最短天数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;const int MXN = 1e5 + 5, MXM = 2e5 + 5;struct Node&#123; int a, b, t; bool operator&lt; (const Node node)const&#123; return t &lt; node.t; &#125;&#125;e[MXM];int n, m, par[MXM];void init()&#123; for(int i = 0; i &lt;= n; i++) &#123; par[i] = i; &#125;&#125;int fid(int x)&#123; return par[x] == x? x : par[x] = fid(par[x]);&#125;int main()&#123; while(scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; for(int i = 0; i &lt; m; i++) scanf(\"%d%d%d\", &amp;e[i].a, &amp;e[i].b, &amp;e[i].t); init(); sort(e, e + m); for(int i = 0; i &lt; m; i++) &#123; int x = fid(e[i].a); int y = fid(e[i].b); if(x != y) &#123; par[x] = y; &#125; if(fid(1) == fid(n)) &#123; printf(\"%d\\n\", e[i].t); break; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"CCF 题解","slug":"CCF-题解","permalink":"https://wyxwx.github.io/categories/CCF-题解/"}],"tags":[{"name":"CCF","slug":"CCF","permalink":"https://wyxwx.github.io/tags/CCF/"},{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"},{"name":"并查集","slug":"并查集","permalink":"https://wyxwx.github.io/tags/并查集/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://wyxwx.github.io/tags/最小生成树/"}]},{"title":"CCF 201703-2 学生排队(模拟)","slug":"CCF-201703-2-学生排队-模拟","date":"2018-11-10T07:24:11.000Z","updated":"2018-11-10T07:40:44.203Z","comments":true,"path":"2018/11/10/CCF-201703-2-学生排队-模拟/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/CCF-201703-2-学生排队-模拟/","excerpt":"问题描述 体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。 例如，下面给出了一组移动的例子，例子中学生的人数为8人。 0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8； 1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8； 2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7； 3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。 小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？ 请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。","text":"问题描述 体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。 例如，下面给出了一组移动的例子，例子中学生的人数为8人。 0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8； 1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8； 2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7； 3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。 小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？ 请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。 输入格式 输入的第一行包含一个整数n，表示学生的数量，学生的学号由1到n编号。 第二行包含一个整数m，表示调整的次数。 接下来m行，每行两个整数p, q，如果q为正，表示学号为p的同学向后移动q，如果q为负，表示学号为p的同学向前移动-q。输出格式 输出一行，包含n个整数，相邻两个整数之间由一个空格分隔，表示最终从前向后所有学生的学号。样例输入833 28 -33 -2样例输出1 2 4 3 5 8 6 7评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，所有移动均合法。 解题思路数组模拟，利用两个数组，一个表示指定位置的学生学号，一个表示该学号的学生所在的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int MX = 1005;struct Mve&#123; int id, mve;&#125;e[MX];int n, a[MX], b[MX];int m;int main()&#123; while(scanf(\"%d\", &amp;n) != EOF) &#123; for(int i = 1; i &lt;= n; i++) &#123; a[i] = i; b[i] = i; &#125; scanf(\"%d\", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\", &amp;e[i].id, &amp;e[i].mve); &#125; for(int i = 1; i &lt;= m; i++) &#123; if(e[i].mve &lt; 0) &#123; int ind = b[e[i].id] + e[i].mve; int tmp = a[ind]; int st = b[e[i].id], ed = b[tmp] + 1; for(int j = st; j &gt;= ed; j--) &#123; a[j] = a[j -1]; b[a[j]]++; &#125; a[ind] = e[i].id; b[e[i].id] = b[e[i].id] + e[i].mve; &#125; if(e[i].mve &gt;= 0) &#123; int ind = b[e[i].id] + e[i].mve; int tmp = a[ind]; int st = b[e[i].id], ed = b[tmp] - 1; for(int j = st; j &lt;= ed; j++) &#123; a[j] = a[j + 1]; b[a[j]]--; &#125; a[ind] = e[i].id; b[e[i].id] = b[e[i].id] + e[i].mve; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; printf(\"%d\", a[i]); if(i != n) printf(\" \"); else printf(\"\\n\"); &#125; &#125; return 0;&#125;","categories":[{"name":"CCF 题解","slug":"CCF-题解","permalink":"https://wyxwx.github.io/categories/CCF-题解/"}],"tags":[{"name":"CCF","slug":"CCF","permalink":"https://wyxwx.github.io/tags/CCF/"},{"name":"题解","slug":"题解","permalink":"https://wyxwx.github.io/tags/题解/"},{"name":"模拟","slug":"模拟","permalink":"https://wyxwx.github.io/tags/模拟/"}]},{"title":"用命令行工具sqlite3打开数据库出现乱码的解决方案","slug":"用命令行工具sqlite3打开数据库出现乱码的解决方案","date":"2018-11-10T07:19:23.000Z","updated":"2018-11-10T07:20:50.207Z","comments":true,"path":"2018/11/10/用命令行工具sqlite3打开数据库出现乱码的解决方案/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/用命令行工具sqlite3打开数据库出现乱码的解决方案/","excerpt":"数据库中存储的数据本是中文，用 sqlite3 打开之后变成乱码 方法： （1）查看 dos 的编码方式，一般为 GBK（简体中文）","text":"数据库中存储的数据本是中文，用 sqlite3 打开之后变成乱码 方法： （1）查看 dos 的编码方式，一般为 GBK（简体中文） Android 一般的编码方式都是 UTF-8，所以要将 dos 的编码方式也改为 UTF-8 （2）借用 chcp 命令改变编码方式 chcp 65001 （将编码方式改为UTF-8） chcp 936 （将编码方式改回GBK） （3）改为 UTF-8 后重新在命令行用 sqlite3 打开数据库，格式正确","categories":[{"name":"踩坑之路","slug":"踩坑之路","permalink":"https://wyxwx.github.io/categories/踩坑之路/"}],"tags":[{"name":"sqlite3","slug":"sqlite3","permalink":"https://wyxwx.github.io/tags/sqlite3/"},{"name":"乱码","slug":"乱码","permalink":"https://wyxwx.github.io/tags/乱码/"}]},{"title":"windows关机命令与tomcat的shutdown命令冲突解决方法","slug":"windows关机命令与tomcat的shutdown命令冲突解决方法","date":"2018-11-10T07:12:31.000Z","updated":"2018-11-10T07:16:39.875Z","comments":true,"path":"2018/11/10/windows关机命令与tomcat的shutdown命令冲突解决方法/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/windows关机命令与tomcat的shutdown命令冲突解决方法/","excerpt":"配置tomcat使其能在任意目录下启动之后，输入startup回车，如图","text":"配置tomcat使其能在任意目录下启动之后，输入startup回车，如图 再输入shutdown会出现如下图问题 shutdown 默认为 Windows 的关机命令，若想执行tomcat的shutdown命令，只需执行全称shutdown.bat 成功关闭","categories":[{"name":"踩坑之路","slug":"踩坑之路","permalink":"https://wyxwx.github.io/categories/踩坑之路/"}],"tags":[{"name":"shutdown 冲突","slug":"shutdown-冲突","permalink":"https://wyxwx.github.io/tags/shutdown-冲突/"}]},{"title":"Linux 连接文件","slug":"Linux-连接文件","date":"2018-11-10T07:08:09.000Z","updated":"2018-11-10T07:13:41.729Z","comments":true,"path":"2018/11/10/Linux-连接文件/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/Linux-连接文件/","excerpt":"Linux 的连接文件有两种 symbolic link（符号连接） 类似 Windows 的快捷方式功能的文件，可以快速连接到目标文件 hard link（硬连接） 通过文件系统的 inode 连接来产生新文件名，而不是产生新文件","text":"Linux 的连接文件有两种 symbolic link（符号连接） 类似 Windows 的快捷方式功能的文件，可以快速连接到目标文件 hard link（硬连接） 通过文件系统的 inode 连接来产生新文件名，而不是产生新文件 一、hard link在某个目录下新建一条文件名连接到某 inode 号码的关联记录 eg： 12[root@www ~]# ln /etc/crontab crontab[root@www ~]# ll -i /etc/crontab /root/crontab 连接数变为了2 两个文件的权限，属性完全一样 如果此时删除任何一个文件名，inode 和 block 都还存在，可以通过另一个文件名读取到正确的文件数据 无论使用哪个文件名进行编辑，均能进行数据的修改 hard link 只是在某个目录下的 block 多写入了一个关连数据，不增加 inode 也不耗用 block 数量 但是 hard link 是有限制的： 不能跨文件系统 不能连接到目录 二、symbolic link创建一个独立的文件，该文件会让数据的读取指向它连接的那个文件的文件名，连接文件中会写上目标文件的文件名 当源文件被删除后，连接文件也会无法打开 修改连接文件后，源文件也跟着变 eg： 12[root@www ~]# ln -s /etc/crontab crontab2[root@www ~]# ll -i /etc/crontab /root/crontab2 两个文件指向不同的 inode 号码 symbolic link 所创建的文件为一个独立的新文件，会占用 inode 和 block hard link 安全但是限制多 symbolic link 使用范围广 三、ln 命令123[root@www ~]# ln [-sf] 源文件 目标文件# -s：不加参数表示 hard link，加上 -s 表示 symbolic link# -f：如果目标文件存在，直接删除后创建 四、关于目录的连接数量新建目录时，新目录的连接数为 2，上层目录的连接数会增加 1 新建一个 /tmp/test 目录时，会有三个东西： /tmp/test /tmp/test/. /tmp/test/.. 前两个是一样的，都代表 /tmp/test 目录，而第三个代表了 /tmp 目录 所以有两个连接指向了新目录 /tmp/test，一个指向了上层目录 /tmp","categories":[{"name":"Linux 学习之路","slug":"Linux-学习之路","permalink":"https://wyxwx.github.io/categories/Linux-学习之路/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wyxwx.github.io/tags/Linux/"}]},{"title":"Linux 命令与文件的查询","slug":"Linux-命令与文件的查询","date":"2018-11-10T07:01:53.000Z","updated":"2018-11-10T07:05:19.113Z","comments":true,"path":"2018/11/10/Linux-命令与文件的查询/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/Linux-命令与文件的查询/","excerpt":"查询脚本文件名which（寻找“执行文件”） 12[root@www ~]# which [-a] command# -a：将所有由 PATH 目录中可以找到的命令均列出","text":"查询脚本文件名which（寻找“执行文件”） 12[root@www ~]# which [-a] command# -a：将所有由 PATH 目录中可以找到的命令均列出 该命令是根据 PTAH 这个环境变量所规范的路径去查询“执行文件”的文件名 查询文件名whereis（寻找特定文件） 12345[root@www ~]# whereis [-bmsu] 文件或目录名# -b：只找二进制格式的文件# -m：只找在说明文件 manual 路径下的文件# -s：只找 source 源文件# -u：查找不在上述三个选项当中的其他特殊文件 如果不加任何参数，就将所有的数据列出来 locate: 123[root@www ~]# locate [-ir] keyword# -i：忽略大小写的差异# -r：后面可接正则表达式的显示方式 locate 可以根据文件的部分名称来查找结果 locate：依据 /var/lib/mlocate 内的数据库记载，找出用户输入的关键字文件名 由于数据库基本上是默认每天更新一次，所以有时查找时需要手动更新： updatedb：读取 /etc/updatedb.conf 配置文件的设置去查找系统硬盘内的文件名，并更新 /var/lib/mlocate 内的数据库文件 find: 1234567891011121314151617181920212223242526272829303132333435[root@www ~]# [PATH] [option] [action] # 1. 时间参数共有 -atime，-ctime，-mtime# mtime n：n 天之前的一天之内更改过的文件# mtime +n：n 天之前（不含第 n 天）更改过的文件# mtime -n：n 天之前（包含第 n 天）更改过的文件# newer file：file 为一个已经存在的文件夹，列出比 file 还要新的文件名# ps：若 n 为 0，表示目前的时间 # 2. 与用户或用户组名有关的参数# -uid n：n 为用户的账号 ID# -gid n：n 为用户组名的 ID# -user name：name 为用户账号名称# -group name：name 为用户组名# -nouser：寻找文件的所有者不存在 /etc/passwd（用户的账号 ID） 的人# -nogroup：寻找文件的用户组不存在于 /etc/group（用户组名的 ID） 中的文件 # 3. 与文件权限及名称有关的参数# -name filename：查找文件名为 filename 的文件# -size [+-]SIZE：查找比 SIZE 还要大（+）或小（-）的文件。c：byte；k：1024 bytes# -type TYPE：查找文件的类型为 TYPE 的。f：一般正规文件；b，c：设备文件；d：目录；l：连接文件；s：socket；p：FIFO# -perm mode：查找文件权限刚好等于 mode 的文件# -perm -mode：查找文件权限必须要全部包括 mode 的权限的文件# -perm +mode：查找文件权限包含任一 mode 的权限的文件# 4. 其他可进行的操作# -exec command：-exec 后面可再接其他的命令来处理查找到的结果# -print：将结果打印到屏幕上，也是默认选项 # find 相关的额外命令：find / -perm +7000 -exec ls -l &#123;&#125; \\;# find 的结果会被放置到 &#123;&#125; 中# find 额外命令的开始(-exec)到结束(\\;)，中间的部分即是 find 命令内的额外命令 \"ls -l &#123;&#125;\"# \";\" 在 bash 环境下有特殊意义，所以利用反斜杠来转义# find 可以利用通配符来找寻文件名 find 命令后面可以接多个目录来进行查找，find 本来就会查找子目录 find 不但可以指定查找的目录（连同子目录），还可以利用额外的参数来找到最正确的文件名","categories":[{"name":"Linux 学习之路","slug":"Linux-学习之路","permalink":"https://wyxwx.github.io/categories/Linux-学习之路/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wyxwx.github.io/tags/Linux/"}]},{"title":"Linux 下文件内容的查阅命令","slug":"Linux-下文件内容的查阅命令","date":"2018-11-10T06:50:35.000Z","updated":"2018-11-10T07:00:22.290Z","comments":true,"path":"2018/11/10/Linux-下文件内容的查阅命令/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/Linux-下文件内容的查阅命令/","excerpt":"简单介绍cat：由第一行开始显示文件内容 tac：从最后一行开始显示文件内容 nl：显示的时候，顺便输出行号 more：一页一页地显示文件内容 less：与 more 类似，但可以往前查询翻页 head：只看头几行 tail：只看结尾几行 od：以二进制的方式读取文件内容","text":"简单介绍cat：由第一行开始显示文件内容 tac：从最后一行开始显示文件内容 nl：显示的时候，顺便输出行号 more：一页一页地显示文件内容 less：与 more 类似，但可以往前查询翻页 head：只看头几行 tail：只看结尾几行 od：以二进制的方式读取文件内容 命令详解 cat 1234567[root@www ~]# cat [-AbEnTv] 文件名# -A：可以列出一些特殊字符，相当于 -vET 参数# -b：列出行号，空白行不标号# -E：显示结尾的断行字符 '$'# -n：打印行号，空白行也打印# -T：将 [Tab] 键以 '^I' 显示出来# -v：列出一些看不出来的特殊字符 tac 1[root@www ~]# tac 文件名 nl 1234567[root@www ~]# nl [-bnw] 文件名# -b a：相当于 cat -n# -b t：相当于 cat -b# -n ln：行号在屏幕的最左方显示# -n rn：行号在自己字段的最右方显示，且不加0# -n rz：行号在自己字段的最右方显示，且加0# -w &#123;数字&#125;：行号字段占用的位数 more 1[root@www ~]# more 文件名 按键功能： 空格键：向下翻一页 Enter：向下滚动一行 /string：向下查询 string :f：立刻显示出文件名以及目前显示的行数 b 或 [ctrl]-b：往回翻页，只对文件有用，对管道无用 q：离开 more 页面 less 1[root@www ~]# less 文件名 按键功能： 空格键：向下翻一页 [PageDown]：向下翻一页 [PageUp]：向上翻一页 /string：向下查询 string ?string：向上查询 string n：重复前一个查询 N：反向重复前一个查询 q：离开 less 页面 6.head 123[root@www ~]# head [-n number] 文件名# -n：显示 number 行数据，默认显示前10行# 若 number 为负数，表示显示除 后面 number 行外的所有数据 7.tail 1234[root@www ~]# tail [-n number] 文件名# -n：显示 number 行数据，默认显示最后的10行# f：持续检测该文件，直到按下 [ctrl]-c 才结束# 若 number 前有 '+' 符号，表示除了前面的 number 行之外的所有数据都将被显示 od 作用于非纯文本文件 12345678[root@www ~]# od [-t TYPE] 文件# -t：后面接各种类型的输出：# a：使用默认的字符输出# c：使用 ASCII 字符输出# d[size]：使用十进制输出，每个整数占用 size bytes# f[size]：使用浮点数输出，每个数占用 size bytes# o[size]：使用八进制输出，每个整数占用 size bytes# x[size]：使用十六进制输出，每个整数占用 size bytes 读出来的数值默认是使用非文本文件，即是十六进制的数值来显示 9.touch 修改文件时间或创建新的文件 Linux 文件有三个主要变动的时间： ① mtime（modification time） 当该文件的“内容数据”即文件的内容更改时，更新该时间 ② ctime（status time） 当该文件的“状态”即权限与属性改变时，更新该时间 ③ atime（access time） 当“该文件的内容被取用”时，更新该时间 在默认情况下，ls 命令显示出来的是该文件的 mtime，即该文件内容上次被更改的时间 123456[root@www ~]# touch [-acdmt] 文件名# -a：仅修改 atime# -c：仅修改文件的时间，若该文件不存在则不创建新文件# -d：后面接欲修改的日期而不用目前的日期，也可以用 --date=\"日期或时间\"# -m：仅修改 mtime# -t：后面接欲修改的时间而不用目前的时间，格式：[YYMMDDhhmm] ps：两个命令之间加上 ‘;’ 表示连续命令的执行 touch 命令一般不修改 ctime touch 这个命令最常被使用的情况是 ① 创建一个空的文件 ② 将某个文件的日期修改为目前日期（mtime 与 atime）","categories":[{"name":"Linux 学习之路","slug":"Linux-学习之路","permalink":"https://wyxwx.github.io/categories/Linux-学习之路/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wyxwx.github.io/tags/Linux/"}]},{"title":"Linux 下的文件与目录管理","slug":"Linux-下的文件与目录管理","date":"2018-11-10T06:46:19.000Z","updated":"2018-11-10T06:49:17.336Z","comments":true,"path":"2018/11/10/Linux-下的文件与目录管理/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/Linux-下的文件与目录管理/","excerpt":"查看文件与目录：ls 1234567891011121314151617181920[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称# -a：全部文件，连同隐藏文件一起列出来# -A：列出全部文件，包含隐藏文件，但不包括 '.' 和 '..'这两个目录# -d：仅列出目录本身# -f：直接列出结果而不排序（ls 默认以文件名排序）# -F：根据文件、目录等信息添加后缀，例如： *：可执行文件；/：目录；=：socket 文件；|：FIFO 文件# -h：将文件容量以人类较易读的方式列出来# -i：列出 inode 号码# -l：列出包含文件属性与权限等数据的长数据串# -n：用 UID 与 GID 替换用户与用户组的名称# -r：将排序结果反向输出# -R：连同子目录的内容一起列出来# -S：以文件容量大小排序# -t：依时间排序# --color=never：不依据文件特性给予颜色显示# --color=always：显示颜色# --color=auto：系统自行判断是否给予颜色# --full=time：以完整时间模式输出","text":"查看文件与目录：ls 1234567891011121314151617181920[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称# -a：全部文件，连同隐藏文件一起列出来# -A：列出全部文件，包含隐藏文件，但不包括 '.' 和 '..'这两个目录# -d：仅列出目录本身# -f：直接列出结果而不排序（ls 默认以文件名排序）# -F：根据文件、目录等信息添加后缀，例如： *：可执行文件；/：目录；=：socket 文件；|：FIFO 文件# -h：将文件容量以人类较易读的方式列出来# -i：列出 inode 号码# -l：列出包含文件属性与权限等数据的长数据串# -n：用 UID 与 GID 替换用户与用户组的名称# -r：将排序结果反向输出# -R：连同子目录的内容一起列出来# -S：以文件容量大小排序# -t：依时间排序# --color=never：不依据文件特性给予颜色显示# --color=always：显示颜色# --color=auto：系统自行判断是否给予颜色# --full=time：以完整时间模式输出 ps：默认显示的只有非隐藏文件的文件名，以文件名进行排序及文件名代表的颜色显示 目录文件文件名都是以深蓝色显示 复制、删除与移动：cp，rm，mvcp：复制文件或目录、创建连接文件（快捷方式）、对比两文件的新旧而予以更新、复制整个目录 rm：删除文件或目录 mv：移动目录或文件、重命名操作 cp（复制文件与目录） 123456789101112[root@www ~]# cp [-adfilprsu] 源文件 目标文件[root@www ~]# cp [options] source1 source2 source3 .... directory# -a：相当于 -pdr 的意思# -d：若源文件为连接文件的属性，则复制连接文件属性而非文件本身# -f：若目标文件已经存在且无法开启，则删除后再尝试一次# -i：若目标文件已经存在时，在覆盖时会先询问操作的进行# -l：进行硬连接的连接文件创建，而非复制文件本身# -p：连同文件的属性一起复制过去# -r：递归持续复制，用于目录的复制行为# -s：复制成为符号链接文件，即快捷方式文件# -u：若目标文件比源文件旧才更新目标文件# 若源文件有两个以上，则最后一个目标文件一定要是“目录” ps：复制时，在不加任何参数的情况下，文件的某些属性/权限会改变，可以加上 -a 参数可以保证复制前后的两个文件或目录的整个数据特性完全一模一样 如果是目录则不能直接复制，要加上 -r 参数 在默认的条件中，cp 的源文件与目的文件的权限是不同的，目的文件的所有者通常会是命令操作者本身 与所有者、用户组相关的权限与属性，若是由非系统管理员操作，即使加上 -a 参数，也无法达成完整复制权限的 rm（移除文件或目录） 1234[root@www ~]# rm [-fir] 文件或目录# -f：忽略不存在的文件# -i：在删除前会询问用户是否操作# -r：递归删除，删除目录 若使用 root 身份，则默认加入 -i 参数 若不想要被询问，可以在命令前加上反斜杠 ‘\\’ 若有以 ‘-‘ 开头的文件或目录，操作时要在文件名前加上本目录 ‘./‘ 即可；或者在命令与文件名之间加上 ‘ – ‘ 即可 mv（移动文件与目录，或更名） 1234[root@www ~]# mv [-fiu] source destination# -f：若目标文件已经存在，不会询问而直接覆盖# -i：若目标文件已经存在时，会询问是否覆盖# -u：若目标文件已经存在，且 source 比较新，才会更新 destination ps：如果有多个源文件或目录，则最后一个目标文件一定是“目录” 若目标文件不存在，则表示给源文件重命名 取得路径的文件名与目录名称文件名和目录名用斜线 (/) 来分辨 basename 与 dirname 两个命令分别用来查看该路径的文件名与路径名","categories":[{"name":"Linux 学习之路","slug":"Linux-学习之路","permalink":"https://wyxwx.github.io/categories/Linux-学习之路/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wyxwx.github.io/tags/Linux/"}]},{"title":"Linux 下目录与路径","slug":"Linux-下目录与路径","date":"2018-11-10T06:03:23.000Z","updated":"2018-11-10T06:42:26.292Z","comments":true,"path":"2018/11/10/Linux-下目录与路径/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/Linux-下目录与路径/","excerpt":"相对路径与绝对路径绝对路径：路径的写法一定由根目录 / 写起 相对路径：路径的写法不是由 / 写起 比较而言，相对路径较为方便，但是绝对路径的正确度更好","text":"相对路径与绝对路径绝对路径：路径的写法一定由根目录 / 写起 相对路径：路径的写法不是由 / 写起 比较而言，相对路径较为方便，但是绝对路径的正确度更好 目录的相关操作下表为一些较为特殊的目录 符号 代表意义 . 此层目录 .. 上一层目录 - 前一个工作目录 - 目前用户身份”所在的主文件夹 ~账号名 该用户的主文件夹 ps：根目录的上一层(..)与根目录自己(.)是同一个目录下表为一些常见的处理目录的命令 命令 代表意义 cd 切换目录 pwd 显示当前目录 mkdir 新建一个新的目录 rmdir 删除一个空的目录 命令详解： cd（切换目录） 1234567[root@www ~]# cd [相对路径或绝对路径][root@www ~]# cd ~user# 进入 user 这个用户的主文件夹[root@www ~]# cd ~# 进入自己的主文件夹[root@www ~]# cd# 不加路径代表回到自己的主文件夹 pwd（显示目前所在的目录） 12[root@www ~]# pwd [-P]# -P：显示当前的路径，而非连接路径 /var/mail为连接路径 /var/spool/mail 为当前的路径 上图高亮表示 /var/mail 连接到 /var/spool/mail mkdir（新建新目录） 123[root@www ~]# mkdir [-mp] 目录名称# -m：配置文件案的权限# -p：将所需要的目录（包含上层目录）递归创建 默认情况下，所需要的目录要一层一层地创建，如果用 ‘-p’参数即可以直接创建，并且如果该目录本来就已经存在时，系统也不会显示错误信息 rmdir（删除空的目录） 12[root@www ~]# rmdir [-p] 目录名称# -p：连同上层空目录也一起删除 如果要将所有目录下的东西都删掉，必须使用“rm -r 目录”","categories":[{"name":"Linux 学习之路","slug":"Linux-学习之路","permalink":"https://wyxwx.github.io/categories/Linux-学习之路/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wyxwx.github.io/tags/Linux/"}]},{"title":"Linux 的文件权限的概念","slug":"Linux-的文件权限的概念","date":"2018-11-10T05:42:40.000Z","updated":"2018-11-10T06:42:26.261Z","comments":true,"path":"2018/11/10/Linux-的文件权限的概念/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/Linux-的文件权限的概念/","excerpt":"Linux 文件属性利用 ls -al 命令查看文件 命令 ls：显示文件的文件名与相关属性 -al 参数：列出所有的文件（含隐藏文件）详细的权限与属性","text":"Linux 文件属性利用 ls -al 命令查看文件 命令 ls：显示文件的文件名与相关属性 -al 参数：列出所有的文件（含隐藏文件）详细的权限与属性 -rw-r–r–. 1 root root 129 Dec 29 2013 .tcshrc 权限 连接数 文件所有者 文件所属用户组 文件大小 文件最后被修改的时间 文件名 第一列代表这个文件的类型与权限 · 第一个字符代表这个文件是“目录、文件或链接文件等” 权限：rwx。[r] 代表可读，[w] 代表可写，[x] 表示可执行(execute)，三个权限的位置不会改变 共三组权限 第一组：文件所有者的权限 第二组：同用户组的权限 第三组：其他非本用户组的权限 ps：目录与文件的权限意义并不相同 –&gt; 第二列表示有多少文件名连接到此节点 –&gt; 第三列表示这个文件（或目录）的所有者账号 –&gt; 第四列表示这个文件的所属用户组 –&gt; 第五列为这个文件的容量大小，默认单位为 B –&gt; 第六列为这个文件的创建日期或最近的修改日期 –&gt; 第七列为该文件名 改变文件属性与权限 chgrp: 改变文件所属用户组 · chown: 改变文件所有者 · chmod: 改变文件的权限 –&gt; 改变所属用户组：chgrp 前提：要被改变的组名必须在 /etc/group 文件内存在 12[root@www ~]# chgrp [-R] dirname/filename ...# -R : 进行递归的持续更改，即连同子目录下的所有文件、目录都更新成为这个用户组 改变文件所有者：chown（也可以修改用户组的名称） 前提：用户必须是已经存在与系统中的账号，也就是在 /etc/password 这个文件中有记录的用户名称 123[root@www ~]# chown [-R] 账号名称 文件或目录[root@www ~]# chown [-R] 账号名称:组名 文件或目录# -R : 进行递归的持续更改，即连同子目录下的所有文件、目录都更新成为这个用户组 chown 也可以使用 “chown user.group file”，即在所有者与用户组之间加上小数点 “.” 单纯修改所属用户组：”chown .group file” 改变权限：chmod 权限的设置方法有两种： 数字类型改变文件权限 符号类型改变文件权限 · 数字类型： r：4 w：2 x：1 12[root@www ~]# chmod [-R] xyz 文件或目录# xyz：rwx 属性数值的相加 · 符号类型： user：u group：g others：o all：a +’：加入 ‘-’：除去 ‘=’：设置 目录与文件的权限意义文件是存放实际数据的所在，目录主要的内容是记录文件名列表 文件的权限： r：可读取此文件的实际内容 w：可以编辑，新增或者是修改该文件的内容（不包含删除） x：该文件具有可以被系统执行的权限 目录的权限： r：具有读取目录结构列表的权限，查询该目录下的文件名 w：具有更改该目录结构列表的权限，即： 1. 新建文件与目录 2. 删除已经存在的文件与目录 3. 将已存在的文件或目录进行重命名 4. 转移该目录内的文件、目录位置 x：代表用户能否进入该目录成为工作目录 工作目录：当前所在的目录 能不能进入（cd）某一个目录，只与该目录的 x 权限有关 要开放目录给任何人浏览时，应该至少也要给予 r 及 x 的权限","categories":[{"name":"Linux 学习之路","slug":"Linux-学习之路","permalink":"https://wyxwx.github.io/categories/Linux-学习之路/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wyxwx.github.io/tags/Linux/"}]},{"title":"关于 Linux 系统下的关机命令","slug":"关于-Linux-系统下的关机命令","date":"2018-11-10T05:39:31.000Z","updated":"2018-11-10T06:43:51.096Z","comments":true,"path":"2018/11/10/关于-Linux-系统下的关机命令/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/关于-Linux-系统下的关机命令/","excerpt":"由于 Linux 系统的特殊性，可能有很多人同时在你的主机上面工作，所以当你直接按下电源开关来关机时，其他人的数据传输也会中断，造成文件损毁，所以关于这个问题，Linux 里有一些相关的命令 将数据同步写入磁盘：sync 在 Linux 系统的默认情况下，某些已经加载内存中的数据不会直接被写回硬盘，而是先暂存在内存当中。 因此在关机之前要利用 sync 命令先将数据写入磁盘，为了防止非正常关机，可以在关机或重启之前指定多次该命令。 ps：目前的 shutdown / reboot / halt 等命令均已经在关机前进行了 sync 这个工具的调用","text":"由于 Linux 系统的特殊性，可能有很多人同时在你的主机上面工作，所以当你直接按下电源开关来关机时，其他人的数据传输也会中断，造成文件损毁，所以关于这个问题，Linux 里有一些相关的命令 将数据同步写入磁盘：sync 在 Linux 系统的默认情况下，某些已经加载内存中的数据不会直接被写回硬盘，而是先暂存在内存当中。 因此在关机之前要利用 sync 命令先将数据写入磁盘，为了防止非正常关机，可以在关机或重启之前指定多次该命令。 ps：目前的 shutdown / reboot / halt 等命令均已经在关机前进行了 sync 这个工具的调用 惯用的关机命令：shutdown shutdown 可以完成以下工作： · 自由选择关机模式：关机、重启或进入单用户操作模式 · 设置关机时间： · 自定义关机消息 · 仅发出警告信息（不关机） · 选择是否要用 fsck 检查文件系统： （fsck命令被用于检查并且试图修复文件系统中的错误。当文件系统发生错误四化，可用fsck指令尝试加以修复。） shutdown 语法规则： /sbin/shutdown [-t 秒] [-arkhncff] 时间 [警告信息] eg：1/sbin/shutdown -h 10 'I will shutdown after 10 mins' 这台机器会在十分钟之后关机，并且将字符串显示在目前登录者的屏幕前方 其他命令： 重启、关机：reboot、halt，poweroff 补充： Linux 系统中的系统运作的模式（run level）共有七种，以下先列出四种执行等级： run level 0: 关机 run level 3: 纯命令行模式 run level 5: 含有图形界面模式 run level 6: 重启 切换执行等级：init 命令 所以如下的命令也可以用于关机： 1init 0","categories":[{"name":"Linux 学习之路","slug":"Linux-学习之路","permalink":"https://wyxwx.github.io/categories/Linux-学习之路/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wyxwx.github.io/tags/Linux/"}]},{"title":"关于 Linux 的 man page 说明与使用","slug":"关于-Linux-的-man-page-说明与使用","date":"2018-11-10T05:23:34.000Z","updated":"2018-11-10T05:37:41.237Z","comments":true,"path":"2018/11/10/关于-Linux-的-man-page-说明与使用/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/关于-Linux-的-man-page-说明与使用/","excerpt":"man 即是 manual 的简写 在命令行执行 “man [命令或数据]” 既可以出现关于该命令或数据的详细操作说明","text":"man 即是 manual 的简写 在命令行执行 “man [命令或数据]” 既可以出现关于该命令或数据的详细操作说明 例如，输入 “man cal” 之后会出现如下界面: 下表为在 man page 界面中的常用快捷键 按键 功能 空格 向下翻一页 [Page Down] 向下翻一页 [Page Up] 向上翻一页 [Home] 去到第一页 [End] 去到最后一页 /string 向下查询string字符串 ?string 向上查询string字符串 n, N 利用 / 或 ? 来查询字符串时，可以用 n 来继续下一个查询，用 N 来进行反向查询 q 结束 man page 环境 man page 页面第一行的 CAL(1) 中， 在查询数据的后面的数字 (1) 是有其说明意义的，下表为常见数字的意义 数字代号 代表内容 1 用户在 shell 环境中可以操作的命令或可执行文件 2 系统内核可调用的函数与工具等 3 一些常用的函数与函数库，大部分为 C 的函数库 4 设备文件的说明，通常在 /dev 下的文件 5 配置文件或者是某些文件的格式 6 游戏 7 惯例与协议等，例如 Linux 文件系统、网络协议、ASCII code 等说明 8 系统管理员可用的管理命令 9 跟 Kernel 有关的文件 man page 中的内容也分几个部分 代号 内容说明 NAME 简短的命令，数据名称说明 SYNOPSIS 简短的命令执行语法简介 DESCRIPTION 较为完整的说明 OPTIONS 针对 SYNOPSIS 部分中，有列举的所有可用的选项说明 COMMANDS 当这个程序在执行的时候，可以在此程序中执行的命令 FILES 这个程序或数据所使用或参考或连接到的某些文件 SEE ALSO 这个命令或数据有相关的其他说明 EXAMPLE 一些可以参考的范例 BUGS 是否有相关的错误 建议查询 man page 时的步骤： 先查看 NAME 的项目 仔细看一下 DESCRIPTION， 学习一些细节 查询关于 OPTIONS 的部分，了解每个选项的意义 查看 SEE ALSO 来看一下还有那些东西可以使用 查看 FILES 部分的文件来参考 查询特定命令/文件的 man page 说明文件： man -f [命令或数据]： 获取 [命令或数据] 的信息 man -k [命令或数据]： 在系统的说明文件中，只要有 [命令或数据] 这个关键字就将该说明列出来 下图执行: “man -k cal” · 补充：whatis [命令或数据] 等价于 man -f [命令或数据] apropos [命令或数据] 等价于 man -k [命令或数据] 若想要使用这两个命令，需要以 root 身份创建 whatis 数据库: [root@www ~] # makewhatis 总结自 《鸟哥的 Linux 私房菜》 基础学习篇第三版","categories":[{"name":"Linux 学习之路","slug":"Linux-学习之路","permalink":"https://wyxwx.github.io/categories/Linux-学习之路/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wyxwx.github.io/tags/Linux/"},{"name":"man page","slug":"man-page","permalink":"https://wyxwx.github.io/tags/man-page/"}]},{"title":"Vmware Workstation 虚拟机出现 The VMware Authorization Service is not running 问题的解决方案","slug":"Vmware-Workstation-虚拟机出现-The-VMware-Authorization-Service-is-not-running-问题的解决方案","date":"2018-11-10T05:18:08.000Z","updated":"2018-11-10T05:20:16.991Z","comments":true,"path":"2018/11/10/Vmware-Workstation-虚拟机出现-The-VMware-Authorization-Service-is-not-running-问题的解决方案/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/Vmware-Workstation-虚拟机出现-The-VMware-Authorization-Service-is-not-running-问题的解决方案/","excerpt":"点击开启虚拟机后，出现了如图所示的错误提示","text":"点击开启虚拟机后，出现了如图所示的错误提示 解决方案： 打开任务管理器，点击服务 在名称里找到 VMAuthdService 右键点击选择启动 再次开启虚拟机即可成功","categories":[{"name":"踩坑之路","slug":"踩坑之路","permalink":"https://wyxwx.github.io/categories/踩坑之路/"}],"tags":[{"name":"VM 虚拟机","slug":"VM-虚拟机","permalink":"https://wyxwx.github.io/tags/VM-虚拟机/"}]},{"title":"阿里云Ubuntu64位云服务器搭建JavaEE环境（JDK+Tomcat+Mysql）","slug":"阿里云Ubuntu64位云服务器搭建JavaEE环境（JDK-Tomcat-Mysql）","date":"2018-11-10T04:49:08.000Z","updated":"2018-11-10T05:13:29.447Z","comments":true,"path":"2018/11/10/阿里云Ubuntu64位云服务器搭建JavaEE环境（JDK-Tomcat-Mysql）/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/阿里云Ubuntu64位云服务器搭建JavaEE环境（JDK-Tomcat-Mysql）/","excerpt":"要想在服务器上部署自己的项目，首先要在服务器上安装JDK， Mysql， Tomcat，下面将先讲解如何安装这三项。由于我的电脑是win10系统，所以需要下载额外的辅助软件来实现与服务器的文件交互等。","text":"要想在服务器上部署自己的项目，首先要在服务器上安装JDK， Mysql， Tomcat，下面将先讲解如何安装这三项。由于我的电脑是win10系统，所以需要下载额外的辅助软件来实现与服务器的文件交互等。 准备工作：下载PuTTy，FileZilla，jdk（请无视截图的版本，不要下载10.0版本！！！来自踩坑选手的忠告），Tomcat，mysql 打开FileZilla，将云服务器的公有IP（若是腾讯云服务器，只需要将唯一IP填入即可）填入主机栏，其他信息填好之后点击快速连接 在左侧的本地站点中找到刚刚下载的jdk及Tomcat压缩包，选中后右键点击上传 上传成功后，打开PuTTy以连接到服务器，将云服务器的公有IP填入HostName栏，Port填写22（出于安全考虑，Linux默认只开放22端口，若需要连接其他端口，可以在控制台中进行设置） 点击open后跳转到如下图所示界面，输入用户名及密码后登录成功（Linux系统不会显示密码，输好密码后直接回车即可） 查看当前目录下的文件，即我们刚刚用FileFilla上传成功的压缩包 在root目录下新建一个javaee文件夹输入命令： 1tar zxvf jdk-10.0.2_linux-x64_bin.tar.gz -C javaee 从而将jdk压缩包解压至javaee目录下 注：想要给文件重命名一定要在进行配置之前改！！！ 本弱鸡在配置之后对文件进行了重命名，并且忘了改配置文件，卡了一个小时，生无可恋心态已崩 输入命令： 1vi /etc/profile 进入配置文件开始配置java环境变量 进入下图界面后，按下键盘上的’i’进行编辑，并在文件的最后追加如下配置，输入完成后按下Esc键，再输入“:wq!”保存文件并退出（具体参照Linux中VI编辑器的使用） 1234export JAVA_HOME=/root/javaee/jdk-10.0.2export JRE_HOME=/root/javaee/jdk-10.0.2/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH 输入两条命令，若出现下图所示提示则配置成功 12source /etc/profilejava -version 接下来进行Tomcat的安装配置将其解压至javaee文件夹下 进入Tomcat文件夹下，用 VI 编辑器打开 catalina.sh 1vi catalina.sh 在该文件的开头添加如下配置 12export JAVA_HOME=/root/javaee/jdk-10.0.2export JRE_HOME=/root/javaee/jdk-10.0.2/jre 退出后在Tomcat的bin目录下如下输入命令，显示Tomcat已成功启动 1./startup.sh 此时，从浏览器可以成功访问Tomcat页面（访问之前请确认是否打开防火墙或已按照文章最后附一的内容将8080端口添加进安全组） 接下来开始安装mysql由于mysql版本及原Linux系统存在残留mysql的问题，搞了一下午心态已崩，重新装了镜像，用了大佬们常用的更简便的方法在终端窗口中输入以下三条命令 123sudo apt-get install mysql-serversudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev 安装完成后，测试是否安装成功，输入登录指令及密码，密码即安装 mysql-server 时设置的密码，若出现下图所示情况，则安装成功，此时，可以查看与操作数据库中的数据表 至此，jdk， tomcat， mysql 全部安装成功 附一：开放其他可用端口：云服务器管理控制台-&gt;管理-&gt;本实例安全组-&gt;配置规则-&gt;添加安全组规则之后添加所需要访问的端口即可 下面是一些常用端口","categories":[{"name":"常用配置","slug":"常用配置","permalink":"https://wyxwx.github.io/categories/常用配置/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wyxwx.github.io/tags/Linux/"},{"name":"云服务器","slug":"云服务器","permalink":"https://wyxwx.github.io/tags/云服务器/"},{"name":"JavaEE环境","slug":"JavaEE环境","permalink":"https://wyxwx.github.io/tags/JavaEE环境/"}]},{"title":"Win10环境配置Tomcat（9.0版本）","slug":"Win10环境配置Tomcat（9-0版本）","date":"2018-11-10T03:11:57.000Z","updated":"2018-11-10T17:39:29.668Z","comments":true,"path":"2018/11/10/Win10环境配置Tomcat（9-0版本）/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/Win10环境配置Tomcat（9-0版本）/","excerpt":"由于博主今天中午脑子一抽重装了系统，电脑上所有的东西都被我干掉了，一朝回到解放前，被各种配置折磨了一下午，所以记录一下重装系统之后艰难的配置路线，以防以后再次冲动 首先去官网下载tomcat的压缩包并解压","text":"由于博主今天中午脑子一抽重装了系统，电脑上所有的东西都被我干掉了，一朝回到解放前，被各种配置折磨了一下午，所以记录一下重装系统之后艰难的配置路线，以防以后再次冲动 首先去官网下载tomcat的压缩包并解压 然后去电脑的属性配置环境变量 这里需要配置两处：CATALINA_HOME 与 Path CATALINA_HOME的变量值是tomcat的根目录，如下图 其后，点击编辑Path新增一条：%CATALINA_HOME%\\bin，随后一路确定 随后打开cmd，输入startup 此时会弹出另一个窗口 当出现如下图红框中日志时，打开浏览器，输入：http://localhost:8080/ 出现如下页面，则tomcat配置成功","categories":[{"name":"常用配置","slug":"常用配置","permalink":"https://wyxwx.github.io/categories/常用配置/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://wyxwx.github.io/tags/Tomcat/"}]},{"title":"关于vi编辑器的方向键无法使用的解决方法","slug":"关于vi编辑器的方向键无法使用的解决方法","date":"2018-11-10T03:05:40.000Z","updated":"2018-11-10T03:06:39.576Z","comments":true,"path":"2018/11/10/关于vi编辑器的方向键无法使用的解决方法/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/关于vi编辑器的方向键无法使用的解决方法/","excerpt":"对于刚开始用Linux编程的小白来说，vi是最基础的编辑器，可以用vi写出一些简单程序 而在vi中按下方向键或退格键会出现奇奇怪怪的字母","text":"对于刚开始用Linux编程的小白来说，vi是最基础的编辑器，可以用vi写出一些简单程序 而在vi中按下方向键或退格键会出现奇奇怪怪的字母 这种情况是由于vi不支持方向键和退格键，这些功能是由vim支持的，所以只需要重新下载vim即可 打开终端，依次输入以下命令: sudo apt-get remove vim-common sudo apt-get install vim 再次打开vi编辑器之后就可以正常使用方向键及退格键","categories":[{"name":"Linux 学习之路","slug":"Linux-学习之路","permalink":"https://wyxwx.github.io/categories/Linux-学习之路/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wyxwx.github.io/tags/Linux/"},{"name":"vi","slug":"vi","permalink":"https://wyxwx.github.io/tags/vi/"}]},{"title":"Spring Boot + WebSocket 学习笔记","slug":"学习笔记","date":"2018-11-10T02:44:46.000Z","updated":"2018-11-10T02:59:15.683Z","comments":true,"path":"2018/11/10/学习笔记/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/学习笔记/","excerpt":"WebSocket 协议是基于 TCP 的一种新的网络协议。它实现了浏览器与服务器全双工通信–允许服务器主动发送信息给客户端，实现客户端之间的交互。WebSocket 是从 Html5 中演化而出，但是相对于 HTTP的 不支持持久性连接，WebSocket 是一个持久化的协议。","text":"WebSocket 协议是基于 TCP 的一种新的网络协议。它实现了浏览器与服务器全双工通信–允许服务器主动发送信息给客户端，实现客户端之间的交互。WebSocket 是从 Html5 中演化而出，但是相对于 HTTP的 不支持持久性连接，WebSocket 是一个持久化的协议。 实现 WebSocket 协议后，服务端只要与客户端进行过一次连接之后，就不需要再次连接，并且可以一直向客户端发送信息，即服务端主动向客户端发送消息。由于 WebSocket 协议在握手阶段采用了 HTTP 协议，能通过各种 HTTP 代理服务器。目前并不是所有的浏览器都实现了 WebSocket，对于没有实现该协议的浏览器，还需要通过 STOMP 协议来完成兼容。要想在 Spring Boot 项目中应用 WebSocket，首先要在 pom.xml 中加入依赖 12345678910111213 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; &lt;!-- Spring security 主要为了点对点时的安全登录，可以不使用 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 下面开发一个简单的 WebSocket 服务· 创建 java 配置文件 1234567891011121314import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter; @Configurationpublic class WebSocketConfig &#123; //创建服务器端点 @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125; &#125; · 定义 WebSocket 服务端站点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106 import org.springframework.stereotype.Service; import javax.websocket.*;import javax.websocket.server.ServerEndpoint;import java.io.IOException;import java.util.concurrent.CopyOnWriteArrayList; //创建 WebSocket 服务站点， 参数: 请求地址@ServerEndpoint(\"/ws\")@Servicepublic class WebSocketServiceImpl &#123; //用来记录当前在线连接数，应该设置为线程安全 private static int onlineCount = 0; //保证线程安全的 WebSocketServiceImpl 对象的 Set private static CopyOnWriteArrayList&lt;WebSocketServiceImpl&gt; webSocketServices = new CopyOnWriteArrayList&lt;&gt;(); //与客户端的连接会话 private Session session; public Session getSession() &#123; return session; &#125; /** * 连接建立成功调用的方法 * @param session */ @OnOpen public void onOpen(Session session)&#123; this.session = session; webSocketServices.add(this); addOnlineCount(); System.out.println(\"有新连接加入， 当前在线人数: \" + getOnlineCount()); try &#123; sendMessage(\"有新连接加入了\"); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; /** * 连接关闭调用的方法 */ @OnClose public void onClose()&#123; webSocketServices.remove(this); subOnlineCount(); System.out.println(\"有一个连接关闭， 当前在线人数: \" + getOnlineCount()); &#125; /** * 收到客户端消息后调用的方法 * @param message 客户端发送来的消息 * @param session */ @OnMessage public void onMessage(String message, Session session)&#123; System.out.println(\"收到客户端消息: \" + message); //群发消息 for(WebSocketServiceImpl service : webSocketServices)&#123; try &#123; //获取当前用户名称 String userName = service.getSession().getUserPrincipal().getName(); System.out.println(userName); service.sendMessage(message); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** *发生错误时调用 */ @OnError public void onError(Session session, Throwable error)&#123; System.out.println(\"发生错误\"); error.printStackTrace(); &#125; /** * 发送消息 * @param message 客户端消息 * @throws IOException */ private void sendMessage(String message) throws IOException&#123; this.session.getBasicRemote().sendText(message); &#125; //返回在线数 private static synchronized int getOnlineCount()&#123; return onlineCount; &#125; //增加连接人数 private static synchronized void addOnlineCount()&#123; WebSocketServiceImpl.onlineCount++; &#125; //减少连接人数 private static synchronized void subOnlineCount()&#123; WebSocketServiceImpl.onlineCount--; &#125; &#125; · WebSocket 页面（websocket.jsp） 12345678910111213141516171819202122&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;My WebSocket&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"/jquery-1.8.3.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/websocket.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 测试 WebSocket 站点 &lt;br&gt; &lt;input id = \"message\" type=\"text\"&gt; &lt;button onclick=\"sendMessage()\"&gt;发送消息&lt;/button&gt; &lt;button onclick=\"closeWebSocket()\"&gt;关闭 WebSocket 连接&lt;/button&gt; &lt;div id=\"context\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; · WebSocket 客户端脚本(websocket.js) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var websocket = null;//判断当前浏览器是否支持 WebSocketif('WebSocket' in window)&#123; //创建 WebSocket 对象，连接服务器端点 websocket = new WebSocket(\"ws://localhost:8080/ws\");&#125;else&#123; alert('Not support webSocket')&#125; //连接发生错误的回调方法websocket.onerror = function () &#123; appendMessage(\"error\");&#125;; //连接成功建立的回调方法websocket.onopen = function (event) &#123; appendMessage(\"open\");&#125;; //接收到消息的回调方法websocket.onmessage = function (event) &#123; appendMessage(event.data);&#125;; //连接关闭的回调方法websocket.onclose = function () &#123; appendMessage(\"close\");&#125;; //监听窗口关闭事件，当窗口关闭时，主动关闭 websocket 连接//防止连接还没断开就关闭窗口， server 端会抛异常window.onbeforeunload = function () &#123; websocket.close();&#125;; //将消息显示在网页上function appendMessage(message) &#123; var context = $(\"#context\").html() + \"&lt;br/&gt;\" + message; $(\"#context\").html(context);&#125;; //关闭连接function closeWebSocket() &#123; websocket.close();&#125; //发送消息function sendMessage() &#123; var message = $(\"#message\").val(); websocket.send(message);&#125; · WebSocket 控制器 123456789101112131415 import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; @RequestMapping(value = \"/websocket\")@RestControllerpublic class WebSocketController &#123; @GetMapping(value = \"/index\") public String websocket()&#123; return \"websocket\"; &#125; &#125; 启动控制器，跳转去客户端，打开两个页面发送消息","categories":[{"name":"JavaEE 学习之路","slug":"JavaEE-学习之路","permalink":"https://wyxwx.github.io/categories/JavaEE-学习之路/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wyxwx.github.io/tags/SpringBoot/"}]},{"title":"Spring Boot 的 jsp文件中无法引入静态资源文件（js,css等文件）","slug":"jsp文件中无法引入静态资源文件（js-css等文件）","date":"2018-11-10T02:07:05.000Z","updated":"2018-11-10T02:45:27.185Z","comments":true,"path":"2018/11/10/jsp文件中无法引入静态资源文件（js-css等文件）/","link":"","permalink":"https://wyxwx.github.io/2018/11/10/jsp文件中无法引入静态资源文件（js-css等文件）/","excerpt":"错误（net::ERR_ABORTED 404）报错信息：","text":"错误（net::ERR_ABORTED 404）报错信息： 报错时我的jsp文件中引入路径： 12&lt;script type=\"text/javascript\" src=\"../../sources/static/jquery-1.8.3.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"../../sources/static/websocket.js\"&gt;&lt;/script&gt; 正确路径：删除掉static及其之前的全部路径 12&lt;script type=\"text/javascript\" src=\"/jquery-1.8.3.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/websocket.js\"&gt;&lt;/script&gt; 原因：在未对 application.properties 文件进行配置时，Spring Boot 默认从resources目录的static目录查找资源文件，所以 src 目录中无需加入 static 及其之前的路径 若想对资源路径进行配置，可以在 application.properties 配置文件中加入下面的配置 1spring.mvc.static-path-pattern=/**","categories":[{"name":"JavaEE 学习之路","slug":"JavaEE-学习之路","permalink":"https://wyxwx.github.io/categories/JavaEE-学习之路/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wyxwx.github.io/tags/SpringBoot/"}]},{"title":"IDEA 创建 Maven + Spring Boot 项目并打包（jar 包）上传至 Linux 服务器上运行","slug":"IDEA-创建-Maven-Spring-Boot-项目并打包（jar-包）上传至-Linux-服务器上运行","date":"2018-11-07T16:58:32.000Z","updated":"2018-11-08T17:20:20.514Z","comments":true,"path":"2018/11/08/IDEA-创建-Maven-Spring-Boot-项目并打包（jar-包）上传至-Linux-服务器上运行/","link":"","permalink":"https://wyxwx.github.io/2018/11/08/IDEA-创建-Maven-Spring-Boot-项目并打包（jar-包）上传至-Linux-服务器上运行/","excerpt":"首先打开 IDEA 并点击 New Project，进入如下页面 点击 Maven，选中”Create from archetype” 选择 quickstart 然后 next","text":"首先打开 IDEA 并点击 New Project，进入如下页面 点击 Maven，选中”Create from archetype” 选择 quickstart 然后 next GroupId 为 package 名，ArtifactId 为项目名称，点击 next 不用改动，直接 next（有教程说要添加一个什么东西来防止下载速度过慢，笔者用了另一种办法，后面描述，所以这里不需要改动） 这个页面也不用改动，直接 finish 进入项目后，先去修改 pom.xml 文件，首先添加图中圈出的三处（version 请视自己具体所用版本而定） 接着在 dependencies 标签内添加以下配置 12345678910111213141516171819202122232425262728293031323334&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 然后将 build 标签改为下图所示 此时右下角可能会出现下图所示的小窗口，并且一直停滞，这就是上面所提到的问题，此时，下载 archetype-catalog.xml 文件，并将其放在 C 盘 .m2 文件的根目录下 关闭项目后再次打开发现下载速度明显提升并且很快结束下载 然后在 main 目录下创建文件夹 resources 并且设置为 Resources Root 在 Resources 目录下创建 application.properties 文件并填写有关数据库的配置（这里配置端口是因为笔者的服务器中8080端口已被占用，所以使用了另外的端口） 123456spring.datasource.url=jdbc:mysql://localhost:3306/basketball?serverTimezone=GMT&amp;allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=root`# 设置 tomcat 端口为 8880server.port=8880 此时，正式开始代码部分 在 com.hello 包下创建 controller 包， 并在其下创建 HelloController 类 在其中编写代码 1234567891011121314package com.hello.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;@RestControllerpublic class HelloController &#123; @GetMapping(value = \"/hello\") public Map&lt;String, Object&gt; hello()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"hello\", \"Hello world!\"); return map; &#125;&#125; 打开 App.java 为 App 添加注解 @SpringBootApplication，并在 Main 函数中运行 SpringApplication.run(App.class, args); 1234567891011package com.hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class App&#123; public static void main( String[] args ) &#123; SpringApplication.run(App.class, args); &#125;&#125; 此时，代码部分已经结束，开始进行下一步，按图中箭头所示进行操作 Name 可以自己取，Main class 选取添加了 @SpringBootApplication 注解的 App 类，直接 ok 运行后用 Postman（Get 方法也可以在浏览器地址栏直接访问） 访问 url，成功返回 接下来，将项目打包为 jar 包并上传至服务器 在 View 中的 Tool Windows 找到Maven Projects 并打开 先双击 clean （如果是第一次则不需要） 然后双击 install 此时，打包成功 在 target 目录下可以看到生成的 .jar 文件 然后利用 FileZilla 将 jar 包上传至服务器文件 利用 PuTTY 登录云服务器，进入到所上传 jar 包的目录下 运行 jar 包有两种方式 1234# 直接运行，当该窗口关闭时程序终止java -jar xxxx.jar# 持久运行，即便窗口关闭程序也不会终止nohup java -jar xxxx.jar &amp; 这里运用第二种方法 此时 hello.jar 已在运行，并且将日志存放在 nohup.out 文件中 12# 查看日志， Ctrl + C 退出查看tail -100f nohup.out 此时再次通过 Postman 访问路径，可以成功得到返回结果 若想关闭 jar 包的运行，首先要查看当前 jar 包的进程号，然后利用 kill 命令杀死进程 1234# 查看 xxxx.jar 运行的进程号ps -ef|grep xxxx.jar# 关闭进程号为 xx 的进程 kill xx","categories":[{"name":"JavaEE 学习之路","slug":"JavaEE-学习之路","permalink":"https://wyxwx.github.io/categories/JavaEE-学习之路/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wyxwx.github.io/tags/SpringBoot/"},{"name":"Maven","slug":"Maven","permalink":"https://wyxwx.github.io/tags/Maven/"},{"name":"Linux 云服务器","slug":"Linux-云服务器","permalink":"https://wyxwx.github.io/tags/Linux-云服务器/"}]},{"title":"Spring Boot 项目在本地可以成功访问但是在服务器上无法访问 Controller 方法解决办法","slug":"Spring-Boot-项目在本地可以成功访问但是在服务器上无法访问-Controller-方法解决办法","date":"2018-11-07T16:24:51.000Z","updated":"2018-11-08T17:19:29.029Z","comments":true,"path":"2018/11/08/Spring-Boot-项目在本地可以成功访问但是在服务器上无法访问-Controller-方法解决办法/","link":"","permalink":"https://wyxwx.github.io/2018/11/08/Spring-Boot-项目在本地可以成功访问但是在服务器上无法访问-Controller-方法解决办法/","excerpt":"这是一篇记录自己失了智的博客 晚上写了一个小 Demo 来测试在云服务器上同时运行两个 jar 包的情况 两个项目的端口分别为 8080 和 8880 以 8880 为端口的 Demo 在本地成功运行并且访问到了 Controller 中的方法","text":"这是一篇记录自己失了智的博客 晚上写了一个小 Demo 来测试在云服务器上同时运行两个 jar 包的情况 两个项目的端口分别为 8080 和 8880 以 8880 为端口的 Demo 在本地成功运行并且访问到了 Controller 中的方法 在服务器运行后从日志中也可以确定成功完成了映射 但是就是没有办法通过服务器的 url 进行访问 百度了 N 久都没有找到和我相同的问题，直到被大佬指点之后才意识到，我的服务器的安全组中没有添加 8880 这个端口，换言之，请求被防火墙拦截了。去将 8880 添加到安全组后，再次访问，成功返回 “Hello world!”","categories":[{"name":"踩坑之路","slug":"踩坑之路","permalink":"https://wyxwx.github.io/categories/踩坑之路/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wyxwx.github.io/tags/SpringBoot/"},{"name":"无法访问 Controller","slug":"无法访问-Controller","permalink":"https://wyxwx.github.io/tags/无法访问-Controller/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-06T13:38:41.928Z","updated":"2018-11-08T17:11:59.737Z","comments":true,"path":"2018/11/06/hello-world/","link":"","permalink":"https://wyxwx.github.io/2018/11/06/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}